<!DOCTYPE html>
<html class="writer-html5" lang="en"><head>
  <meta charset="utf-8"><meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator">

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>cuCIM API Reference &mdash; cuCIM 21.12.00 documentation</title>
      <link href="_static/pygments.css" rel="stylesheet" type="text/css">
      <link href="_static/css/theme.css" rel="stylesheet" type="text/css">
      <link href="_static/params.css" rel="stylesheet" type="text/css">
      <link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script src="_static/js/theme.js"></script>
    <link href="genindex.html" rel="index" title="Index">
    <link href="search.html" rel="search" title="Search">
    <link href="index.html" rel="prev" title="Welcome to cuCIM&rsquo;s documentation!"> 
<link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav class="wy-nav-side" data-toggle="wy-nav-shift">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"><div id="rapids-jtd-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cucim</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/index.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rapids-cmake/stable/api.html">rapids-cmake</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (21.12)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cucim/nightly/api.html">nightly (21.12)</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">stable (21.10)</a><a class="rapids-selector__menu-item" href="/api/cucim/legacy/api.html">legacy (21.08)</a></div></div></div>
            
              
<div role="search">
  <form action="search.html" class="wy-form" id="rtd-search-form" method="get">
    <input name="q" placeholder="Search docs" type="text">
    <input name="check_keywords" type="hidden" value="yes">
    <input name="area" type="hidden" value="default">
  </form>
</div>
        </div><div aria-label="Navigation menu" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuCIM API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#cuimage-submodules">CuImage Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.CuImage">CuImage</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#skimage-submodules">skimage Submodules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.color">color</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.data">data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.exposure">exposure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.feature">feature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.filters">filters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.measure">measure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.metrics">metrics</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.morphology">morphology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.registration">registration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.restoration">restoration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.segmentation">segmentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.transform">transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage.util">util</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#submodule-contents">Submodule Contents</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cucim.skimage">skimage</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#utility-functions">Utility Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section class="wy-nav-content-wrap" data-toggle="wy-nav-shift"><nav aria-label="Mobile navigation menu" class="wy-nav-top">
          <i class="fa fa-bars" data-toggle="wy-nav-top"></i>
          <a href="index.html">cuCIM</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div aria-label="Page navigation" role="navigation">
  <ul class="wy-breadcrumbs">
      <li><a class="icon icon-home" href="index.html"></a> &raquo;</li>
      <li>cuCIM API Reference</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr>
</div>
          <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="cucim-api-reference">
<h1>cuCIM API Reference<a class="headerlink" href="#cucim-api-reference" title="Permalink to this headline">&para;</a></h1>
<section id="cuimage-submodules">
<h2>CuImage Submodules<a class="headerlink" href="#cuimage-submodules" title="Permalink to this headline">&para;</a></h2>
<section id="module-cucim.CuImage">
<span id="cuimage"></span><h3>CuImage<a class="headerlink" href="#module-cucim.CuImage" title="Permalink to this headline">&para;</a></h3>
<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.associated_images">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">associated_images</span></span><a class="headerlink" href="#cucim.CuImage.associated_images" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns a set of associated image names.</p>
<p>Digital Pathology image usually has a label/thumbnail or a macro image(low-power snapshot of the entire glass slide).
Names of those images (such as &lsquo;macro&rsquo; and &lsquo;label&rsquo;) are in <cite>associated_images</cite>.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.channel_names">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">channel_names</span></span><a class="headerlink" href="#cucim.CuImage.channel_names" title="Permalink to this definition">&para;</a></dt>
<dd><p>A channel name list.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.coord_sys">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">coord_sys</span></span><a class="headerlink" href="#cucim.CuImage.coord_sys" title="Permalink to this definition">&para;</a></dt>
<dd><p>Coordinate frame in which the direction cosines are measured.</p>
<p>Available Coordinate frame names are not finalized yet.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.device">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">device</span></span><a class="headerlink" href="#cucim.CuImage.device" title="Permalink to this definition">&para;</a></dt>
<dd><p>A device type.</p>
<p>By default t is <cite>cpu</cite> (It will be changed since v0.19.0).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.dims">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">dims</span></span><a class="headerlink" href="#cucim.CuImage.dims" title="Permalink to this definition">&para;</a></dt>
<dd><p>A string containing a list of dimensions being requested.</p>
<dl class="simple">
<dt>The default is to return the six standard dims (&lsquo;STCZYX&rsquo;) unless it is a DP multi-resolution image.</dt><dd><p>[sites, time, channel(or wavelength), z, y, x]. S - Sites or multiposition locations.</p>
</dd>
</dl>
<p>NOTE: in OME-TIFF&rsquo;s metadata, dimension order would be specified as &lsquo;XYZCTS&rsquo; (first one is fast-iterating dimension).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.direction">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">direction</span></span><a class="headerlink" href="#cucim.CuImage.direction" title="Permalink to this definition">&para;</a></dt>
<dd><p>Direction cosines (size is always 3x3).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.dtype">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#cucim.CuImage.dtype" title="Permalink to this definition">&para;</a></dt>
<dd><p>The data type of the image.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.is_loaded">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">is_loaded</span></span><a class="headerlink" href="#cucim.CuImage.is_loaded" title="Permalink to this definition">&para;</a></dt>
<dd><p>True if image data is loaded &amp; available.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.metadata">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">metadata</span></span><a class="headerlink" href="#cucim.CuImage.metadata" title="Permalink to this definition">&para;</a></dt>
<dd><p>A metadata object as <cite>dict</cite>.</p>
<p>It would be a dictionary(key-value pair) in general but can be a complex object (e.g., OME-TIFF metadata).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.ndim">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">ndim</span></span><a class="headerlink" href="#cucim.CuImage.ndim" title="Permalink to this definition">&para;</a></dt>
<dd><p>The number of dimensions.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.origin">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="#cucim.CuImage.origin" title="Permalink to this definition">&para;</a></dt>
<dd><p>Physical location of (0, 0, 0) (size is always 3).</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.path">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">path</span></span><a class="headerlink" href="#cucim.CuImage.path" title="Permalink to this definition">&para;</a></dt>
<dd><p>Underlying file path for this object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.raw_metadata">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">raw_metadata</span></span><a class="headerlink" href="#cucim.CuImage.raw_metadata" title="Permalink to this definition">&para;</a></dt>
<dd><p>A raw metadata string.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.resolutions">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">resolutions</span></span><a class="headerlink" href="#cucim.CuImage.resolutions" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns a dict that includes resolution information.</p>
<ul class="simple">
<li><p>level_count: The number of levels</p></li>
<li><p>level_dimensions: A tuple of dimension tuples (width, height)</p></li>
<li><p>level_downsamples: A tuple of down-sample factors</p></li>
<li><p>level_tile_sizes: A tuple of tile size tuple (tile width, tile_height)</p></li>
</ul>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="cucim.CuImage.shape">
<span class="sig-prename descclassname"><span class="pre">cucim.CuImage.</span></span><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#cucim.CuImage.shape" title="Permalink to this definition">&para;</a></dt>
<dd><p>A tuple of dimension sizes (in the order of <cite>dims</cite>)</p>
</dd></dl>

</section>
</section>
<section id="skimage-submodules">
<h2>skimage Submodules<a class="headerlink" href="#skimage-submodules" title="Permalink to this headline">&para;</a></h2>
<section id="module-cucim.skimage.color">
<span id="color"></span><h3>color<a class="headerlink" href="#module-cucim.skimage.color" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.combine_stains">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">combine_stains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">stains</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.combine_stains" title="Permalink to this definition">&para;</a></dt>
<dd><p>Stain to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stains</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in stain color space. Final dimension denotes channels.</p>
</dd>
<dt><strong>conv_matrix: ndarray</strong></dt><dd><p>The stain separation matrix as described by G. Landini <a class="reference internal" href="#rfb03de915426-1" id="id1">[1]</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>stains</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Stain combination matrices available in the <code class="docutils literal notranslate"><span class="pre">color</span></code> module and their
respective colorspace:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hed</span></code>: Hematoxylin + Eosin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hdx</span></code>: Hematoxylin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_fgx</span></code>: Feulgen + Light Green</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_bex</span></code>: Giemsa stain : Methyl Blue + Eosin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_rbd</span></code>: FastRed + FastBlue +  DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_gdx</span></code>: Methyl Green + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hax</span></code>: Hematoxylin + AEC</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_bro</span></code>: Blue matrix Anilline Blue + Red matrix Azocarmine                        + Orange matrix Orange-G</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_bpx</span></code>: Methyl Blue + Ponceau Fuchsin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_ahx</span></code>: Alcian Blue + Hematoxylin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rgb_from_hpx</span></code>: Hematoxylin + PAS</p></li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfb03de915426-1"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html">https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html</a></p>
</dd>
<dt class="label" id="rfb03de915426-2"><span class="brackets">2</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution,&rdquo; Anal. Quant. Cytol. Histol., vol.
23, no. 4, pp. 291&ndash;299, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="p">(</span><span class="n">separate_stains</span><span class="p">,</span> <span class="n">combine_stains</span><span class="p">,</span>
<span class="gp">... </span>                                   <span class="n">hdx_from_rgb</span><span class="p">,</span> <span class="n">rgb_from_hdx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hdx</span> <span class="o">=</span> <span class="n">separate_stains</span><span class="p">(</span><span class="n">ihc</span><span class="p">,</span> <span class="n">hdx_from_rgb</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_rgb</span> <span class="o">=</span> <span class="n">combine_stains</span><span class="p">(</span><span class="n">ihc_hdx</span><span class="p">,</span> <span class="n">rgb_from_hdx</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.convert_colorspace">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">convert_colorspace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fromspace</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tospace</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.convert_colorspace" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image array to a new color space.</p>
<dl class="simple">
<dt>Valid color spaces are:</dt><dd><p>&lsquo;RGB&rsquo;, &lsquo;HSV&rsquo;, &lsquo;RGB CIE&rsquo;, &lsquo;XYZ&rsquo;, &lsquo;YUV&rsquo;, &lsquo;YIQ&rsquo;, &lsquo;YPbPr&rsquo;, &lsquo;YCbCr&rsquo;, &lsquo;YDbDr&rsquo;</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image to convert. Final dimension denotes channels.</p>
</dd>
<dt><strong>fromspace</strong><span class="classifier">str</span></dt><dd><p>The color space to convert from. Can be specified in lower case.</p>
</dd>
<dt><strong>tospace</strong><span class="classifier">str</span></dt><dd><p>The color space to convert to. Can be specified in lower case.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The converted image. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If fromspace is not a valid color space</p>
</dd>
<dt>ValueError</dt><dd><p>If tospace is not a valid color space</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Conversion is performed through the &ldquo;central&rdquo; RGB color space,
i.e. conversion from XYZ to HSV is implemented as <code class="docutils literal notranslate"><span class="pre">XYZ</span> <span class="pre">-&gt;</span> <span class="pre">RGB</span> <span class="pre">-&gt;</span> <span class="pre">HSV</span></code>
instead of directly.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_hsv</span> <span class="o">=</span> <span class="n">convert_colorspace</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="s1">'RGB'</span><span class="p">,</span> <span class="s1">'HSV'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_cie76">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_cie76</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_cie76" title="Permalink to this definition">&para;</a></dt>
<dd><p>Euclidean distance between two points in Lab color space</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dE</strong><span class="classifier">array_like</span></dt><dd><p>distance between colors <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r98e40734704d-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="r98e40734704d-2"><span class="brackets">2</span></dt>
<dd><p>A. R. Robertson, &ldquo;The CIE 1976 color-difference formulae,&rdquo;
Color Res. Appl. 2, 7-11 (1977).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_ciede2000">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_ciede2000</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kH</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_ciede2000" title="Permalink to this definition">&para;</a></dt>
<dd><p>Color difference as given by the CIEDE 2000 standard.</p>
<p>CIEDE 2000 is a major revision of CIDE94.  The perceptual calibration is
largely based on experience with automotive paint on smooth surfaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
<dt><strong>kL</strong><span class="classifier">float (range), optional</span></dt><dd><p>lightness scale factor, 1 for &ldquo;acceptably close&rdquo;; 2 for &ldquo;imperceptible&rdquo;
see deltaE_cmc</p>
</dd>
<dt><strong>kC</strong><span class="classifier">float (range), optional</span></dt><dd><p>chroma scale factor, usually 1</p>
</dd>
<dt><strong>kH</strong><span class="classifier">float (range), optional</span></dt><dd><p>hue scale factor, usually 1</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>deltaE</strong><span class="classifier">array_like</span></dt><dd><p>The distance between <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>CIEDE 2000 assumes parametric weighting factors for the lightness, chroma,
and hue (<cite>kL</cite>, <cite>kC</cite>, <cite>kH</cite> respectively).  These default to 1.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbfde64bae038-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="rbfde64bae038-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf">http://www.ece.rochester.edu/~gsharma/ciede2000/ciede2000noteCRNA.pdf</a>
<a class="reference external" href="https://doi.org/10.1364/AO.33.008069">DOI:10.1364/AO.33.008069</a></p>
</dd>
<dt class="label" id="rbfde64bae038-3"><span class="brackets">3</span></dt>
<dd><p>M. Melgosa, J. Quesada, and E. Hita, &ldquo;Uniformity of some recent
color metrics tested with an accurate color-difference tolerance
dataset,&rdquo; Appl. Opt. 33, 8069-8077 (1994).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_ciede94">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_ciede94</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kH</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.045</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.015</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_ciede94" title="Permalink to this definition">&para;</a></dt>
<dd><p>Color difference according to CIEDE 94 standard</p>
<p>Accommodates perceptual non-uniformities through the use of application
specific scale factors (<cite>kH</cite>, <cite>kC</cite>, <cite>kL</cite>, <cite>k1</cite>, and <cite>k2</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
<dt><strong>kH</strong><span class="classifier">float, optional</span></dt><dd><p>Hue scale</p>
</dd>
<dt><strong>kC</strong><span class="classifier">float, optional</span></dt><dd><p>Chroma scale</p>
</dd>
<dt><strong>kL</strong><span class="classifier">float, optional</span></dt><dd><p>Lightness scale</p>
</dd>
<dt><strong>k1</strong><span class="classifier">float, optional</span></dt><dd><p>first scale parameter</p>
</dd>
<dt><strong>k2</strong><span class="classifier">float, optional</span></dt><dd><p>second scale parameter</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dE</strong><span class="classifier">array_like</span></dt><dd><p>color difference between <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>deltaE_ciede94 is not symmetric with respect to lab1 and lab2.  CIEDE94
defines the scales for the lightness, hue, and chroma in terms of the first
color.  Consequently, the first color should be regarded as the &ldquo;reference&rdquo;
color.</p>
<p><cite>kL</cite>, <cite>k1</cite>, <cite>k2</cite> depend on the application and default to the values
suggested for graphic arts</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 29%">
<col style="width: 41%">
<col style="width: 29%">
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Parameter</p></th>
<th class="head"><p>Graphic Arts</p></th>
<th class="head"><p>Textiles</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>kL</cite></p></td>
<td><p>1.000</p></td>
<td><p>2.000</p></td>
</tr>
<tr class="row-odd"><td><p><cite>k1</cite></p></td>
<td><p>0.045</p></td>
<td><p>0.048</p></td>
</tr>
<tr class="row-even"><td><p><cite>k2</cite></p></td>
<td><p>0.015</p></td>
<td><p>0.014</p></td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rabb6f51f8faf-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="rabb6f51f8faf-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html">http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.deltaE_cmc">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">deltaE_cmc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lab2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kL</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kC</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.deltaE_cmc" title="Permalink to this definition">&para;</a></dt>
<dd><p>Color difference from the  CMC l:c standard.</p>
<p>This color difference was developed by the Colour Measurement Committee
(CMC) of the Society of Dyers and Colourists (United Kingdom). It is
intended for use in the textile industry.</p>
<p>The scale factors <cite>kL</cite>, <cite>kC</cite> set the weight given to differences in
lightness and chroma relative to differences in hue.  The usual values are
<code class="docutils literal notranslate"><span class="pre">kL=2</span></code>, <code class="docutils literal notranslate"><span class="pre">kC=1</span></code> for &ldquo;acceptability&rdquo; and <code class="docutils literal notranslate"><span class="pre">kL=1</span></code>, <code class="docutils literal notranslate"><span class="pre">kC=1</span></code> for
&ldquo;imperceptibility&rdquo;.  Colors with <code class="docutils literal notranslate"><span class="pre">dE</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> are &ldquo;different&rdquo; for the given
scale factors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab1</strong><span class="classifier">array_like</span></dt><dd><p>reference color (Lab colorspace)</p>
</dd>
<dt><strong>lab2</strong><span class="classifier">array_like</span></dt><dd><p>comparison color (Lab colorspace)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dE</strong><span class="classifier">array_like</span></dt><dd><p>distance between colors <cite>lab1</cite> and <cite>lab2</cite></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>deltaE_cmc the defines the scales for the lightness, hue, and chroma
in terms of the first color.  Consequently
<code class="docutils literal notranslate"><span class="pre">deltaE_cmc(lab1,</span> <span class="pre">lab2)</span> <span class="pre">!=</span> <span class="pre">deltaE_cmc(lab2,</span> <span class="pre">lab1)</span></code></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r67a10bd0d57d-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Color_difference">https://en.wikipedia.org/wiki/Color_difference</a></p>
</dd>
<dt class="label" id="r67a10bd0d57d-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html">http://www.brucelindbloom.com/index.html?Eqn_DeltaE_CIE94.html</a></p>
</dd>
<dt class="label" id="r67a10bd0d57d-3"><span class="brackets">3</span></dt>
<dd><p>F. J. J. Clarke, R. McDonald, and B. Rigg, &ldquo;Modification to the
JPC79 colour-difference formula,&rdquo; J. Soc. Dyers Colour. 100, 128-132
(1984).</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.gray2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">gray2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.gray2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create an RGB representation of a gray-level image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">bool, optional</span></dt><dd><p>Ensure that the output image has an alpha layer. If None,
alpha layers are passed through but not created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>RGB image. A new dimension of length 3 is added to input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the input is a 1-dimensional image of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">)</span></code>, the output
will be shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">3)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.gray2rgba">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">gray2rgba</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.gray2rgba" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create a RGBA representation of a gray-level image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">array_like, optional</span></dt><dd><p>Alpha channel of the output image. It may be a scalar or an
array that can be broadcast to <code class="docutils literal notranslate"><span class="pre">image</span></code>. If not specified it is
set to the maximum limit corresponding to the <code class="docutils literal notranslate"><span class="pre">image</span></code> dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgba</strong><span class="classifier">ndarray</span></dt><dd><p>RGBA image. A new dimension of length 4 is added to input
image shape.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.grey2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">grey2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.grey2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create an RGB representation of a gray-level image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array_like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">bool, optional</span></dt><dd><p>Ensure that the output image has an alpha layer. If None,
alpha layers are passed through but not created.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>RGB image. A new dimension of length 3 is added to input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the input is a 1-dimensional image of shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">)</span></code>, the output
will be shape <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">3)</span></code>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.hed2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">hed2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.hed2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>Haematoxylin-Eosin-DAB (HED) to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hed</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in the HED color space. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>hed</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdaa655cd9550-1"><span class="brackets">1</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution.,&rdquo; Analytical and quantitative
cytology and histology / the International Academy of Cytology [and]
American Society of Cytology, vol. 23, no. 4, pp. 291-9, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2hed</span><span class="p">,</span> <span class="n">hed2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hed</span> <span class="o">=</span> <span class="n">rgb2hed</span><span class="p">(</span><span class="n">ihc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_rgb</span> <span class="o">=</span> <span class="n">hed2rgb</span><span class="p">(</span><span class="n">ihc_hed</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.hsv2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">hsv2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">hsv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.hsv2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>HSV to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>hsv</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in HSV format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>hsv</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Conversion between RGB and HSV color spaces results in some loss of
precision, due to integer arithmetic and rounding <a class="reference internal" href="#r9b32ad9e2308-1" id="id15">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9b32ad9e2308-1"><span class="brackets"><a class="fn-backref" href="#id15">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">https://en.wikipedia.org/wiki/HSL_and_HSV</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_hsv</span> <span class="o">=</span> <span class="n">rgb2hsv</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">hsv2rgb</span><span class="p">(</span><span class="n">img_hsv</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lab2lch">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lab2lch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lab2lch" title="Permalink to this definition">&para;</a></dt>
<dd><p>CIE-LAB to CIE-LCH color space conversion.</p>
<p>LCH is the cylindrical representation of the LAB (Cartesian) colorspace</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The N-D image in CIE-LAB format. The last (<code class="docutils literal notranslate"><span class="pre">N+1</span></code>-th) dimension must
have at least 3 elements, corresponding to the <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code>
color channels. Subsequent elements are copied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in LCH format, in a N-D array with same shape as input <cite>lab</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lch</cite> does not have at least 3 color channels (i.e. l, a, b).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Hue is expressed as an angle between <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">2*pi)</span></code></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2lab</span><span class="p">,</span> <span class="n">lab2lch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab</span> <span class="o">=</span> <span class="n">rgb2lab</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lch</span> <span class="o">=</span> <span class="n">lab2lch</span><span class="p">(</span><span class="n">img_lab</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lab2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lab2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lab2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>Lab to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in Lab format. Final dimension denotes channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lab</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses lab2xyz and xyz2rgb.
By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values
x_ref=95.047, y_ref=100., z_ref=108.883. See function <cite>get_xyz_coords</cite> for
a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4748a0929677-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Standard_illuminant">https://en.wikipedia.org/wiki/Standard_illuminant</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lab2xyz">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lab2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lab</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lab2xyz" title="Permalink to this definition">&para;</a></dt>
<dd><p>CIE-LAB to XYZcolor space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lab</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in Lab format. Final dimension denotes channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in XYZ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lab</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle are not supported or
unknown.</p>
</dd>
<dt>UserWarning</dt><dd><p>If any of the pixels are invalid (Z &lt; 0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values x_ref
= 95.047, y_ref = 100., z_ref = 108.883. See function &lsquo;get_xyz_coords&rsquo; for
a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r06a92c61e103-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=07">http://www.easyrgb.com/index.php?X=MATH&amp;H=07</a></p>
</dd>
<dt class="label" id="r06a92c61e103-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lab_color_space">https://en.wikipedia.org/wiki/Lab_color_space</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.label2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">label2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bg_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'overlay'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.label2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return an RGB image where color-coded labels are painted over the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">array, shape (M, N)</span></dt><dd><p>Integer array of labels with the same shape as <cite>image</cite>.</p>
</dd>
<dt><strong>image</strong><span class="classifier">array, shape (M, N, 3), optional</span></dt><dd><p>Image used as underlay for labels. If the input is an RGB image, it&rsquo;s
converted to grayscale before coloring.</p>
</dd>
<dt><strong>colors</strong><span class="classifier">list, optional</span></dt><dd><p>List of colors. If the number of labels exceeds the number of colors,
then the colors are cycled.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float [0, 1], optional</span></dt><dd><p>Opacity of colorized labels. Ignored if image is <cite>None</cite>.</p>
</dd>
<dt><strong>bg_label</strong><span class="classifier">int, optional</span></dt><dd><p>Label that&rsquo;s treated as the background. If <cite>bg_label</cite> is specified,
<cite>bg_color</cite> is <cite>None</cite>, and <cite>kind</cite> is <cite>overlay</cite>,
background is not painted by any colors.</p>
</dd>
<dt><strong>bg_color</strong><span class="classifier">str or array, optional</span></dt><dd><p>Background color. Must be a name in <cite>color_dict</cite> or RGB float values
between [0, 1].</p>
</dd>
<dt><strong>image_alpha</strong><span class="classifier">float [0, 1], optional</span></dt><dd><p>Opacity of the image.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">string, one of {&lsquo;overlay&rsquo;, &lsquo;avg&rsquo;}</span></dt><dd><p>The kind of color image desired. &lsquo;overlay&rsquo; cycles over defined colors
and overlays the colored labels over the original image. &lsquo;avg&rsquo; replaces
each labeled segment with its average color, for a stained-class or
pastel painting appearance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">array of float, shape (M, N, 3)</span></dt><dd><p>The result of blending a cycling colormap (<cite>colors</cite>) for each distinct
value in <cite>label</cite> with the image, at a certain alpha value.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.lch2lab">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">lch2lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lch</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.lch2lab" title="Permalink to this definition">&para;</a></dt>
<dd><p>CIE-LCH to CIE-LAB color space conversion.</p>
<p>LCH is the cylindrical representation of the LAB (Cartesian) colorspace</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>lch</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The N-D image in CIE-LCH format. The last (<code class="docutils literal notranslate"><span class="pre">N+1</span></code>-th) dimension must
have at least 3 elements, corresponding to the <code class="docutils literal notranslate"><span class="pre">L</span></code>, <code class="docutils literal notranslate"><span class="pre">a</span></code>, and <code class="docutils literal notranslate"><span class="pre">b</span></code>
color channels.  Subsequent elements are copied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in LAB format, with same shape as input <cite>lch</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>lch</cite> does not have at least 3 color channels (i.e. l, c, h).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2lab</span><span class="p">,</span> <span class="n">lch2lab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab</span> <span class="o">=</span> <span class="n">rgb2lab</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lch</span> <span class="o">=</span> <span class="n">lab2lch</span><span class="p">(</span><span class="n">img_lab</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab2</span> <span class="o">=</span> <span class="n">lch2lab</span><span class="p">(</span><span class="n">img_lch</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.luv2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">luv2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">luv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.luv2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>Luv to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>luv</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in CIE Luv format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>luv</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses luv2xyz and xyz2rgb.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.luv2xyz">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">luv2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">luv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.luv2xyz" title="Permalink to this definition">&para;</a></dt>
<dd><p>CIE-Luv to XYZ color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>luv</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in CIE-Luv format. Final dimension denotes channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in XYZ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>luv</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle are not supported or
unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>XYZ conversion weights use observer=2A. Reference whitepoint for D65
Illuminant, with XYZ tristimulus values of <code class="docutils literal notranslate"><span class="pre">(95.047,</span> <span class="pre">100.,</span> <span class="pre">108.883)</span></code>. See
function &lsquo;get_xyz_coords&rsquo; for a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf6e473b85d39-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16">http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16</a></p>
</dd>
<dt class="label" id="rf6e473b85d39-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELUV">https://en.wikipedia.org/wiki/CIELUV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2gray">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2gray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2gray" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute luminance of an RGB image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The luminance image - an array which is the same size as the input
array, but with the channel dimension removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The weights used in this conversion are calibrated for contemporary
CRT phosphors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">=</span> <span class="mf">0.2125</span> <span class="n">R</span> <span class="o">+</span> <span class="mf">0.7154</span> <span class="n">G</span> <span class="o">+</span> <span class="mf">0.0721</span> <span class="n">B</span>
</pre></div>
</div>
<p>If there is an alpha channel present, it is ignored.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7deaec9cd8c6-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://poynton.ca/PDFs/ColorFAQ.pdf">http://poynton.ca/PDFs/ColorFAQ.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_gray</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2grey">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2grey</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2grey" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute luminance of an RGB image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>The luminance image - an array which is the same size as the input
array, but with the channel dimension removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The weights used in this conversion are calibrated for contemporary
CRT phosphors:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Y</span> <span class="o">=</span> <span class="mf">0.2125</span> <span class="n">R</span> <span class="o">+</span> <span class="mf">0.7154</span> <span class="n">G</span> <span class="o">+</span> <span class="mf">0.0721</span> <span class="n">B</span>
</pre></div>
</div>
<p>If there is an alpha channel present, it is ignored.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd569bec71759-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://poynton.ca/PDFs/ColorFAQ.pdf">http://poynton.ca/PDFs/ColorFAQ.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_gray</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2hed">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2hed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2hed" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to Haematoxylin-Eosin-DAB (HED) color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in HED format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd1ab26ad5612-1"><span class="brackets">1</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution.,&rdquo; Analytical and quantitative
cytology and histology / the International Academy of Cytology [and]
American Society of Cytology, vol. 23, no. 4, pp. 291-9, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2hed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hed</span> <span class="o">=</span> <span class="n">rgb2hed</span><span class="p">(</span><span class="n">ihc</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2hsv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2hsv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2hsv" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to HSV color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in HSV format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Conversion between RGB and HSV color spaces results in some loss of
precision, due to integer arithmetic and rounding <a class="reference internal" href="#r67d3a639daac-1" id="id25">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r67d3a639daac-1"><span class="brackets"><a class="fn-backref" href="#id25">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/HSL_and_HSV">https://en.wikipedia.org/wiki/HSL_and_HSV</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_hsv</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2hsv</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2lab">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2lab" title="Permalink to this definition">&para;</a></dt>
<dd><p>Conversion from the sRGB color space (IEC 61966-2-1:1999)
to the CIE Lab colorspace under the given illuminant and observer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in Lab format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>RGB is a device-dependent color space so, if you use this function, be
sure that the image you are analyzing has been mapped to the sRGB color
space.</p>
<p>This function uses rgb2xyz and xyz2lab.
By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values
x_ref=95.047, y_ref=100., z_ref=108.883. See function <cite>get_xyz_coords</cite> for
a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc0871f9b8d8e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Standard_illuminant">https://en.wikipedia.org/wiki/Standard_illuminant</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2luv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2luv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2luv" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to CIE-Luv color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in CIE Luv format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function uses rgb2xyz and xyz2luv.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7f191d586ee8-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16">http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16</a></p>
</dd>
<dt class="label" id="r7f191d586ee8-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=02#text2">http://www.easyrgb.com/index.php?X=MATH&amp;H=02#text2</a></p>
</dd>
<dt class="label" id="r7f191d586ee8-3"><span class="brackets">3</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELUV">https://en.wikipedia.org/wiki/CIELUV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2rgbcie">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2rgbcie</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2rgbcie" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to RGB CIE color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB CIE format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb91e96098763-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2rgbcie</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgbcie</span> <span class="o">=</span> <span class="n">rgb2rgbcie</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2xyz">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2xyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2xyz" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to XYZ color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in XYZ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The CIE XYZ color space is derived from the CIE RGB color space. Note
however that this function converts from sRGB.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd54030807848-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2ycbcr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2ycbcr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2ycbcr" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to YCbCr color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in YCbCr format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Y is between 16 and 235. This is the color space commonly used by video
codecs; it is sometimes incorrectly called &ldquo;YUV&rdquo;.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1072114a30cf-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YCbCr">https://en.wikipedia.org/wiki/YCbCr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2ydbdr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2ydbdr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2ydbdr" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to YDbDr color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in YDbDr format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is the color space commonly used by video codecs. It is also the
reversible color transform in JPEG2000.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r58826d6bd44c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YDbDr">https://en.wikipedia.org/wiki/YDbDr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2yiq">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2yiq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2yiq" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to YIQ color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in YIQ format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2ypbpr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2ypbpr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2ypbpr" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to YPbPr color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in YPbPr format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r89d5df5bad40-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YPbPr">https://en.wikipedia.org/wiki/YPbPr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgb2yuv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgb2yuv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgb2yuv" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to YUV color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in YUV format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Y is between 0 and 1.  Use YCbCr instead of YUV for the color space
commonly used by video codecs, where Y ranges from 16 to 235.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4cf337b1a585-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YUV">https://en.wikipedia.org/wiki/YUV</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgba2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgba2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgba</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">1)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgba2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGBA to RGB conversion using alpha blending <a class="reference internal" href="#r06de24b6b99b-1" id="id37">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgba</strong><span class="classifier">(&hellip;, 4) array_like</span></dt><dd><p>The image in RGBA format. Final dimension denotes channels.</p>
</dd>
<dt><strong>background</strong><span class="classifier">array_like</span></dt><dd><p>The color of the background to blend the image with (3 floats
between 0 to 1 - the RGB value of the background).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgba</cite> is not at least 2-D with shape (&hellip;, 4).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r06de24b6b99b-1"><span class="brackets"><a class="fn-backref" href="#id37">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending">https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgba</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">logo</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgba2rgb</span><span class="p">(</span><span class="n">img_rgba</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.rgbcie2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">rgbcie2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgbcie</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.rgbcie2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB CIE to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgbcie</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB CIE format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgbcie</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="radd4167d6800-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2rgbcie</span><span class="p">,</span> <span class="n">rgbcie2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgbcie</span> <span class="o">=</span> <span class="n">rgb2rgbcie</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">rgbcie2rgb</span><span class="p">(</span><span class="n">img_rgbcie</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.separate_stains">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">separate_stains</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rgb</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.separate_stains" title="Permalink to this definition">&para;</a></dt>
<dd><p>RGB to stain color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rgb</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in RGB format. Final dimension denotes channels.</p>
</dd>
<dt><strong>conv_matrix: ndarray</strong></dt><dd><p>The stain separation matrix as described by G. Landini <a class="reference internal" href="#rc537717e7931-1" id="id40">[1]</a>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in stain color space. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>rgb</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Stain separation matrices available in the <code class="docutils literal notranslate"><span class="pre">color</span></code> module and their
respective colorspace:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">hed_from_rgb</span></code>: Hematoxylin + Eosin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hdx_from_rgb</span></code>: Hematoxylin + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">fgx_from_rgb</span></code>: Feulgen + Light Green</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bex_from_rgb</span></code>: Giemsa stain : Methyl Blue + Eosin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rbd_from_rgb</span></code>: FastRed + FastBlue +  DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gdx_from_rgb</span></code>: Methyl Green + DAB</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hax_from_rgb</span></code>: Hematoxylin + AEC</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bro_from_rgb</span></code>: Blue matrix Anilline Blue + Red matrix Azocarmine                        + Orange matrix Orange-G</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">bpx_from_rgb</span></code>: Methyl Blue + Ponceau Fuchsin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ahx_from_rgb</span></code>: Alcian Blue + Hematoxylin</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hpx_from_rgb</span></code>: Hematoxylin + PAS</p></li>
</ul>
<p>This implementation borrows some ideas from DIPlib <a class="reference internal" href="#rc537717e7931-2" id="id41">[2]</a>, e.g. the
compensation using a small value to avoid log artifacts when
calculating the Beer-Lambert law.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rc537717e7931-1"><span class="brackets"><a class="fn-backref" href="#id40">1</a></span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html">https://web.archive.org/web/20160624145052/http://www.mecourse.com/landinig/software/cdeconv/cdeconv.html</a></p>
</dd>
<dt class="label" id="rc537717e7931-2"><span class="brackets"><a class="fn-backref" href="#id41">2</a></span></dt>
<dd><p><a class="reference external" href="https://github.com/DIPlib/diplib/">https://github.com/DIPlib/diplib/</a></p>
</dd>
<dt class="label" id="rc537717e7931-3"><span class="brackets">3</span></dt>
<dd><p>A. C. Ruifrok and D. A. Johnston, &ldquo;Quantification of histochemical
staining by color deconvolution,&rdquo; Anal. Quant. Cytol. Histol., vol.
23, no. 4, pp. 291&ndash;299, Aug. 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">separate_stains</span><span class="p">,</span> <span class="n">hdx_from_rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">immunohistochemistry</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ihc_hdx</span> <span class="o">=</span> <span class="n">separate_stains</span><span class="p">(</span><span class="n">ihc</span><span class="p">,</span> <span class="n">hdx_from_rgb</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.xyz2lab">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">xyz2lab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.xyz2lab" title="Permalink to this definition">&para;</a></dt>
<dd><p>XYZ to CIE-LAB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in XYZ format. Final dimension denotes channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in CIE-LAB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xyz</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle is unsupported or
unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default Observer= 2A, Illuminant= D65. CIE XYZ tristimulus values
x_ref=95.047, y_ref=100., z_ref=108.883. See function <cite>get_xyz_coords</cite> for
a list of supported illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r712a707c3b18-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=07">http://www.easyrgb.com/index.php?X=MATH&amp;H=07</a></p>
</dd>
<dt class="label" id="r712a707c3b18-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Lab_color_space">https://en.wikipedia.org/wiki/Lab_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2xyz</span><span class="p">,</span> <span class="n">xyz2lab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_lab</span> <span class="o">=</span> <span class="n">xyz2lab</span><span class="p">(</span><span class="n">img_xyz</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.xyz2luv">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">xyz2luv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">illuminant</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'D65'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">observer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'2'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.xyz2luv" title="Permalink to this definition">&para;</a></dt>
<dd><p>XYZ to CIE-Luv color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in XYZ format. Final dimension denotes channels.</p>
</dd>
<dt><strong>illuminant</strong><span class="classifier">{&ldquo;A&rdquo;, &ldquo;D50&rdquo;, &ldquo;D55&rdquo;, &ldquo;D65&rdquo;, &ldquo;D75&rdquo;, &ldquo;E&rdquo;}, optional</span></dt><dd><p>The name of the illuminant (the function is NOT case sensitive).</p>
</dd>
<dt><strong>observer</strong><span class="classifier">{&ldquo;2&rdquo;, &ldquo;10&rdquo;}, optional</span></dt><dd><p>The aperture angle of the observer.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in CIE-Luv format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xyz</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
<dt>ValueError</dt><dd><p>If either the illuminant or the observer angle are not supported or
unknown.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>By default XYZ conversion weights use observer=2A. Reference whitepoint
for D65 Illuminant, with XYZ tristimulus values of <code class="docutils literal notranslate"><span class="pre">(95.047,</span> <span class="pre">100.,</span>
<span class="pre">108.883)</span></code>. See function &lsquo;get_xyz_coords&rsquo; for a list of supported
illuminants.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r48d81901c134-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16">http://www.easyrgb.com/index.php?X=MATH&amp;H=16#text16</a></p>
</dd>
<dt class="label" id="r48d81901c134-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIELUV">https://en.wikipedia.org/wiki/CIELUV</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2xyz</span><span class="p">,</span> <span class="n">xyz2luv</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_luv</span> <span class="o">=</span> <span class="n">xyz2luv</span><span class="p">(</span><span class="n">img_xyz</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.xyz2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">xyz2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.xyz2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>XYZ to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xyz</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in XYZ format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>xyz</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The CIE XYZ color space is derived from the CIE RGB color space. Note
however that this function converts to sRGB.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb72411d50c27-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CIE_1931_color_space">https://en.wikipedia.org/wiki/CIE_1931_color_space</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2xyz</span><span class="p">,</span> <span class="n">xyz2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_xyz</span> <span class="o">=</span> <span class="n">rgb2xyz</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_rgb</span> <span class="o">=</span> <span class="n">xyz2rgb</span><span class="p">(</span><span class="n">img_xyz</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.ycbcr2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">ycbcr2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ycbcr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.ycbcr2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>YCbCr to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ycbcr</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in YCbCr format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>ycbcr</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Y is between 16 and 235. This is the color space commonly used by video
codecs; it is sometimes incorrectly called &ldquo;YUV&rdquo;.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6327037fe147-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YCbCr">https://en.wikipedia.org/wiki/YCbCr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.ydbdr2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">ydbdr2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ydbdr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.ydbdr2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>YDbDr to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ydbdr</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in YDbDr format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>ydbdr</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is the color space commonly used by video codecs, also called the
reversible color transform in JPEG2000.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r480b557ed432-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YDbDr">https://en.wikipedia.org/wiki/YDbDr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.yiq2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">yiq2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yiq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.yiq2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>YIQ to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yiq</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in YIQ format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>yiq</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.ypbpr2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">ypbpr2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ypbpr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.ypbpr2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>YPbPr to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ypbpr</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in YPbPr format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>ypbpr</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1e0c80545ecc-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YPbPr">https://en.wikipedia.org/wiki/YPbPr</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.color.yuv2rgb">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.color.</span></span><span class="sig-name descname"><span class="pre">yuv2rgb</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">yuv</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.color.yuv2rgb" title="Permalink to this definition">&para;</a></dt>
<dd><p>YUV to RGB color space conversion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>yuv</strong><span class="classifier">(&hellip;, 3) array_like</span></dt><dd><p>The image in YUV format. Final dimension denotes channels.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(&hellip;, 3) ndarray</span></dt><dd><p>The image in RGB format. Same dimensions as input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <cite>yuv</cite> is not at least 2-D with shape (&hellip;, 3).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1f43f16bb221-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/YUV">https://en.wikipedia.org/wiki/YUV</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.data">
<span id="data"></span><h3>data<a class="headerlink" href="#module-cucim.skimage.data" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.data.binary_blobs">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.data.</span></span><span class="sig-name descname"><span class="pre">binary_blobs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">512</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blob_size_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">volume_fraction</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.data.binary_blobs" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generate synthetic binary image with several rounded blob-like objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>length</strong><span class="classifier">int, optional</span></dt><dd><p>Linear size of output image.</p>
</dd>
<dt><strong>blob_size_fraction</strong><span class="classifier">float, optional</span></dt><dd><p>Typical linear size of blob, as a fraction of <code class="docutils literal notranslate"><span class="pre">length</span></code>, should be
smaller than 1.</p>
</dd>
<dt><strong>n_dim</strong><span class="classifier">int, optional</span></dt><dd><p>Number of dimensions of output image.</p>
</dd>
<dt><strong>volume_fraction</strong><span class="classifier">float, default 0.5</span></dt><dd><p>Fraction of image pixels covered by the blobs (where the output is 1).
Should be in [0, 1].</p>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>Seed to initialize the random number generator.
If <cite>None</cite>, a random seed from the operating system is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>blobs</strong><span class="classifier">ndarray of bools</span></dt><dd><p>Output binary image</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Warning: CuPy does not give identical randomly generated numbers as NumPy,
so using a specific seed here will not give an identical pattern to the
scikit-image implementation.</p>
<p>The behavior for a given random seed may also change across CuPy major
versions.
See: <a class="reference external" href="https://docs.cupy.dev/en/stable/reference/random.html">https://docs.cupy.dev/en/stable/reference/random.html</a></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># tiny size (5, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">blob_size_fraction</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># larger size</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">blob_size_fraction</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Finer structures</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">blob_size_fraction</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Blobs cover a smaller volume fraction of the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blobs</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">binary_blobs</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">volume_fraction</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.exposure">
<span id="exposure"></span><h3>exposure<a class="headerlink" href="#module-cucim.skimage.exposure" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.adjust_gamma">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">adjust_gamma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.adjust_gamma" title="Permalink to this definition">&para;</a></dt>
<dd><p>Performs Gamma Correction on the input image.</p>
<p>Also known as Power Law Transform.
This function transforms the input image pixelwise according to the
equation <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">I**gamma</span></code> after scaling each pixel to the range 0 to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float, optional</span></dt><dd><p>Non negative real number. Default value is 1.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">float, optional</span></dt><dd><p>The constant multiplier. Default value is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Gamma corrected output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.adjust_log" title="cucim.skimage.exposure.adjust_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_log</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For gamma greater than 1, the histogram will shift towards left and
the output image will be darker than the input image.</p>
<p>For gamma less than 1, the histogram will shift towards right and
the output image will be brighter than the input image.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b2d42bd838c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gamma_correction">https://en.wikipedia.org/wiki/Gamma_correction</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">moon</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gamma_corrected</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">adjust_gamma</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Output is darker for gamma &gt; 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">gamma_corrected</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.adjust_log">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">adjust_log</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.adjust_log" title="Permalink to this definition">&para;</a></dt>
<dd><p>Performs Logarithmic correction on the input image.</p>
<p>This function transforms the input image pixelwise according to the
equation <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">gain*log(1</span> <span class="pre">+</span> <span class="pre">I)</span></code> after scaling each pixel to the range
0 to 1.</p>
<p>For inverse logarithmic correction, the equation is
<code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">gain*(2**I</span> <span class="pre">-</span> <span class="pre">1)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">float, optional</span></dt><dd><p>The constant multiplier. Default value is 1.</p>
</dd>
<dt><strong>inv</strong><span class="classifier">float, optional</span></dt><dd><p>If True, it performs inverse logarithmic correction,
else correction will be logarithmic. Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Logarithm corrected output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.adjust_gamma" title="cucim.skimage.exposure.adjust_gamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_gamma</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7be5bc73818c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://www.ece.ucsb.edu/Faculty/Manjunath/courses/ece178W03/EnhancePart1.pdf">http://www.ece.ucsb.edu/Faculty/Manjunath/courses/ece178W03/EnhancePart1.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.adjust_sigmoid">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">adjust_sigmoid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.adjust_sigmoid" title="Permalink to this definition">&para;</a></dt>
<dd><p>Performs Sigmoid Correction on the input image.</p>
<p>Also known as Contrast Adjustment.
This function transforms the input image pixelwise according to the
equation <code class="docutils literal notranslate"><span class="pre">O</span> <span class="pre">=</span> <span class="pre">1/(1</span> <span class="pre">+</span> <span class="pre">exp*(gain*(cutoff</span> <span class="pre">-</span> <span class="pre">I)))</span></code> after scaling each pixel
to the range 0 to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>cutoff</strong><span class="classifier">float, optional</span></dt><dd><p>Cutoff of the sigmoid function that shifts the characteristic curve
in horizontal direction. Default value is 0.5.</p>
</dd>
<dt><strong>gain</strong><span class="classifier">float, optional</span></dt><dd><p>The constant multiplier in exponential&rsquo;s power of sigmoid function.
Default value is 10.</p>
</dd>
<dt><strong>inv</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, returns the negative sigmoid correction. Defaults to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Sigmoid corrected output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.adjust_gamma" title="cucim.skimage.exposure.adjust_gamma"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjust_gamma</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0311c63269be-1"><span class="brackets">1</span></dt>
<dd><p>Gustav J. Braun, &ldquo;Image Lightness Rescaling Using Sigmoidal Contrast
Enhancement Functions&rdquo;,
<a class="reference external" href="http://www.cis.rit.edu/fairchild/PDFs/PAP07.pdf">http://www.cis.rit.edu/fairchild/PDFs/PAP07.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.cumulative_distribution">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">cumulative_distribution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.cumulative_distribution" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return cumulative distribution function (cdf) for the given image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins for image histogram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>img_cdf</strong><span class="classifier">array</span></dt><dd><p>Values of cumulative distribution function.</p>
</dd>
<dt><strong>bin_centers</strong><span class="classifier">array</span></dt><dd><p>Centers of bins.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.histogram" title="cucim.skimage.exposure.histogram"><code class="xref py py-obj docutils literal notranslate"><span class="pre">histogram</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r413c110ae5c3-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Cumulative_distribution_function">https://en.wikipedia.org/wiki/Cumulative_distribution_function</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hi</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cdf</span> <span class="o">=</span> <span class="n">exposure</span><span class="o">.</span><span class="n">cumulative_distribution</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">alltrue</span><span class="p">(</span><span class="n">cdf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cp</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">hi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.equalize_adapthist">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">equalize_adapthist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.equalize_adapthist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Contrast Limited Adaptive Histogram Equalization (CLAHE).</p>
<p>An algorithm for local contrast enhancement, that uses histograms computed
over different tile regions of the image. Local details can therefore be
enhanced even in regions that are darker or lighter than most of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N1, &hellip;,NN[, C]) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>kernel_size: int or array_like, optional</strong></dt><dd><p>Defines the shape of contextual regions used in the algorithm. If
iterable is passed, it must have the same number of elements as
<code class="docutils literal notranslate"><span class="pre">image.ndim</span></code> (without color channel). If integer, it is broadcasted
to each <cite>image</cite> dimension. By default, <code class="docutils literal notranslate"><span class="pre">kernel_size</span></code> is 1/8 of
<code class="docutils literal notranslate"><span class="pre">image</span></code> height by 1/8 of its width.</p>
</dd>
<dt><strong>clip_limit</strong><span class="classifier">float, optional</span></dt><dd><p>Clipping limit, normalized between 0 and 1 (higher values give more
contrast).</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of gray bins for histogram (&ldquo;data range&rdquo;).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N1, &hellip;,NN[, C]) ndarray</span></dt><dd><p>Equalized image with float64 dtype.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.equalize_hist" title="cucim.skimage.exposure.equalize_hist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_hist</span></code></a>, <a class="reference internal" href="#cucim.skimage.exposure.rescale_intensity" title="cucim.skimage.exposure.rescale_intensity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rescale_intensity</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><dl class="simple">
<dt>For color images, the following steps are performed:</dt><dd><ul>
<li><p>The image is converted to HSV color space</p></li>
<li><p>The CLAHE algorithm is run on the V (Value) channel</p></li>
<li><p>The image is converted back to RGB space and returned</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>For RGBA images, the original alpha channel is removed.</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.17: </span>The values returned by this function are slightly shifted upwards
because of an internal change in rounding behavior.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re69247a61663-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://tog.acm.org/resources/GraphicsGems/">http://tog.acm.org/resources/GraphicsGems/</a></p>
</dd>
<dt class="label" id="re69247a61663-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/CLAHE#CLAHE">https://en.wikipedia.org/wiki/CLAHE#CLAHE</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.equalize_hist">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">equalize_hist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.equalize_hist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return image after histogram equalization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins for image histogram. Note: this argument is
ignored for integer images, for which each integer is its own
bin.</p>
</dd>
<dt><strong>mask: ndarray of bools or 0s and 1s, optional</strong></dt><dd><p>Array of same shape as <cite>image</cite>. Only points at which mask == True
are used for the equalization, which is applied to the whole image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">float array</span></dt><dd><p>Image array after histogram equalization.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is adapted from <a class="reference internal" href="#r0b3e7653afbe-1" id="id60">[1]</a> with the author&rsquo;s permission.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b3e7653afbe-1"><span class="brackets"><a class="fn-backref" href="#id60">1</a></span></dt>
<dd><p><a class="reference external" href="http://www.janeriksolem.net/histogram-equalization-with-python-and.html">http://www.janeriksolem.net/histogram-equalization-with-python-and.html</a></p>
</dd>
<dt class="label" id="r0b3e7653afbe-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Histogram_equalization">https://en.wikipedia.org/wiki/Histogram_equalization</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.histogram">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">histogram</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'image'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.histogram" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return histogram of image.</p>
<p>Unlike <cite>numpy.histogram</cite>, this function returns the centers of bins and
does not rebin integer arrays. For integer arrays, each integer value has
its own bin, which improves speed and intensity-resolution.</p>
<p>The histogram is computed on the flattened image: for color images, the
function should be used separately on each channel to obtain a histogram
for each color channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>source_range</strong><span class="classifier">string, optional</span></dt><dd><p>&lsquo;image&rsquo; (default) determines the range from the input image.
&lsquo;dtype&rsquo; determines the range from the expected range of the images
of that data type.</p>
</dd>
<dt><strong>normalize</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, normalize the histogram by the sum of its values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>hist</strong><span class="classifier">array</span></dt><dd><p>The values of the histogram.</p>
</dd>
<dt><strong>bin_centers</strong><span class="classifier">array</span></dt><dd><p>The values at the center of the bins.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.cumulative_distribution" title="cucim.skimage.exposure.cumulative_distribution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumulative_distribution</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">exposure</span><span class="p">,</span> <span class="n">img_as_float</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">img_as_float</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(array([ 93585, 168559]), array([0. , 0.5, 1. ]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exposure</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(array([ 93585, 168559]), array([0.25, 0.75]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.is_low_contrast">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">is_low_contrast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fraction_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">99</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.is_low_contrast" title="Permalink to this definition">&para;</a></dt>
<dd><p>Determine if an image is low contrast.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array-like</span></dt><dd><p>The image under test.</p>
</dd>
<dt><strong>fraction_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>The low contrast fraction threshold. An image is considered low-
contrast when its range of brightness spans less than this
fraction of its data type&rsquo;s full range. <a class="reference internal" href="#r12f9fb47597e-1" id="id63">[1]</a></p>
</dd>
<dt><strong>lower_percentile</strong><span class="classifier">float, optional</span></dt><dd><p>Disregard values below this percentile when computing image contrast.</p>
</dd>
<dt><strong>upper_percentile</strong><span class="classifier">float, optional</span></dt><dd><p>Disregard values above this percentile when computing image contrast.</p>
</dd>
<dt><strong>method</strong><span class="classifier">str, optional</span></dt><dd><p>The contrast determination method.  Right now the only available
option is &ldquo;linear&rdquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd><p>True when the image is determined to be low contrast.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r12f9fb47597e-1"><span class="brackets"><a class="fn-backref" href="#id63">1</a></span></dt>
<dd><p><a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.04</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_low_contrast</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_low_contrast</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">is_low_contrast</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">upper_percentile</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.match_histograms">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">match_histograms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.match_histograms" title="Permalink to this definition">&para;</a></dt>
<dd><p>Adjust an image so that its cumulative histogram matches that of another.</p>
<p>The adjustment is applied separately for each channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. Can be gray-scale or in color.</p>
</dd>
<dt><strong>reference</strong><span class="classifier">ndarray</span></dt><dd><p>Image to match histogram of. Must have the same number of channels as
image.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Apply the matching separately for each channel.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>matched</strong><span class="classifier">ndarray</span></dt><dd><p>Transformed input image.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>Thrown when the number of channels in the input image and the reference
differ.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8109c05ff55e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://paulbourke.net/miscellaneous/equalisation/">http://paulbourke.net/miscellaneous/equalisation/</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.exposure.rescale_intensity">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.exposure.</span></span><span class="sig-name descname"><span class="pre">rescale_intensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'image'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dtype'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.exposure.rescale_intensity" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return image after stretching or shrinking its intensity levels.</p>
<p>The desired intensity range of the input and output, <cite>in_range</cite> and
<cite>out_range</cite> respectively, are used to stretch or shrink the intensity range
of the input image. See examples below.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>in_range, out_range</strong><span class="classifier">str or 2-tuple, optional</span></dt><dd><p>Min and max intensity values of input and output image.
The possible values for this parameter are enumerated below.</p>
<dl class="simple">
<dt>&lsquo;image&rsquo;</dt><dd><p>Use image min/max as the intensity range.</p>
</dd>
<dt>&lsquo;dtype&rsquo;</dt><dd><p>Use min/max of the image&rsquo;s dtype as the intensity range.</p>
</dd>
<dt>dtype-name</dt><dd><p>Use intensity range based on desired <cite>dtype</cite>. Must be valid key
in <cite>DTYPE_RANGE</cite>.</p>
</dd>
<dt>2-tuple</dt><dd><p>Use <cite>range_values</cite> as explicit min/max intensities.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Image array after rescaling its intensity. This image is the same dtype
as the input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.exposure.equalize_hist" title="cucim.skimage.exposure.equalize_hist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equalize_hist</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.17: </span>The dtype of the output array has changed to match the output dtype, or
float if the output range is specified by a pair of floats.</p>
</div>
<p class="rubric">Examples</p>
<p>By default, the min/max intensities of the input image are stretched to
the limits allowed by the image&rsquo;s dtype, since <cite>in_range</cite> defaults to
&lsquo;image&rsquo; and <cite>out_range</cite> defaults to &lsquo;dtype&rsquo;:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">51</span><span class="p">,</span> <span class="mi">102</span><span class="p">,</span> <span class="mi">153</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([  0, 127, 255], dtype=uint8)</span>
</pre></div>
</div>
<p>It&rsquo;s easy to accidentally convert an image dtype from uint8 to float:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">image</span>
<span class="go">array([ 51., 102., 153.])</span>
</pre></div>
</div>
<p>Use <cite>rescale_intensity</cite> to rescale to the proper range for float dtypes:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_float</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image_float</span><span class="p">)</span>
<span class="go">array([0. , 0.5, 1. ])</span>
</pre></div>
</div>
<p>To maintain the low contrast of the original, use the <cite>in_range</cite> parameter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image_float</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span>
<span class="go">array([0.2, 0.4, 0.6])</span>
</pre></div>
</div>
<p>If the min/max value of <cite>in_range</cite> is more/less than the min/max image
intensity, then the intensity levels are clipped:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image_float</span><span class="p">,</span> <span class="n">in_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">102</span><span class="p">))</span>
<span class="go">array([0.5, 1. , 1. ])</span>
</pre></div>
</div>
<p>If you have an image with signed integers but want to rescale the image to
just the positive range, use the <cite>out_range</cite> parameter. In that case, the
output dtype will be float:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">))</span>
<span class="go">array([  0. ,  63.5, 127. ])</span>
</pre></div>
</div>
<p>To get the desired range with a specific dtype, use <code class="docutils literal notranslate"><span class="pre">.astype()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rescale_intensity</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">out_range</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">127</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="go">array([  0,  63, 127], dtype=int8)</span>
</pre></div>
</div>
<p>If the input image is constant, the output will be clipped directly to the
output range:
&gt;&gt;&gt; image = cp.asarray([130, 130, 130], dtype=np.int32)
&gt;&gt;&gt; rescale_intensity(image, out_range=(0, 127)).astype(np.int32)
array([127, 127, 127], dtype=int32)</p>
</dd></dl>

</section>
<section id="module-cucim.skimage.feature">
<span id="feature"></span><h3>feature<a class="headerlink" href="#module-cucim.skimage.feature" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.canny">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">canny</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_quantiles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.canny" title="Permalink to this definition">&para;</a></dt>
<dd><p>Edge filter an image using the Canny algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2D array</span></dt><dd><p>Grayscale input image to detect edges on; can be of any dtype.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation of the Gaussian filter.</p>
</dd>
<dt><strong>low_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Lower bound for hysteresis thresholding (linking edges).
If None, low_threshold is set to 10% of dtype&rsquo;s max.</p>
</dd>
<dt><strong>high_threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Upper bound for hysteresis thresholding (linking edges).
If None, high_threshold is set to 20% of dtype&rsquo;s max.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array, dtype=bool, optional</span></dt><dd><p>Mask to limit the application of Canny to a certain area.</p>
</dd>
<dt><strong>use_quantiles</strong><span class="classifier">bool, optional</span></dt><dd><p>If True then treat low_threshold and high_threshold as quantiles of the
edge magnitude image, rather than absolute edge magnitude values. If
True, then the thresholds must be in the range [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2D array (image)</span></dt><dd><p>The binary edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.sobel</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The steps of the algorithm are as follows:</p>
<ul class="simple">
<li><p>Smooth the image using a Gaussian with <code class="docutils literal notranslate"><span class="pre">sigma</span></code> width.</p></li>
<li><p>Apply the horizontal and vertical Sobel operators to get the gradients
within the image. The edge strength is the norm of the gradient.</p></li>
<li><p>Thin potential edges to 1-pixel wide curves. First, find the normal
to the edge at each point. This is done by looking at the
signs and the relative magnitude of the X-Sobel and Y-Sobel
to sort the points into 4 categories: horizontal, vertical,
diagonal and antidiagonal. Then look in the normal and reverse
directions to see if the values in either of those directions are
greater than the point in question. Use interpolation to get a mix of
points instead of picking the one that&rsquo;s the closest to the normal.</p></li>
<li><p>Perform a hysteresis thresholding: first label all points above the
high threshold as edges. Then recursively label any point above the
low threshold that is 8-connected to a labeled point as an edge.</p></li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rda09548a1040-1"><span class="brackets">1</span></dt>
<dd><p>Canny, J., A Computational Approach To Edge Detection, IEEE Trans.
Pattern Analysis and Machine Intelligence, 8:679-714, 1986
<a class="reference external" href="https://doi.org/10.1109/TPAMI.1986.4767851">DOI:10.1109/TPAMI.1986.4767851</a></p>
</dd>
<dt class="label" id="rda09548a1040-2"><span class="brackets">2</span></dt>
<dd><p>William Green&rsquo;s Canny tutorial
<a class="reference external" href="https://en.wikipedia.org/wiki/Canny_edge_detector">https://en.wikipedia.org/wiki/Canny_edge_detector</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">feature</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Generate noisy image of a square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span><span class="p">[</span><span class="mi">64</span><span class="p">:</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span> <span class="mi">64</span><span class="p">:</span><span class="o">-</span><span class="mi">64</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">im</span> <span class="o">+=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># First trial with the Canny filter, with the default smoothing</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges1</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">canny</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Increase the smoothing for better results</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges2</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">canny</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_foerstner">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_foerstner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_foerstner" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute Foerstner corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="p">(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axx</span> <span class="n">Axy</span><span class="p">]</span>
    <span class="p">[(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)</span>   <span class="p">(</span><span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>   <span class="p">[</span><span class="n">Axy</span> <span class="n">Ayy</span><span class="p">]</span>
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">w</span> <span class="o">=</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>           <span class="p">(</span><span class="n">size</span> <span class="n">of</span> <span class="n">error</span> <span class="n">ellipse</span><span class="p">)</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>    <span class="p">(</span><span class="n">roundness</span> <span class="n">of</span> <span class="n">error</span> <span class="n">ellipse</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>w</strong><span class="classifier">ndarray</span></dt><dd><p>Error ellipse sizes.</p>
</dd>
<dt><strong>q</strong><span class="classifier">ndarray</span></dt><dd><p>Roundness of error ellipse.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b0ff10bd5c6-1"><span class="brackets">1</span></dt>
<dd><p>F&ouml;rstner, W., &amp; G&uuml;lch, E. (1987, June). A fast operator for
detection and precise location of distinct points, corners and
centres of circular features. In Proc. ISPRS intercommission
conference on fast processing of photogrammetric data (pp. 281-305).
<a class="reference external" href="https://cseweb.ucsd.edu/classes/sp02/cse252/foerstner/foerstner.pdf">https://cseweb.ucsd.edu/classes/sp02/cse252/foerstner/foerstner.pdf</a></p>
</dd>
<dt class="label" id="r0b0ff10bd5c6-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Corner_detection">https://en.wikipedia.org/wiki/Corner_detection</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">corner_foerstner</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">corner_foerstner</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">accuracy_thresh</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">roundness_thresh</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">foerstner</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">&gt;</span> <span class="n">roundness_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="n">accuracy_thresh</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">foerstner</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_harris">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_harris</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'k'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_harris" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute Harris corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="p">(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axx</span> <span class="n">Axy</span><span class="p">]</span>
    <span class="p">[(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)</span>   <span class="p">(</span><span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>   <span class="p">[</span><span class="n">Axy</span> <span class="n">Ayy</span><span class="p">]</span>
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">2</span> <span class="o">*</span> <span class="n">det</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">trace</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;k&rsquo;, &lsquo;eps&rsquo;}, optional</span></dt><dd><p>Method to compute the response image from the auto-correlation matrix.</p>
</dd>
<dt><strong>k</strong><span class="classifier">float, optional</span></dt><dd><p>Sensitivity factor to separate corners from edges, typically in range
<cite>[0, 0.2]</cite>. Small values of k result in detection of sharp corners.</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Normalisation factor (Noble&rsquo;s corner measure).</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>Harris response image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="re3d0143ef51f-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Corner_detection">https://en.wikipedia.org/wiki/Corner_detection</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">corner_harris</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_harris</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_kitchen_rosenfeld">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_kitchen_rosenfeld</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_kitchen_rosenfeld" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute Kitchen and Rosenfeld corner measure response image.</p>
<p>The corner measure is calculated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">imxx</span> <span class="o">*</span> <span class="n">imy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">imyy</span> <span class="o">*</span> <span class="n">imx</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">imxy</span> <span class="o">*</span> <span class="n">imx</span> <span class="o">*</span> <span class="n">imy</span><span class="p">)</span>
    <span class="o">/</span> <span class="p">(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Where imx and imy are the first and imxx, imxy, imyy the second
derivatives.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>Kitchen and Rosenfeld response image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra14f0c3b8083-1"><span class="brackets">1</span></dt>
<dd><p>Kitchen, L., &amp; Rosenfeld, A. (1982). Gray-level corner detection.
Pattern recognition letters, 1(2), 95-102.
<a class="reference external" href="https://doi.org/10.1016/0167-8655(82)90020-4">DOI:10.1016/0167-8655(82)90020-4</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_peaks">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_peaks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks_per_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_peaks" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find peaks in corner measure response image.</p>
<p>This differs from <cite>skimage.feature.peak_local_max</cite> in that it suppresses
multiple connected peaks with the same accumulator value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>The minimal allowed distance separating peaks.</p>
</dd>
<dt><strong>*</strong><span class="classifier">*</span></dt><dd><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">skimage.feature.peak_local_max()</span></code>.</p>
</dd>
<dt><strong>p_norm</strong><span class="classifier">float</span></dt><dd><p>Which Minkowski p-norm to use. Should be in the range [1, inf].
A finite large p may cause a ValueError if overflow can occur.
<code class="docutils literal notranslate"><span class="pre">inf</span></code> corresponds to the Chebyshev distance and 2 to the
Euclidean distance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray or ndarray of bools</span></dt><dd><ul class="simple">
<li><p>If <cite>indices = True</cite>  : (row, column, &hellip;) coordinates of peaks.</p></li>
<li><p>If <cite>indices = False</cite> : Boolean array shaped like <cite>image</cite>, with peaks
represented by True values.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.peak_local_max</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>The default value of <cite>threshold_rel</cite> has changed to None, which
corresponds to letting <cite>skimage.feature.peak_local_max</cite> decide on the
default. This is equivalent to <cite>threshold_rel=0</cite>.</p>
</div>
<p>The <cite>num_peaks</cite> limit is applied before suppression of connected peaks.
To limit the number of peaks after suppression, set <cite>num_peaks=np.inf</cite> and
post-process the output of this function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">response</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 0., 1., 1., 0.],</span>
<span class="go">       [0., 0., 1., 1., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 3],</span>
<span class="go">       [3, 2],</span>
<span class="go">       [3, 3]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
<span class="go">array([[2, 2]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.corner_shi_tomasi">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">corner_shi_tomasi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.corner_shi_tomasi" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute Shi-Tomasi (Kanade-Tomasi) corner measure response image.</p>
<p>This corner detector uses information from the auto-correlation matrix A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[(</span><span class="n">imx</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>   <span class="p">(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="n">Axx</span> <span class="n">Axy</span><span class="p">]</span>
    <span class="p">[(</span><span class="n">imx</span><span class="o">*</span><span class="n">imy</span><span class="p">)</span>   <span class="p">(</span><span class="n">imy</span><span class="o">**</span><span class="mi">2</span><span class="p">)]</span>   <span class="p">[</span><span class="n">Axy</span> <span class="n">Ayy</span><span class="p">]</span>
</pre></div>
</div>
<p>Where imx and imy are first derivatives, averaged with a gaussian filter.
The corner measure is then defined as the smaller eigenvalue of A:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">((</span><span class="n">Axx</span> <span class="o">+</span> <span class="n">Ayy</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">Axx</span> <span class="o">-</span> <span class="n">Ayy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">Axy</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>response</strong><span class="classifier">ndarray</span></dt><dd><p>Shi-Tomasi response image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1533b50bf70b-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Corner_detection">https://en.wikipedia.org/wiki/Corner_detection</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">corner_shi_tomasi</span><span class="p">,</span> <span class="n">corner_peaks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corner_peaks</span><span class="p">(</span><span class="n">corner_shi_tomasi</span><span class="p">(</span><span class="n">square</span><span class="p">),</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[2, 2],</span>
<span class="go">       [2, 7],</span>
<span class="go">       [7, 2],</span>
<span class="go">       [7, 7]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.daisy">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">daisy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rings</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">histograms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orientations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l1'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring_radii</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visualize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.daisy" title="Permalink to this definition">&para;</a></dt>
<dd><p>Extract DAISY feature descriptors densely for the given image.</p>
<p>DAISY is a feature descriptor similar to SIFT formulated in a way that
allows for fast dense extraction. Typically, this is practical for
bag-of-features image representations.</p>
<p>The implementation follows Tola et al. <a class="reference internal" href="#r755485c8391d-1" id="id73">[1]</a> but deviate on the following
points:</p>
<blockquote>
<div><ul class="simple">
<li><p>Histogram bin contribution are smoothed with a circular Gaussian
window over the tonal range (the angular range).</p></li>
<li><p>The sigma values of the spatial Gaussian smoothing in this code do not
match the sigma values in the original code by Tola et al. <a class="reference internal" href="#r755485c8391d-2" id="id74">[2]</a>. In
their code, spatial smoothing is applied to both the input image and
the center histogram. However, this smoothing is not documented in <a class="reference internal" href="#r755485c8391d-1" id="id75">[1]</a>
and, therefore, it is omitted.</p></li>
</ul>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N) array</span></dt><dd><p>Input image (grayscale).</p>
</dd>
<dt><strong>step</strong><span class="classifier">int, optional</span></dt><dd><p>Distance between descriptor sampling points.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>Radius (in pixels) of the outermost ring.</p>
</dd>
<dt><strong>rings</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rings.</p>
</dd>
<dt><strong>histograms</strong><span class="classifier">int, optional</span></dt><dd><p>Number of histograms sampled per ring.</p>
</dd>
<dt><strong>orientations</strong><span class="classifier">int, optional</span></dt><dd><p>Number of orientations (bins) per histogram.</p>
</dd>
<dt><strong>normalization</strong><span class="classifier">[ &lsquo;l1&rsquo; | &lsquo;l2&rsquo; | &lsquo;daisy&rsquo; | &lsquo;off&rsquo; ], optional</span></dt><dd><p>How to normalize the descriptors</p>
<blockquote>
<div><ul class="simple">
<li><p>&lsquo;l1&rsquo;: L1-normalization of each descriptor.</p></li>
<li><p>&lsquo;l2&rsquo;: L2-normalization of each descriptor.</p></li>
<li><p>&lsquo;daisy&rsquo;: L2-normalization of individual histograms.</p></li>
<li><p>&lsquo;off&rsquo;: Disable normalization.</p></li>
</ul>
</div></blockquote>
</dd>
<dt><strong>sigmas</strong><span class="classifier">1D array of float, optional</span></dt><dd><p>Standard deviation of spatial Gaussian smoothing for the center
histogram and for each ring of histograms. The array of sigmas should
be sorted from the center and out. I.e. the first sigma value defines
the spatial smoothing of the center histogram and the last sigma value
defines the spatial smoothing of the outermost ring. Specifying sigmas
overrides the following parameter.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(sigmas)</span> <span class="pre">-</span> <span class="pre">1</span></code></p>
</div></blockquote>
</dd>
<dt><strong>ring_radii</strong><span class="classifier">1D array of int, optional</span></dt><dd><p>Radius (in pixels) for each ring. Specifying ring_radii overrides the
following two parameters.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rings</span> <span class="pre">=</span> <span class="pre">len(ring_radii)</span></code>
<code class="docutils literal notranslate"><span class="pre">radius</span> <span class="pre">=</span> <span class="pre">ring_radii[-1]</span></code></p>
</div></blockquote>
<p>If both sigmas and ring_radii are given, they must satisfy the
following predicate since no radius is needed for the center
histogram.</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">len(ring_radii)</span> <span class="pre">==</span> <span class="pre">len(sigmas)</span> <span class="pre">+</span> <span class="pre">1</span></code></p>
</div></blockquote>
</dd>
<dt><strong>visualize</strong><span class="classifier">bool, optional</span></dt><dd><p>Generate a visualization of the DAISY descriptors</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>descs</strong><span class="classifier">array</span></dt><dd><p>Grid of DAISY descriptors for the given image as an array
dimensionality  (P, Q, R) where</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">P</span> <span class="pre">=</span> <span class="pre">ceil((M</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></code>
<code class="docutils literal notranslate"><span class="pre">Q</span> <span class="pre">=</span> <span class="pre">ceil((N</span> <span class="pre">-</span> <span class="pre">radius*2)</span> <span class="pre">/</span> <span class="pre">step)</span></code>
<code class="docutils literal notranslate"><span class="pre">R</span> <span class="pre">=</span> <span class="pre">(rings</span> <span class="pre">*</span> <span class="pre">histograms</span> <span class="pre">+</span> <span class="pre">1)</span> <span class="pre">*</span> <span class="pre">orientations</span></code></p>
</div></blockquote>
</dd>
<dt><strong>descs_img</strong><span class="classifier">(M, N, 3) array (only if visualize==True)</span></dt><dd><p>Visualization of the DAISY descriptors.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r755485c8391d-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id73">1</a>,<a href="#id75">2</a>)</span></dt>
<dd><p>Tola et al. &ldquo;Daisy: An efficient dense descriptor applied to wide-
baseline stereo.&rdquo; Pattern Analysis and Machine Intelligence, IEEE
Transactions on 32.5 (2010): 815-830.</p>
</dd>
<dt class="label" id="r755485c8391d-2"><span class="brackets"><a class="fn-backref" href="#id74">2</a></span></dt>
<dd><p><a class="reference external" href="http://cvlab.epfl.ch/software/daisy">http://cvlab.epfl.ch/software/daisy</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.hessian_matrix">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">hessian_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rc'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.hessian_matrix" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute Hessian matrix.</p>
<p>The Hessian matrix is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">Hrr</span> <span class="n">Hrc</span><span class="p">]</span>
    <span class="p">[</span><span class="n">Hrc</span> <span class="n">Hcc</span><span class="p">]</span>
</pre></div>
</div>
<p>which is computed by convolving the image with the second derivatives
of the Gaussian kernel in the respective r- and c-directions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as
weighting function for the auto-correlation matrix.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{&lsquo;rc&rsquo;, &lsquo;xy&rsquo;}, optional</span></dt><dd><p>This parameter allows for the use of reverse or forward order of
the image axes in gradient computation. &lsquo;rc&rsquo; indicates the use of
the first axis initially (Hrr, Hrc, Hcc), whilst &lsquo;xy&rsquo; indicates the
usage of the last axis initially (Hxx, Hxy, Hyy)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Hrr</strong><span class="classifier">ndarray</span></dt><dd><p>Element of the Hessian matrix for each pixel in the input image.</p>
</dd>
<dt><strong>Hrc</strong><span class="classifier">ndarray</span></dt><dd><p>Element of the Hessian matrix for each pixel in the input image.</p>
</dd>
<dt><strong>Hcc</strong><span class="classifier">ndarray</span></dt><dd><p>Element of the Hessian matrix for each pixel in the input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">hessian_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hrr</span><span class="p">,</span> <span class="n">Hrc</span><span class="p">,</span> <span class="n">Hcc</span> <span class="o">=</span> <span class="n">hessian_matrix</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'rc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Hrc</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0., -1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.hessian_matrix_det">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">hessian_matrix_det</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.hessian_matrix_det" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the approximate Hessian Determinant over an image.</p>
<p>The 2D approximate method uses box filters over integral images to
compute the approximate Hessian Determinant, as described in <a class="reference internal" href="#rb0b31e8efc4c-1" id="id78">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The image over which to compute Hessian Determinant.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, used for the Hessian
matrix.</p>
</dd>
<dt><strong>approximate</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> and the image is 2D, use a much faster approximate
computation. This argument has no effect on 3D and higher images.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>The array of the Determinant of Hessians.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For 2D images when <code class="docutils literal notranslate"><span class="pre">approximate=True</span></code>, the running time of this method
only depends on size of the image. It is independent of <cite>sigma</cite> as one
would expect. The downside is that the result for <cite>sigma</cite> less than <cite>3</cite>
is not accurate, i.e., not similar to the result obtained if someone
computed the Hessian and took its determinant.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb0b31e8efc4c-1"><span class="brackets"><a class="fn-backref" href="#id78">1</a></span></dt>
<dd><p>Herbert Bay, Andreas Ess, Tinne Tuytelaars, Luc Van Gool,
&ldquo;SURF: Speeded Up Robust Features&rdquo;
<a class="reference external" href="ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf">ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.hessian_matrix_eigvals">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">hessian_matrix_eigvals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">H_elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.hessian_matrix_eigvals" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute eigenvalues of Hessian matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>H_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>The upper-diagonal elements of the Hessian matrix, as returned
by <cite>hessian_matrix</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eigs</strong><span class="classifier">ndarray</span></dt><dd><p>The eigenvalues of the Hessian matrix, in decreasing order. The
eigenvalues are the leading dimension. That is, <code class="docutils literal notranslate"><span class="pre">eigs[i,</span> <span class="pre">j,</span> <span class="pre">k]</span></code>
contains the ith-largest eigenvalue at position (j, k).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="p">(</span><span class="n">hessian_matrix</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">hessian_matrix_eigvals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H_elems</span> <span class="o">=</span> <span class="n">hessian_matrix</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'rc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hessian_matrix_eigvals</span><span class="p">(</span><span class="n">H_elems</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[ 0.,  0.,  2.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  1.,  0.],</span>
<span class="go">       [ 2.,  0., -2.,  0.,  2.],</span>
<span class="go">       [ 0.,  1.,  0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  2.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.masked_register_translation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">masked_register_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.masked_register_translation" title="Permalink to this definition">&para;</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <code class="docutils literal notranslate"><span class="pre">cucim.skimage.registration.phase_cross_correlation</span></code> instead.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.match_template">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">match_template</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">template</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_input</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constant_values</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.match_template" title="Permalink to this definition">&para;</a></dt>
<dd><p>Match a template to a 2-D or 3-D image using normalized correlation.</p>
<p>The output is an array with values between -1.0 and 1.0. The value at a
given position corresponds to the correlation coefficient between the image
and the template.</p>
<p>For <cite>pad_input=True</cite> matches correspond to the center and otherwise to the
top-left corner of the template. To find the best match you must search for
peaks in the response (output) image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(M, N[, D]) array</span></dt><dd><p>2-D or 3-D input image.</p>
</dd>
<dt><strong>template</strong><span class="classifier">(m, n[, d]) array</span></dt><dd><p>Template to locate. It must be <cite>(m &lt;= M, n &lt;= N[, d &lt;= D])</cite>.</p>
</dd>
<dt><strong>pad_input</strong><span class="classifier">bool</span></dt><dd><p>If True, pad <cite>image</cite> so that output is the same size as the image, and
output values correspond to the template center. Otherwise, the output
is an array with shape <cite>(M - m + 1, N - n + 1)</cite> for an <cite>(M, N)</cite> image
and an <cite>(m, n)</cite> template, and matches correspond to origin
(top-left corner) of the template.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">see <cite>numpy.pad</cite>, optional</span></dt><dd><p>Padding mode.</p>
</dd>
<dt><strong>constant_values</strong><span class="classifier">see <cite>numpy.pad</cite>, optional</span></dt><dd><p>Constant values used in conjunction with <code class="docutils literal notranslate"><span class="pre">mode='constant'</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array</span></dt><dd><p>Response image with correlation coefficients.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Details on the cross-correlation are presented in <a class="reference internal" href="#r9f67d2173c8e-1" id="id80">[1]</a>. This implementation
uses FFT convolutions of the image and the template. Reference <a class="reference internal" href="#r9f67d2173c8e-2" id="id81">[2]</a>
presents similar derivations but the approximation presented in this
reference is not used in our implementation.</p>
<p>This CuPy implementation does not force the image to float64 internally,
but will use float32 for single-precision inputs.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9f67d2173c8e-1"><span class="brackets"><a class="fn-backref" href="#id80">1</a></span></dt>
<dd><p>J. P. Lewis, &ldquo;Fast Normalized Cross-Correlation&rdquo;, Industrial Light
and Magic.</p>
</dd>
<dt class="label" id="r9f67d2173c8e-2"><span class="brackets"><a class="fn-backref" href="#id81">2</a></span></dt>
<dd><p>Briechle and Hanebeck, &ldquo;Template Matching using Fast Normalized
Cross Correlation&rdquo;, Proceedings of the SPIE (2001).
<a class="reference external" href="https://doi.org/10.1117/12.421129">DOI:10.1117/12.421129</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">template</span>
<span class="go">array([[ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  1.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0., -1.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[ 1.   , -0.125,  0.   ,  0.   ],</span>
<span class="go">       [-0.125, -0.125,  0.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  0.   ,  0.125,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.125, -1.   ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">match_template</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">template</span><span class="p">,</span> <span class="n">pad_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([[-0.125, -0.125, -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [-0.125,  1.   , -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [-0.125, -0.125, -0.125,  0.   ,  0.   ,  0.   ],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125,  0.125,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125, -1.   ,  0.125],</span>
<span class="go">       [ 0.   ,  0.   ,  0.   ,  0.125,  0.125,  0.125]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.multiscale_basic_features">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">multiscale_basic_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">texture</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_min</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_workers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.multiscale_basic_features" title="Permalink to this definition">&para;</a></dt>
<dd><p>Local features for a single- or multi-channel nd image.</p>
<p>Intensity, gradient intensity and local structure are computed at
different scales thanks to Gaussian blurring.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image, which can be grayscale or multichannel.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, default False</span></dt><dd><p>True if the last dimension corresponds to color channels.</p>
</dd>
<dt><strong>intensity</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, pixel intensities averaged over the different scales
are added to the feature set.</p>
</dd>
<dt><strong>edges</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, intensities of local gradients averaged over the different
scales are added to the feature set.</p>
</dd>
<dt><strong>texture</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, eigenvalues of the Hessian matrix after Gaussian blurring
at different scales are added to the feature set.</p>
</dd>
<dt><strong>sigma_min</strong><span class="classifier">float, optional</span></dt><dd><p>Smallest value of the Gaussian kernel used to average local
neighbourhoods before extracting features.</p>
</dd>
<dt><strong>sigma_max</strong><span class="classifier">float, optional</span></dt><dd><p>Largest value of the Gaussian kernel used to average local
neighbourhoods before extracting features.</p>
</dd>
<dt><strong>num_sigma</strong><span class="classifier">int, optional</span></dt><dd><p>Number of values of the Gaussian kernel between sigma_min and sigma_max.
If None, sigma_min multiplied by powers of 2 are used.</p>
</dd>
<dt><strong>num_workers</strong><span class="classifier">int or None, optional</span></dt><dd><p>The number of parallel threads to use. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, the full
set of available cores are used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>features</strong><span class="classifier">cp.ndarray</span></dt><dd><p>Array of shape <code class="docutils literal notranslate"><span class="pre">image.shape</span> <span class="pre">+</span> <span class="pre">(n_features,)</span></code></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.peak_local_max">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">peak_local_max</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_abs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">threshold_rel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_border</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_peaks_per_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_norm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.peak_local_max" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find peaks in an image as coordinate list or boolean mask.</p>
<p>Peaks are the local maxima in a region of <cite>2 * min_distance + 1</cite>
(i.e. peaks are separated by at least <cite>min_distance</cite>).</p>
<p>If both <cite>threshold_abs</cite> and <cite>threshold_rel</cite> are provided, the maximum
of the two is chosen as the minimum intensity threshold of peaks.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18: </span>Prior to version 0.18, peaks of the same height within a radius of
<cite>min_distance</cite> were all returned, but this could cause unexpected
behaviour. From 0.18 onwards, an arbitrary peak within the region is
returned. See issue gh-2592.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>min_distance</strong><span class="classifier">int, optional</span></dt><dd><p>The minimal allowed distance separating peaks. To find the
maximum number of peaks, use <cite>min_distance=1</cite>.</p>
</dd>
<dt><strong>threshold_abs</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks. By default, the absolute threshold is
the minimum intensity of the image.</p>
</dd>
<dt><strong>threshold_rel</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum intensity of peaks, calculated as <cite>max(image) * threshold_rel</cite>.</p>
</dd>
<dt><strong>exclude_border</strong><span class="classifier">int, tuple of ints, or bool, optional</span></dt><dd><p>If positive integer, <cite>exclude_border</cite> excludes peaks from within
<cite>exclude_border</cite>-pixels of the border of the image.
If tuple of non-negative ints, the length of the tuple must match the
input array&rsquo;s dimensionality.  Each element of the tuple will exclude
peaks from within <cite>exclude_border</cite>-pixels of the border of the image
along that dimension.
If True, takes the <cite>min_distance</cite> parameter as value.
If zero or False, peaks are identified regardless of their distance
from the border.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the output will be an array representing peak
coordinates. The coordinates are sorted according to peaks
values (Larger first). If False, the output will be a boolean
array shaped as <cite>image.shape</cite> with peaks present at True
elements. <code class="docutils literal notranslate"><span class="pre">indices</span></code> is deprecated and will be removed in
version 0.20. Default behavior will be to always return peak
coordinates. You can obtain a mask as shown in the example
below.</p>
</dd>
<dt><strong>num_peaks</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks. When the number of peaks exceeds <cite>num_peaks</cite>,
return <cite>num_peaks</cite> peaks based on highest peak intensity.</p>
</dd>
<dt><strong>footprint</strong><span class="classifier">ndarray of bools, optional</span></dt><dd><p>If provided, <cite>footprint == 1</cite> represents the local region within which
to search for peaks at every point in <cite>image</cite>.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">ndarray of ints, optional</span></dt><dd><p>If provided, each unique region <cite>labels == value</cite> represents a unique
region to search for peaks. Zero is reserved for background.</p>
</dd>
<dt><strong>num_peaks_per_label</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of peaks for each label.</p>
</dd>
<dt><strong>p_norm</strong><span class="classifier">float</span></dt><dd><p>Which Minkowski p-norm to use. Should be in the range [1, inf].
A finite large p may cause a ValueError if overflow can occur.
<code class="docutils literal notranslate"><span class="pre">inf</span></code> corresponds to the Chebyshev distance and 2 to the
Euclidean distance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray or ndarray of bools</span></dt><dd><ul class="simple">
<li><p>If <cite>indices = True</cite>  : (row, column, &hellip;) coordinates of peaks.</p></li>
<li><p>If <cite>indices = False</cite> : Boolean array shaped like <cite>image</cite>, with peaks
represented by True values.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.corner_peaks</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The peak local maximum function returns the coordinates of local peaks
(maxima) in an image. Internally, a maximum filter is used for finding local
maxima. This operation dilates the original image. After comparison of the
dilated and original image, this function returns the coordinates or a mask
of the peaks where the dilated image equals the original image.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img1</span>
<span class="go">array([[0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 1.5, 0. , 1. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ],</span>
<span class="go">       [0. , 0. , 0. , 0. , 0. , 0. , 0. ]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">array([[3, 2],</span>
<span class="go">       [3, 4]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_local_max</span><span class="p">(</span><span class="n">img1</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[3, 2]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span><span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_idx</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">exclude_border</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_idx</span>
<span class="go">array([[10, 10, 10],</span>
<span class="go">       [15, 15, 15]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">peak_mask</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">peak_mask</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">peak_idx</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">peak_mask</span><span class="p">)</span>
<span class="go">array([[10, 10, 10],</span>
<span class="go">       [15, 15, 15]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.register_translation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">register_translation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upsample_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.register_translation" title="Permalink to this definition">&para;</a></dt>
<dd><p><strong>Deprecated function</strong>. Use <code class="docutils literal notranslate"><span class="pre">cucim.skimage.registration.phase_cross_correlation</span></code> instead.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.shape_index">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">shape_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.shape_index" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the shape index.</p>
<p>The shape index, as defined by Koenderink &amp; van Doorn <a class="reference internal" href="#r7fa02a84f5a7-1" id="id84">[1]</a>, is a
single valued measure of local curvature, assuming the image as a 3D plane
with intensities representing heights.</p>
<p>It is derived from the eigen values of the Hessian, and its
value ranges from -1 to 1 (and is undefined (=NaN) in <em>flat</em> regions),
with following ranges representing following shapes:</p>
<table class="docutils align-default" id="id241">
<caption><span class="caption-text">Ranges of the shape index and corresponding shapes.</span><a class="headerlink" href="#id241" title="Permalink to this table">&para;</a></caption>
<colgroup>
<col style="width: 59%">
<col style="width: 41%">
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Interval (s in &hellip;)</p></th>
<th class="head"><p>Shape</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>[  -1, -7/8)</p></td>
<td><p>Spherical cup</p></td>
</tr>
<tr class="row-odd"><td><p>[-7/8, -5/8)</p></td>
<td><p>Through</p></td>
</tr>
<tr class="row-even"><td><p>[-5/8, -3/8)</p></td>
<td><p>Rut</p></td>
</tr>
<tr class="row-odd"><td><p>[-3/8, -1/8)</p></td>
<td><p>Saddle rut</p></td>
</tr>
<tr class="row-even"><td><p>[-1/8, +1/8)</p></td>
<td><p>Saddle</p></td>
</tr>
<tr class="row-odd"><td><p>[+1/8, +3/8)</p></td>
<td><p>Saddle ridge</p></td>
</tr>
<tr class="row-even"><td><p>[+3/8, +5/8)</p></td>
<td><p>Ridge</p></td>
</tr>
<tr class="row-odd"><td><p>[+5/8, +7/8)</p></td>
<td><p>Dome</p></td>
</tr>
<tr class="row-even"><td><p>[+7/8,   +1]</p></td>
<td><p>Spherical cap</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used for
smoothing the input data before Hessian eigen value calculation.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>s</strong><span class="classifier">ndarray</span></dt><dd><p>Shape index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7fa02a84f5a7-1"><span class="brackets"><a class="fn-backref" href="#id84">1</a></span></dt>
<dd><p>Koenderink, J. J. &amp; van Doorn, A. J.,
&ldquo;Surface shape and curvature scales&rdquo;,
Image and Vision Computing, 1992, 10, 557-564.
<a class="reference external" href="https://doi.org/10.1016/0262-8856(92)90076-F">DOI:10.1016/0262-8856(92)90076-F</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">shape_index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">shape_index</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">array([[ nan,  nan, -0.5,  nan,  nan],</span>
<span class="go">       [ nan, -0. ,  nan, -0. ,  nan],</span>
<span class="go">       [-0.5,  nan, -1. ,  nan, -0.5],</span>
<span class="go">       [ nan, -0. ,  nan, -0. ,  nan],</span>
<span class="go">       [ nan,  nan, -0.5,  nan,  nan]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.structure_tensor">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">structure_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.structure_tensor" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute structure tensor using sum of squared differences.</p>
<p>The (2-dimensional) structure tensor A is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="n">Arr</span> <span class="n">Arc</span><span class="p">]</span>
    <span class="p">[</span><span class="n">Arc</span> <span class="n">Acc</span><span class="p">]</span>
</pre></div>
</div>
<p>which is approximated by the weighted sum of squared differences in a local
window around each pixel in the image. This formula can be extended to a
larger number of dimensions (see <a class="reference internal" href="#rdb0ba267bece-1" id="id86">[1]</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation used for the Gaussian kernel, which is used as a
weighting function for the local summation of squared differences.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{&lsquo;rc&rsquo;, &lsquo;xy&rsquo;}, optional</span></dt><dd><p>NOTE: Only applies in 2D. Higher dimensions must always use &lsquo;rc&rsquo; order.
This parameter allows for the use of reverse or forward order of
the image axes in gradient computation. &lsquo;rc&rsquo; indicates the use of
the first axis initially (Arr, Arc, Acc), whilst &lsquo;xy&rsquo; indicates the
usage of the last axis initially (Axx, Axy, Ayy).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>A_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>Upper-diagonal elements of the structure tensor for each pixel in the
input image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.feature.structure_tensor_eigenvalues" title="cucim.skimage.feature.structure_tensor_eigenvalues"><code class="xref py py-obj docutils literal notranslate"><span class="pre">structure_tensor_eigenvalues</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rdb0ba267bece-1"><span class="brackets"><a class="fn-backref" href="#id86">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Structure_tensor">https://en.wikipedia.org/wiki/Structure_tensor</a></p>
</dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Arr</span><span class="p">,</span> <span class="n">Arc</span><span class="p">,</span> <span class="n">Acc</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">"rc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Acc</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 1., 0., 1., 0.],</span>
<span class="go">       [0., 4., 0., 4., 0.],</span>
<span class="go">       [0., 1., 0., 1., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.structure_tensor_eigenvalues">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">structure_tensor_eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">A_elems</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.structure_tensor_eigenvalues" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute eigenvalues of structure tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>A_elems</strong><span class="classifier">list of ndarray</span></dt><dd><p>The upper-diagonal elements of the structure tensor, as returned
by <cite>structure_tensor</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>ndarray</dt><dd><p>The eigenvalues of the structure tensor, in decreasing order. The
eigenvalues are the leading dimension. That is, the coordinate
[i, j, k] corresponds to the ith-largest eigenvalue at position (j, k).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="n">structure_tensor_eigenvalues</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A_elems</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">'rc'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure_tensor_eigenvalues</span><span class="p">(</span><span class="n">A_elems</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 2., 4., 2., 0.],</span>
<span class="go">       [0., 4., 0., 4., 0.],</span>
<span class="go">       [0., 2., 4., 2., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.feature.structure_tensor_eigvals">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.feature.</span></span><span class="sig-name descname"><span class="pre">structure_tensor_eigvals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Axx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Axy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ayy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.feature.structure_tensor_eigvals" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute eigenvalues of structure tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>Axx</strong><span class="classifier">ndarray</span></dt><dd><p>Element of the structure tensor for each pixel in the input image.</p>
</dd>
<dt><strong>Axy</strong><span class="classifier">ndarray</span></dt><dd><p>Element of the structure tensor for each pixel in the input image.</p>
</dd>
<dt><strong>Ayy</strong><span class="classifier">ndarray</span></dt><dd><p>Element of the structure tensor for each pixel in the input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>l1</strong><span class="classifier">ndarray</span></dt><dd><p>Larger eigen value for each input matrix.</p>
</dd>
<dt><strong>l2</strong><span class="classifier">ndarray</span></dt><dd><p>Smaller eigen value for each input matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.feature</span> <span class="kn">import</span> <span class="p">(</span><span class="n">structure_tensor</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">structure_tensor_eigvals</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Arr</span><span class="p">,</span> <span class="n">Arc</span><span class="p">,</span> <span class="n">Acc</span> <span class="o">=</span> <span class="n">structure_tensor</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">"rc"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">structure_tensor_eigvals</span><span class="p">(</span><span class="n">Acc</span><span class="p">,</span> <span class="n">Arc</span><span class="p">,</span> <span class="n">Arr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0., 0., 0., 0., 0.],</span>
<span class="go">       [0., 2., 4., 2., 0.],</span>
<span class="go">       [0., 4., 0., 4., 0.],</span>
<span class="go">       [0., 2., 4., 2., 0.],</span>
<span class="go">       [0., 0., 0., 0., 0.]])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.filters">
<span id="filters"></span><h3>filters<a class="headerlink" href="#module-cucim.skimage.filters" title="Permalink to this headline">&para;</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.filters.LPIFilter2D">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">LPIFilter2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">impulse_response</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">filter_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.LPIFilter2D" title="Permalink to this definition">&para;</a></dt>
<dd><p>Linear Position-Invariant Filter (2-dimensional)</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(data)</p></td>
<td><p>Apply the filter to the given data.</p></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.apply_hysteresis_threshold">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">apply_hysteresis_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.apply_hysteresis_threshold" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply hysteresis thresholding to <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
<p>This algorithm finds regions where <code class="docutils literal notranslate"><span class="pre">image</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">high</span></code>
OR <code class="docutils literal notranslate"><span class="pre">image</span></code> is greater than <code class="docutils literal notranslate"><span class="pre">low</span></code> <em>and</em> that region is connected to
a region greater than <code class="docutils literal notranslate"><span class="pre">high</span></code>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array, shape (M,[ N, &hellip;, P])</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>low</strong><span class="classifier">float, or array of same shape as <code class="docutils literal notranslate"><span class="pre">image</span></code></span></dt><dd><p>Lower threshold.</p>
</dd>
<dt><strong>high</strong><span class="classifier">float, or array of same shape as <code class="docutils literal notranslate"><span class="pre">image</span></code></span></dt><dd><p>Higher threshold.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>thresholded</strong><span class="classifier">array of bool, same shape as <code class="docutils literal notranslate"><span class="pre">image</span></code></span></dt><dd><p>Array in which <code class="docutils literal notranslate"><span class="pre">True</span></code> indicates the locations where <code class="docutils literal notranslate"><span class="pre">image</span></code>
was above the hysteresis threshold.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0a2b64cbab75-1"><span class="brackets">1</span></dt>
<dd><p>J. Canny. A computational approach to edge detection.
IEEE Transactions on Pattern Analysis and Machine Intelligence.
1986; vol. 8, pp.679-698.
<a class="reference external" href="https://doi.org/10.1109/TPAMI.1986.4767851">DOI:10.1109/TPAMI.1986.4767851</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">apply_hysteresis_threshold</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">apply_hysteresis_threshold</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="go">array([0, 1, 1, 1, 0, 0, 0, 1, 1])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.correlate_sparse">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">correlate_sparse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.correlate_sparse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute valid cross-correlation of <cite>padded_array</cite> and <cite>kernel</cite>.</p>
<p>This function is <em>fast</em> when <cite>kernel</cite> is large with many zeros.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">scipy.ndimage.correlate</span></code> for a description of cross-correlation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, dtype float, shape (M, N,[ &hellip;,] P)</span></dt><dd><p>The input array. If mode is &lsquo;valid&rsquo;, this array should already be
padded, as a margin of the same shape as kernel will be stripped
off.</p>
</dd>
<dt><strong>kernel</strong><span class="classifier">ndarray, dtype float shape (Q, R,[ &hellip;,] S)</span></dt><dd><p>The kernel to be correlated. Must have the same number of
dimensions as <cite>padded_array</cite>. For high performance, it should
be sparse (few nonzero entries).</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string, optional</span></dt><dd><p>See <cite>scipy.ndimage.correlate</cite> for valid modes.
Additionally, mode &lsquo;valid&rsquo; is accepted, in which case no padding is
applied and the result is the result for the smaller image for which
the kernel is entirely inside the original data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">array of float, shape (M, N,[ &hellip;,] P)</span></dt><dd><p>The result of cross-correlating <cite>image</cite> with <cite>kernel</cite>. If mode
&lsquo;valid&rsquo; is used, the resulting shape is (M-Q+1, N-R+1,[ &hellip;,] P-S+1).</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.difference_of_gaussians">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">difference_of_gaussians</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">high_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truncate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.difference_of_gaussians" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find features between <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code> and <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> in size.</p>
<p>This function uses the Difference of Gaussians method for applying
band-pass filters to multi-dimensional arrays. The input array is
blurred with two Gaussian kernels of differing sigmas to produce two
intermediate, filtered images. The more-blurred image is then subtracted
from the less-blurred image. The final output image will therefore have
had high-frequency components attenuated by the smaller-sigma Gaussian, and
low frequency components will have been removed due to their presence in
the more-blurred intermediate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input array to filter.</p>
</dd>
<dt><strong>low_sigma</strong><span class="classifier">scalar or sequence of scalars</span></dt><dd><p>Standard deviation(s) for the Gaussian kernel with the smaller sigmas
across all axes. The standard deviations are given for each axis as a
sequence, or as a single number, in which case the single number is
used as the standard deviation value for all axes.</p>
</dd>
<dt><strong>high_sigma</strong><span class="classifier">scalar or sequence of scalars, optional (default is None)</span></dt><dd><p>Standard deviation(s) for the Gaussian kernel with the larger sigmas
across all axes. The standard deviations are given for each axis as a
sequence, or as a single number, in which case the single number is
used as the standard deviation value for all axes. If None is given
(default), sigmas for all axes are calculated as 1.6 * low_sigma.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter determines how the array borders are
handled, where <code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when mode is equal to
&lsquo;constant&rsquo;. Default is &lsquo;nearest&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is &lsquo;constant&rsquo;. Default
is 0.0</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional (default: False)</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels. If True, each channel is filtered separately (channels are
not mixed together).</p>
</dd>
<dt><strong>truncate</strong><span class="classifier">float, optional (default is 4.0)</span></dt><dd><p>Truncate the filter at this many standard deviations.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered_image</strong><span class="classifier">ndarray</span></dt><dd><p>the filtered array.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.feature.blog_dog</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This function will subtract an array filtered with a Gaussian kernel
with sigmas given by <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> from an array filtered with a
Gaussian kernel with sigmas provided by <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code>. The values for
<code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> must always be greater than or equal to the corresponding
values in <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code>, or a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> will be raised.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> is none, the values for <code class="docutils literal notranslate"><span class="pre">high_sigma</span></code> will be
calculated as 1.6x the corresponding values in <code class="docutils literal notranslate"><span class="pre">low_sigma</span></code>. This ratio
was originally proposed by Marr and Hildreth (1980) <a class="reference internal" href="#r74659d1d36f1-1" id="id89">[1]</a> and is commonly
used when approximating the inverted Laplacian of Gaussian, which is used
in edge and blob detection.</p>
<p>Input image is converted according to the conventions of <code class="docutils literal notranslate"><span class="pre">img_as_float</span></code>.</p>
<p>Except for sigma values, all parameters are used for both filters.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r74659d1d36f1-1"><span class="brackets"><a class="fn-backref" href="#id89">1</a></span></dt>
<dd><p>Marr, D. and Hildreth, E. Theory of Edge Detection. Proc. R. Soc.
Lond. Series B 207, 187-217 (1980).
<a class="reference external" href="https://doi.org/10.1098/rspb.1980.0020">https://doi.org/10.1098/rspb.1980.0020</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Apply a simple Difference of Gaussians filter to a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">difference_of_gaussians</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">astro</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">difference_of_gaussians</span><span class="p">(</span><span class="n">astro</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">multichannel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a Laplacian of Gaussian filter as approximated by the Difference
of Gaussians filter:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">difference_of_gaussians</span><span class="p">(</span><span class="n">astro</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">multichannel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply a Difference of Gaussians filter to a grayscale image using different
sigma values for each axis:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cam</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_image</span> <span class="o">=</span> <span class="n">difference_of_gaussians</span><span class="p">(</span><span class="n">cam</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.frangi">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">frangi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.frangi" title="Permalink to this definition">&para;</a></dt>
<dd><p>Filter an image with the Frangi vesselness filter.</p>
<p>This filter can be used to detect continuous ridges, e.g. vessels,
wrinkles, rivers. It can be used to calculate the fraction of the
whole image containing such objects.</p>
<p>Defined only for 2-D and 3-D images. Calculates the eigenvectors of the
Hessian to compute the similarity of an image region to vessels, according
to the method described in <a class="reference internal" href="#ree817c6d0d46-1" id="id91">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter, i.e.,
np.arange(scale_range[0], scale_range[1], scale_step)</p>
</dd>
<dt><strong>scale_range</strong><span class="classifier">2-tuple of floats, optional</span></dt><dd><p>The range of sigmas used.</p>
</dd>
<dt><strong>scale_step</strong><span class="classifier">float, optional</span></dt><dd><p>Step size between sigmas.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a plate-like structure.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a blob-like structure.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to areas of high variance/texture/structure.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.meijering" title="cucim.skimage.filters.meijering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijering</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sato" title="cucim.skimage.filters.sato"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sato</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.hessian" title="cucim.skimage.filters.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Written by Marc Schrijver, November 2001
Re-Written by D. J. Kroon, University of Twente, May 2009, <a class="reference internal" href="#ree817c6d0d46-2" id="id92">[2]</a>
Adoption of 3D version from D. G. Ellis, Januar 20017, <a class="reference internal" href="#ree817c6d0d46-3" id="id93">[3]</a></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ree817c6d0d46-1"><span class="brackets"><a class="fn-backref" href="#id91">1</a></span></dt>
<dd><p>Frangi, A. F., Niessen, W. J., Vincken, K. L., &amp; Viergever, M. A.
(1998,). Multiscale vessel enhancement filtering. In International
Conference on Medical Image Computing and Computer-Assisted
Intervention (pp. 130-137). Springer Berlin Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/BFb0056195">DOI:10.1007/BFb0056195</a></p>
</dd>
<dt class="label" id="ree817c6d0d46-2"><span class="brackets"><a class="fn-backref" href="#id92">2</a></span></dt>
<dd><p>Kroon, D. J.: Hessian based Frangi vesselness filter.</p>
</dd>
<dt class="label" id="ree817c6d0d46-3"><span class="brackets"><a class="fn-backref" href="#id93">3</a></span></dt>
<dd><p>Ellis, D. G.: <a class="reference external" href="https://github.com/ellisdg/frangi3d/tree/master/frangi">https://github.com/ellisdg/frangi3d/tree/master/frangi</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.gabor">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">gabor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frequency</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bandwidth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_stds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.gabor" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return real and imaginary responses to Gabor filter.</p>
<p>The real and imaginary parts of the Gabor filter kernel are applied to the
image and the response is returned as a pair of arrays.</p>
<p>Gabor filter is a linear filter with a Gaussian kernel which is modulated
by a sinusoidal plane wave. Frequency and orientation representations of
the Gabor filter are similar to those of the human visual system.
Gabor filter banks are commonly used in computer vision and image
processing. They are especially suitable for edge detection and texture
classification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>frequency</strong><span class="classifier">float</span></dt><dd><p>Spatial frequency of the harmonic function. Specified in pixels.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float, optional</span></dt><dd><p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>
</dd>
<dt><strong>bandwidth</strong><span class="classifier">float, optional</span></dt><dd><p>The bandwidth captured by the filter. For fixed bandwidth, <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code>
and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> will decrease with increasing frequency. This value is
ignored if <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> are set by the user.</p>
</dd>
<dt><strong>sigma_x, sigma_y</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation in x- and y-directions. These directions apply to
the kernel <em>before</em> rotation. If <cite>theta = pi/2</cite>, then the kernel is
rotated 90 degrees so that <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> controls the <em>vertical</em>
direction.</p>
</dd>
<dt><strong>n_stds</strong><span class="classifier">scalar, optional</span></dt><dd><p>The linear size of the kernel is n_stds (3 by default) standard
deviations.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float, optional</span></dt><dd><p>Phase offset of harmonic function in radians.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;reflect&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Mode used to convolve image with a kernel, passed to <cite>ndi.convolve</cite></p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <code class="docutils literal notranslate"><span class="pre">mode</span></code> of convolution is
&lsquo;constant&rsquo;. The parameter is passed to <cite>ndi.convolve</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>real, imag</strong><span class="classifier">arrays</span></dt><dd><p>Filtered images using the real and imaginary parts of the Gabor filter
kernel. Images are of the same dimensions as the input one.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4de53cce5cad-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gabor_filter">https://en.wikipedia.org/wiki/Gabor_filter</a></p>
</dd>
<dt class="label" id="r4de53cce5cad-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf">https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">gabor</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># detecting edges in a coin image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_real</span><span class="p">,</span> <span class="n">filt_imag</span> <span class="o">=</span> <span class="n">gabor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                        
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">filt_real</span><span class="p">))</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                           
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># less sensitivity to finer details with the lower frequency kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filt_real</span><span class="p">,</span> <span class="n">filt_imag</span> <span class="o">=</span> <span class="n">gabor</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                       
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">filt_real</span><span class="p">)</span>    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                          
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.gabor_kernel">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">gabor_kernel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">frequency</span></em>, <em class="sig-param"><span class="pre">theta=0</span></em>, <em class="sig-param"><span class="pre">bandwidth=1</span></em>, <em class="sig-param"><span class="pre">sigma_x=None</span></em>, <em class="sig-param"><span class="pre">sigma_y=None</span></em>, <em class="sig-param"><span class="pre">n_stds=3</span></em>, <em class="sig-param"><span class="pre">offset=0</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">float_dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.gabor_kernel" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return complex 2D Gabor filter kernel.</p>
<p>Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.
Harmonic function consists of an imaginary sine function and a real
cosine function. Spatial frequency is inversely proportional to the
wavelength of the harmonic and to the standard deviation of a Gaussian
kernel. The bandwidth is also inversely proportional to the standard
deviation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frequency</strong><span class="classifier">float</span></dt><dd><p>Spatial frequency of the harmonic function. Specified in pixels.</p>
</dd>
<dt><strong>theta</strong><span class="classifier">float, optional</span></dt><dd><p>Orientation in radians. If 0, the harmonic is in the x-direction.</p>
</dd>
<dt><strong>bandwidth</strong><span class="classifier">float, optional</span></dt><dd><p>The bandwidth captured by the filter. For fixed bandwidth, <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code>
and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> will decrease with increasing frequency. This value is
ignored if <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> and <code class="docutils literal notranslate"><span class="pre">sigma_y</span></code> are set by the user.</p>
</dd>
<dt><strong>sigma_x, sigma_y</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation in x- and y-directions. These directions apply to
the kernel <em>before</em> rotation. If <cite>theta = pi/2</cite>, then the kernel is
rotated 90 degrees so that <code class="docutils literal notranslate"><span class="pre">sigma_x</span></code> controls the <em>vertical</em>
direction.</p>
</dd>
<dt><strong>n_stds</strong><span class="classifier">scalar, optional</span></dt><dd><p>The linear size of the kernel is n_stds (3 by default) standard
deviations</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float, optional</span></dt><dd><p>Phase offset of harmonic function in radians.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>g</strong><span class="classifier">complex array</span></dt><dd><p>Complex filter kernel.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0f4330e36c94-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Gabor_filter">https://en.wikipedia.org/wiki/Gabor_filter</a></p>
</dd>
<dt class="label" id="r0f4330e36c94-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf">https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">gabor_kernel</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>  
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">gabor_kernel</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">gk</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                       
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># more ripples (equivalent to increasing the size of the</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Gaussian spread)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gk</span> <span class="o">=</span> <span class="n">gabor_kernel</span><span class="p">(</span><span class="n">frequency</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">bandwidth</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>                    
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">asnumpy</span><span class="p">(</span><span class="n">gk</span><span class="o">.</span><span class="n">real</span><span class="p">))</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">io</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>                       
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.gaussian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">truncate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.gaussian" title="Permalink to this definition">&para;</a></dt>
<dd><p>Multi-dimensional Gaussian filter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array-like</span></dt><dd><p>Input image (grayscale or color) to filter.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>Standard deviation for Gaussian kernel. The standard
deviations of the Gaussian filter are given for each axis as a
sequence, or as a single number, in which case it is equal for
all axes.</p>
</dd>
<dt><strong>output</strong><span class="classifier">array, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> parameter passes an array in which to store the
filter output.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The <code class="docutils literal notranslate"><span class="pre">mode</span></code> parameter determines how the array borders are
handled, where <code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when mode is equal to
&lsquo;constant&rsquo;. Default is &lsquo;nearest&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if <code class="docutils literal notranslate"><span class="pre">mode</span></code> is &lsquo;constant&rsquo;. Default
is 0.0</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional (default: None)</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels. If True, each channel is filtered separately (channels are
not mixed together). Only 3 channels are supported. If <code class="docutils literal notranslate"><span class="pre">None</span></code>,
the function will attempt to guess this, and raise a warning if
ambiguous, when the array has shape (M, N, 3).</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <code class="docutils literal notranslate"><span class="pre">img_as_float</span></code>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>truncate</strong><span class="classifier">float, optional</span></dt><dd><p>Truncate the filter at this many standard deviations.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered_image</strong><span class="classifier">ndarray</span></dt><dd><p>the filtered array</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is a wrapper around <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.ndi.gaussian_filter()</span></code>.</p>
<p>Integer arrays are converted to float.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">output</span></code> should be floating point data type since gaussian converts
to float provided <code class="docutils literal notranslate"><span class="pre">image</span></code>. If <code class="docutils literal notranslate"><span class="pre">output</span></code> is not provided, another array
will be allocated and returned as the result.</p>
<p>The multi-dimensional filter is implemented as a sequence of
one-dimensional convolution filters. The intermediate arrays are
stored in the same data type as the output. Therefore, for output
types with a limited precision, the results may be imprecise
because intermediate results may be stored with insufficient
precision.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[0., 0., 0.],</span>
<span class="go">       [0., 1., 0.],</span>
<span class="go">       [0., 0., 0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>  <span class="c1"># mild smoothing</span>
<span class="go">array([[0.00163116, 0.03712502, 0.00163116],</span>
<span class="go">       [0.03712502, 0.84496158, 0.03712502],</span>
<span class="go">       [0.00163116, 0.03712502, 0.00163116]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># more smoothing</span>
<span class="go">array([[0.05855018, 0.09653293, 0.05855018],</span>
<span class="go">       [0.09653293, 0.15915589, 0.09653293],</span>
<span class="go">       [0.05855018, 0.09653293, 0.05855018]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Several modes are possible for handling boundaries</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gaussian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'reflect'</span><span class="p">)</span>
<span class="go">array([[0.08767308, 0.12075024, 0.08767308],</span>
<span class="go">       [0.12075024, 0.16630671, 0.12075024],</span>
<span class="go">       [0.08767308, 0.12075024, 0.08767308]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># For RGB images, each is filtered separately</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">astronaut</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filtered_img</span> <span class="o">=</span> <span class="n">gaussian</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">multichannel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.hessian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">hessian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gamma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.hessian" title="Permalink to this definition">&para;</a></dt>
<dd><p>Filter an image with the Hybrid Hessian filter.</p>
<p>This filter can be used to detect continuous edges, e.g. vessels,
wrinkles, rivers. It can be used to calculate the fraction of the whole
image containing such objects.</p>
<p>Defined only for 2-D and 3-D images. Almost equal to Frangi filter, but
uses alternative method of smoothing. Refer to <a class="reference internal" href="#r664d4133c7b0-1" id="id101">[1]</a> to find the differences
between Frangi and Hessian filters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter, i.e.,
np.arange(scale_range[0], scale_range[1], scale_step)</p>
</dd>
<dt><strong>scale_range</strong><span class="classifier">2-tuple of floats, optional</span></dt><dd><p>The range of sigmas used.</p>
</dd>
<dt><strong>scale_step</strong><span class="classifier">float, optional</span></dt><dd><p>Step size between sigmas.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a blob-like structure.</p>
</dd>
<dt><strong>gamma</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to areas of high variance/texture/structure.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.meijering" title="cucim.skimage.filters.meijering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijering</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.sato" title="cucim.skimage.filters.sato"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sato</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.frangi" title="cucim.skimage.filters.frangi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frangi</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Written by Marc Schrijver (November 2001)
Re-Written by D. J. Kroon University of Twente (May 2009) <a class="reference internal" href="#r664d4133c7b0-2" id="id102">[2]</a></p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r664d4133c7b0-1"><span class="brackets"><a class="fn-backref" href="#id101">1</a></span></dt>
<dd><p>Ng, C. C., Yap, M. H., Costen, N., &amp; Li, B. (2014,). Automatic
wrinkle detection using hybrid Hessian filter. In Asian Conference on
Computer Vision (pp. 609-622). Springer International Publishing.
<a class="reference external" href="https://doi.org/10.1007/978-3-319-16811-1_40">DOI:10.1007/978-3-319-16811-1_40</a></p>
</dd>
<dt class="label" id="r664d4133c7b0-2"><span class="brackets"><a class="fn-backref" href="#id102">2</a></span></dt>
<dd><p>Kroon, D. J.: Hessian based Frangi vesselness filter.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.inverse">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impulse_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_gain</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predefined_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.inverse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply the filter in reverse to the given data.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">(M,N) ndarray</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>impulse_response</strong><span class="classifier">callable <cite>f(r, c, **filter_params)</cite></span></dt><dd><p>Impulse response of the filter.  See LPIFilter2D.__init__.</p>
</dd>
<dt><strong>filter_params</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword parameters to the impulse_response function.</p>
</dd>
<dt><strong>max_gain</strong><span class="classifier">float</span></dt><dd><p>Limit the filter gain.  Often, the filter contains zeros, which would
cause the inverse filter to have infinite gain.  High gain causes
amplification of artefacts, so a conservative limit is recommended.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>predefined_filter</strong><span class="classifier">LPIFilter2D</span></dt><dd><p>If you need to apply the same filter multiple times over different
images, construct the LPIFilter2D and specify it here.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.laplace">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">laplace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ksize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.laplace" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the edges of an image using the Laplace operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>ksize</strong><span class="classifier">int, optional</span></dt><dd><p>Define the size of the discrete Laplacian operator such that it
will have a size of (ksize,) * image.ndim.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><p>The Laplace edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The Laplacian operator is generated using the function
skimage.restoration.uft.laplacian().</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.median">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">median</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'nearest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">behavior</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ndimage'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.median" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return local median of an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array-like</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">behavior=='rank'</span></code>, <code class="docutils literal notranslate"><span class="pre">selem</span></code> is a 2-D array of 1&rsquo;s and 0&rsquo;s.
If <code class="docutils literal notranslate"><span class="pre">behavior=='ndimage'</span></code>, <code class="docutils literal notranslate"><span class="pre">selem</span></code> is a N-D array of 1&rsquo;s and 0&rsquo;s
with the same number of dimension than <code class="docutils literal notranslate"><span class="pre">image</span></code>.
If None, <code class="docutils literal notranslate"><span class="pre">selem</span></code> will be a N-D array with 3 elements for each
dimension (e.g., vector, square, cube, etc.)</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, (same dtype as image), optional</span></dt><dd><p>If None, a new array is allocated.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;,&rsquo;&lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
<code class="docutils literal notranslate"><span class="pre">cval</span></code> is the value when mode is equal to &lsquo;constant&rsquo;.
Default is &lsquo;nearest&rsquo;.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15: </span><code class="docutils literal notranslate"><span class="pre">mode</span></code> is used when <code class="docutils literal notranslate"><span class="pre">behavior='ndimage'</span></code>.</p>
</div>
</dd>
<dt><strong>cval</strong><span class="classifier">scalar, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;. Default is 0.0</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15: </span><code class="docutils literal notranslate"><span class="pre">cval</span></code> was added in 0.15 is used when <code class="docutils literal notranslate"><span class="pre">behavior='ndimage'</span></code>.</p>
</div>
</dd>
<dt><strong>behavior</strong><span class="classifier">{&lsquo;ndimage&rsquo;, &lsquo;rank&rsquo;}, optional</span></dt><dd><p>Either to use the old behavior (i.e., &lt; 0.15) or the new behavior.
The old behavior will call the <code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.rank.median()</span></code>.
The new behavior will call the <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.ndimage.median_filter()</span></code>.
Default is &lsquo;ndimage&rsquo;.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.15: </span><code class="docutils literal notranslate"><span class="pre">behavior</span></code> is introduced in 0.15</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>Default <code class="docutils literal notranslate"><span class="pre">behavior</span></code> has been changed from &lsquo;rank&rsquo; to &lsquo;ndimage&rsquo;</p>
</div>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">2-D array (same dtype as input image)</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.filters.rank.median</span></code></dt><dd><p>Rank-based implementation of the median filtering offering more flexibility with additional parameters but dedicated for unsigned integer images.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">median</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">med</span> <span class="o">=</span> <span class="n">median</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">disk</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.meijering">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">meijering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.meijering" title="Permalink to this definition">&para;</a></dt>
<dd><p>Filter an image with the Meijering neuriteness filter.</p>
<p>This filter can be used to detect continuous ridges, e.g. neurites,
wrinkles, rivers. It can be used to calculate the fraction of the
whole image containing such objects.</p>
<p>Calculates the eigenvectors of the Hessian to compute the similarity of
an image region to neurites, according to the method described in <a class="reference internal" href="#r5ebf02c24e78-1" id="id105">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Frangi correction constant that adjusts the filter&rsquo;s
sensitivity to deviation from a plate-like structure.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.sato" title="cucim.skimage.filters.sato"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sato</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.frangi" title="cucim.skimage.filters.frangi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frangi</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.hessian" title="cucim.skimage.filters.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r5ebf02c24e78-1"><span class="brackets"><a class="fn-backref" href="#id105">1</a></span></dt>
<dd><p>Meijering, E., Jacob, M., Sarria, J. C., Steiner, P., Hirling, H.,
Unser, M. (2004). Design and validation of a tool for neurite tracing
and analysis in fluorescence microscopy images. Cytometry Part A,
58(2), 167-176.
<a class="reference external" href="https://doi.org/10.1002/cyto.a.20022">DOI:10.1002/cyto.a.20022</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.prewitt">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">prewitt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.prewitt" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the edge magnitude using the Prewitt transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prw_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">prewitt</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array of float</span></dt><dd><p>The Prewitt edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The edge magnitude depends slightly on edge directions, since the
approximation of the gradient operator by the Prewitt operator is not
completely rotation invariant. For a better rotation invariance, the Scharr
operator should be used. The Sobel operator has a better rotation
invariance than the Prewitt operator, but a worse rotation invariance than
the Scharr operator.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">prewitt</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.prewitt_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">prewitt_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.prewitt_h" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the horizontal edges of an image using the Prewitt transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Prewitt edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
  <span class="mi">0</span>     <span class="mi">0</span>     <span class="mi">0</span>
<span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.prewitt_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">prewitt_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.prewitt_v" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the vertical edges of an image using the Prewitt transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Prewitt edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">3</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.rank_order">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">rank_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.rank_order" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return an image of the same shape where each pixel is the
index of the pixel value in the ascending order of the unique
values of <code class="docutils literal notranslate"><span class="pre">image</span></code>, aka the rank-order value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of type np.uint32, of shape image.shape</span></dt><dd><p>New array where each pixel has the rank-order value of the
corresponding pixel in <code class="docutils literal notranslate"><span class="pre">image</span></code>. Pixel values are between 0 and
n - 1, where n is the number of distinct unique values in
<code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>original_values</strong><span class="classifier">1-D ndarray</span></dt><dd><p>Unique original values of <code class="docutils literal notranslate"><span class="pre">image</span></code></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[1, 4, 5],</span>
<span class="go">       [4, 4, 1],</span>
<span class="go">       [5, 1, 1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">(array([[0, 1, 2],</span>
<span class="go">       [1, 1, 0],</span>
<span class="go">       [2, 0, 0]], dtype=uint32), array([1, 4, 5]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.1</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rank_order</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="go">(array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.roberts">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">roberts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.roberts" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the edge magnitude using Roberts&rsquo; cross operator.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Roberts&rsquo; Cross edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">feature.canny</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">roberts</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.roberts_neg_diag">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">roberts_neg_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.roberts_neg_diag" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the cross edges of an image using the Roberts&rsquo; Cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Robert&rsquo;s edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">0</span>   <span class="mi">1</span>
<span class="o">-</span><span class="mi">1</span>   <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.roberts_pos_diag">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">roberts_pos_diag</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.roberts_pos_diag" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the cross edges of an image using Roberts&rsquo; cross operator.</p>
<p>The kernel is applied to the input image to produce separate measurements
of the gradient component one orientation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Robert&rsquo;s edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>   <span class="mi">0</span>
<span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sato">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sato</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">range(1,</span> <span class="pre">10,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">black_ridges</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sato" title="Permalink to this definition">&para;</a></dt>
<dd><p>Filter an image with the Sato tubeness filter.</p>
<p>This filter can be used to detect continuous ridges, e.g. tubes,
wrinkles, rivers. It can be used to calculate the fraction of the
whole image containing such objects.</p>
<p>Defined only for 2-D and 3-D images. Calculates the eigenvectors of the
Hessian to compute the similarity of an image region to tubes, according to
the method described in <a class="reference internal" href="#r8b615273143c-1" id="id107">[1]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Array with input image data.</p>
</dd>
<dt><strong>sigmas</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Sigmas used as scales of filter.</p>
</dd>
<dt><strong>black_ridges</strong><span class="classifier">boolean, optional</span></dt><dd><p>When True (the default), the filter detects black ridges; when
False, it detects white ridges.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;}, optional</span></dt><dd><p>How to handle values outside the image borders.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Filtered image (maximum of pixels across all scales).</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.meijering" title="cucim.skimage.filters.meijering"><code class="xref py py-obj docutils literal notranslate"><span class="pre">meijering</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.frangi" title="cucim.skimage.filters.frangi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">frangi</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.filters.hessian" title="cucim.skimage.filters.hessian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hessian</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8b615273143c-1"><span class="brackets"><a class="fn-backref" href="#id107">1</a></span></dt>
<dd><p>Sato, Y., Nakajima, S., Shiraga, N., Atsumi, H., Yoshida, S.,
Koller, T., &hellip;, Kikinis, R. (1998). Three-dimensional multi-scale line
filter for segmentation and visualization of curvilinear structures in
medical images. Medical image analysis, 2(2), 143-168.
<a class="reference external" href="https://doi.org/10.1016/S1361-8415(98)80009-1">DOI:10.1016/S1361-8415(98)80009-1</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.scharr">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">scharr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.scharr" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the edge magnitude using the Scharr transform.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sch_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">scharr</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array of float</span></dt><dd><p>The Scharr edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.sobel" title="cucim.skimage.filters.sobel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sobel</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">canny</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The Scharr operator has a better rotation invariance than
other edge filters such as the Sobel or the Prewitt operators.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9c83a420f26b-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
<dt class="label" id="r9c83a420f26b-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators">https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">scharr</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.scharr_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">scharr_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.scharr_h" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the horizontal edges of an image using the Scharr transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Scharr edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">3</span>   <span class="mi">10</span>   <span class="mi">3</span>
 <span class="mi">0</span>    <span class="mi">0</span>   <span class="mi">0</span>
<span class="o">-</span><span class="mi">3</span>  <span class="o">-</span><span class="mi">10</span>  <span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbb5b441dedec-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.scharr_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">scharr_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.scharr_v" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the vertical edges of an image using the Scharr transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Scharr edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">3</span>   <span class="mi">0</span>   <span class="o">-</span><span class="mi">3</span>
<span class="mi">10</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">10</span>
 <span class="mi">3</span>   <span class="mi">0</span>   <span class="o">-</span><span class="mi">3</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9dd5dffe382e-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sobel">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sobel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sobel" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find edges in an image using the Sobel filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">array of bool, optional</span></dt><dd><p>Clip the output image to this mask. (Values where mask=0 will be set
to 0.)</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int or sequence of int, optional</span></dt><dd><p>Compute the edge filter along this axis. If not provided, the edge
magnitude is computed. This is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">sobel_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">sobel</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)])</span> <span class="o">/</span> <span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>
</div>
<p>The magnitude is also computed if axis is a sequence.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str or sequence of str, optional</span></dt><dd><p>The boundary mode for the convolution. See <cite>scipy.ndimage.convolve</cite>
for a description of the modes. This can be either a single boundary
mode or one boundary mode per axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>When <cite>mode</cite> is <code class="docutils literal notranslate"><span class="pre">'constant'</span></code>, this is the constant used in values
outside the boundary of the image data.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">array of float</span></dt><dd><p>The Sobel edge map.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.filters.scharr" title="cucim.skimage.filters.scharr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scharr</span></code></a>, <a class="reference internal" href="#cucim.skimage.filters.prewitt" title="cucim.skimage.filters.prewitt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prewitt</span></code></a>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">canny</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1f13622bd12e-1"><span class="brackets">1</span></dt>
<dd><p>D. Kroon, 2009, Short Paper University Twente, Numerical
Optimization of Kernel Based Image Derivatives.</p>
</dd>
<dt class="label" id="r1f13622bd12e-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Sobel_operator">https://en.wikipedia.org/wiki/Sobel_operator</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">filters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">filters</span><span class="o">.</span><span class="n">sobel</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sobel_h">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sobel_h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sobel_h" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the horizontal edges of an image using the Sobel transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Sobel edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span> <span class="mi">1</span>   <span class="mi">2</span>   <span class="mi">1</span>
 <span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">0</span>
<span class="o">-</span><span class="mi">1</span>  <span class="o">-</span><span class="mi">2</span>  <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.sobel_v">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">sobel_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.sobel_v" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the vertical edges of an image using the Sobel transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">2-D array</span></dt><dd><p>Image to process.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">2-D array, optional</span></dt><dd><p>An optional mask to limit the application to a certain area.
Note that pixels surrounding masked regions are also masked to
prevent masked regions from affecting the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">2-D array</span></dt><dd><p>The Sobel edge map.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>We use the following kernel:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>
<span class="mi">2</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">2</span>
<span class="mi">1</span>   <span class="mi">0</span>  <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_isodata">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_isodata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_isodata" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return threshold value(s) based on ISODATA method.</p>
<p>Histogram-based threshold, known as Ridler-Calvard method or inter-means.
Threshold values returned satisfy the following equality:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">threshold</span> <span class="o">=</span> <span class="p">(</span><span class="n">image</span><span class="p">[</span><span class="n">image</span> <span class="o">&lt;=</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="o">+</span>
             <span class="n">image</span><span class="p">[</span><span class="n">image</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="o">/</span> <span class="mf">2.0</span>
</pre></div>
</div>
<p>That is, returned thresholds are intensities that separate the image into
two groups of pixels, where the threshold intensity is midway between the
mean intensities of these groups.</p>
<p>For integer images, the above equality holds to within one; for floating-
point images, the equality holds to within the histogram bin-width.</p>
<p>Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray, optional</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>return_all</strong><span class="classifier">bool, optional</span></dt><dd><p>If False (default), return only the lowest threshold that satisfies
the above equality. If True, return all valid thresholds.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram to determine the threshold from and a corresponding array
of bin center intensities. Alternatively, only the histogram can be
passed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float or int or array</span></dt><dd><p>Threshold value(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r763768fdb3d6-1"><span class="brackets">1</span></dt>
<dd><p>Ridler, TW &amp; Calvard, S (1978), &ldquo;Picture thresholding using an
iterative selection method&rdquo;
IEEE Transactions on Systems, Man and Cybernetics 8: 630-632,
<a class="reference external" href="https://doi.org/10.1109/TSMC.1978.4310039">DOI:10.1109/TSMC.1978.4310039</a></p>
</dd>
<dt class="label" id="r763768fdb3d6-2"><span class="brackets">2</span></dt>
<dd><p>Sezgin M. and Sankur B. (2004) &ldquo;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&rdquo; Journal of
Electronic Imaging, 13(1): 146-165,
<a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a>
<a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a></p>
</dd>
<dt class="label" id="r763768fdb3d6-3"><span class="brackets">3</span></dt>
<dd><p>ImageJ AutoThresholder code,
<a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">coins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_isodata</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_li">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_li</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">initial_guess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iter_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_li" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute threshold value by Li&rsquo;s iterative Minimum Cross Entropy method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float, optional</span></dt><dd><p>Finish the computation when the change in the threshold in an iteration
is less than this value. By default, this is half the smallest
difference between intensity values in <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>initial_guess</strong><span class="classifier">float or Callable[[array[float]], float], optional</span></dt><dd><p>Li&rsquo;s iterative method uses gradient descent to find the optimal
threshold. If the image intensity histogram contains more than two
modes (peaks), the gradient descent could get stuck in a local optimum.
An initial guess for the iteration can help the algorithm find the
globally-optimal threshold. A float value defines a specific start
point, while a callable should take in an array of image intensities
and return a float value. Example valid callables include
<code class="docutils literal notranslate"><span class="pre">numpy.mean</span></code> (default), <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">arr:</span> <span class="pre">numpy.quantile(arr,</span> <span class="pre">0.95)</span></code>,
or even <code class="xref py py-func docutils literal notranslate"><span class="pre">skimage.filters.threshold_otsu()</span></code>.</p>
</dd>
<dt><strong>iter_callback</strong><span class="classifier">Callable[[float], Any], optional</span></dt><dd><p>A function that will be called on the threshold at every iteration of
the algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6bdb6acf01e9-1"><span class="brackets">1</span></dt>
<dd><p>Li C.H. and Lee C.K. (1993) &ldquo;Minimum Cross Entropy Thresholding&rdquo;
Pattern Recognition, 26(4): 617-625
<a class="reference external" href="https://doi.org/10.1016/0031-3203(93)90115-D">DOI:10.1016/0031-3203(93)90115-D</a></p>
</dd>
<dt class="label" id="r6bdb6acf01e9-2"><span class="brackets">2</span></dt>
<dd><p>Li C.H. and Tam P.K.S. (1998) &ldquo;An Iterative Algorithm for Minimum
Cross Entropy Thresholding&rdquo; Pattern Recognition Letters, 18(8): 771-776
<a class="reference external" href="https://doi.org/10.1016/S0167-8655(98)00057-9">DOI:10.1016/S0167-8655(98)00057-9</a></p>
</dd>
<dt class="label" id="r6bdb6acf01e9-3"><span class="brackets">3</span></dt>
<dd><p>Sezgin M. and Sankur B. (2004) &ldquo;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&rdquo; Journal of
Electronic Imaging, 13(1): 146-165
<a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a></p>
</dd>
<dt class="label" id="r6bdb6acf01e9-4"><span class="brackets">4</span></dt>
<dd><p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_li</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_local">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_local</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">param</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_local" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute a threshold mask image based on local pixel neighborhood.</p>
<p>Also known as adaptive or dynamic thresholding. The threshold value is
the weighted mean for the local neighborhood of a pixel subtracted by a
constant. Alternatively the threshold can be determined dynamically by a
given function, using the &lsquo;generic&rsquo; method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">int</span></dt><dd><p>Odd size of pixel neighborhood which is used to calculate the
threshold value (e.g. 3, 5, 7, &hellip;, 21, &hellip;).</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;generic&rsquo;, &lsquo;gaussian&rsquo;, &lsquo;mean&rsquo;, &lsquo;median&rsquo;}, optional</span></dt><dd><p>Method used to determine adaptive threshold for local neighbourhood in
weighted mean image.</p>
<ul class="simple">
<li><p>&lsquo;generic&rsquo;: use custom function (see <code class="docutils literal notranslate"><span class="pre">param</span></code> parameter)</p></li>
<li><p>&lsquo;gaussian&rsquo;: apply gaussian filter (see <code class="docutils literal notranslate"><span class="pre">param</span></code> parameter for custom                      sigma value)</p></li>
<li><p>&lsquo;mean&rsquo;: apply arithmetic mean filter</p></li>
<li><p>&lsquo;median&rsquo;: apply median rank filter</p></li>
</ul>
<p>By default the &lsquo;gaussian&rsquo; method is used.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">float, optional</span></dt><dd><p>Constant subtracted from weighted mean of neighborhood to calculate
the local threshold value. Default offset is 0.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.
Default is &lsquo;reflect&rsquo;.</p>
</dd>
<dt><strong>param</strong><span class="classifier">{int, function}, optional</span></dt><dd><p>Either specify sigma for &lsquo;gaussian&rsquo; method or function object for
&lsquo;generic&rsquo; method. This functions takes the flat array of local
neighbourhood as a single argument and returns the calculated
threshold for the centre pixel.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Threshold image. All pixels in the input image higher than the
corresponding pixel in the threshold image are considered foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r657fbacd2bc3-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold">https://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image1</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">threshold_local</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">arr</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image2</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">threshold_local</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s1">'generic'</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">param</span><span class="o">=</span><span class="n">func</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_mean">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_mean" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return threshold value based on the mean of grayscale values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbb85261d77e3-1"><span class="brackets">1</span></dt>
<dd><p>C. A. Glasbey, &ldquo;An analysis of histogram-based thresholding
algorithms,&rdquo; CVGIP: Graphical Models and Image Processing,
vol. 55, pp. 532-537, 1993.
<a class="reference external" href="https://doi.org/10.1006/cgip.1993.1040">DOI:10.1006/cgip.1993.1040</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_mean</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_minimum">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_minimum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_minimum" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return threshold value based on minimum method.</p>
<p>The histogram of the input <code class="docutils literal notranslate"><span class="pre">image</span></code> is computed if not provided and
smoothed until there are only two maxima. Then the minimum in between is
the threshold value.</p>
<p>Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray, optional</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of iterations to smooth the histogram.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram to determine the threshold from and a corresponding array
of bin center intensities. Alternatively, only the histogram can be
passed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>RuntimeError</dt><dd><p>If unable to find two local maxima in the histogram or if the
smoothing takes more than 1e4 iterations.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r24ed7d67d119-1"><span class="brackets">1</span></dt>
<dd><p>C. A. Glasbey, &ldquo;An analysis of histogram-based thresholding
algorithms,&rdquo; CVGIP: Graphical Models and Image Processing,
vol. 55, pp. 532-537, 1993.</p>
</dd>
<dt class="label" id="r24ed7d67d119-2"><span class="brackets">2</span></dt>
<dd><p>Prewitt, JMS &amp; Mendelsohn, ML (1966), &ldquo;The analysis of cell
images&rdquo;, Annals of the New York Academy of Sciences 128: 1035-1053
<a class="reference external" href="https://doi.org/10.1111/j.1749-6632.1965.tb11715.x">DOI:10.1111/j.1749-6632.1965.tb11715.x</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_minimum</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_multiotsu">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_multiotsu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">classes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_multiotsu" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generate <cite>classes</cite>-1 threshold values to divide gray levels in <cite>image</cite>.</p>
<p>The threshold values are chosen to maximize the total sum of pairwise
variances between the thresholded graylevel classes. See Notes and <a class="reference internal" href="#r67a1a24cb955-1" id="id126">[1]</a>
for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>classes</strong><span class="classifier">int, optional</span></dt><dd><p>Number of classes to be thresholded, i.e. the number of resulting
regions.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate the histogram. This value is ignored
for integer arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>thresh</strong><span class="classifier">array</span></dt><dd><p>Array containing the threshold values for the desired classes.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">image</span></code> contains less grayscale value then the desired
number of classes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This implementation relies on a Cython function whose complexity
is <span class="math notranslate nohighlight">\(O\left(\frac{Ch^{C-1}}{(C-1)!}\right)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span>
is the number of histogram bins and <span class="math notranslate nohighlight">\(C\)</span> is the number of
classes desired.</p>
<p>The input image must be grayscale.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r67a1a24cb955-1"><span class="brackets"><a class="fn-backref" href="#id126">1</a></span></dt>
<dd><p>Liao, P-S., Chen, T-S. and Chung, P-C., &ldquo;A fast algorithm for
multilevel thresholding&rdquo;, Journal of Information Science and
Engineering 17 (5): 713-727, 2001. Available at:
&lt;<a class="reference external" href="https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf">https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf</a>&gt;
<a class="reference external" href="https://doi.org/10.6688/JISE.2001.17.5.1">DOI:10.6688/JISE.2001.17.5.1</a></p>
</dd>
<dt class="label" id="r67a1a24cb955-2"><span class="brackets">2</span></dt>
<dd><p>Tosa, Y., &ldquo;Multi-Otsu Threshold&rdquo;, a java plugin for ImageJ.
Available at:
&lt;<a class="reference external" href="http://imagej.net/plugins/download/Multi_OtsuThreshold.java">http://imagej.net/plugins/download/Multi_OtsuThreshold.java</a>&gt;</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">label2rgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresholds</span> <span class="o">=</span> <span class="n">threshold_multiotsu</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">thresholds</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regions_colorized</span> <span class="o">=</span> <span class="n">label2rgb</span><span class="p">(</span><span class="n">regions</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_niblack">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_niblack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_niblack" title="Permalink to this definition">&para;</a></dt>
<dd><p>Applies Niblack local threshold to an array.</p>
<p>A threshold T is calculated for every pixel in the image using the
following formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">*</span> <span class="n">s</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>where m(x,y) and s(x,y) are the mean and standard deviation of
pixel (x,y) neighborhood defined by a rectangular window with size w
times w centered around the pixel. k is a configurable parameter
that weights the effect of standard deviation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>window_size</strong><span class="classifier">int, or iterable of int, optional</span></dt><dd><p>Window size specified as a single odd integer (3, 5, 7, &hellip;),
or an iterable of length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code> containing only odd
integers (e.g. <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">5,</span> <span class="pre">5)</span></code>).</p>
</dd>
<dt><strong>k</strong><span class="classifier">float, optional</span></dt><dd><p>Value of parameter k in threshold formula.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Threshold mask. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This algorithm is originally designed for text recognition.</p>
<p>The Bradley threshold is a particular case of the Niblack
one, being equivalent to</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">page</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">q</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold_image</span> <span class="o">=</span> <span class="n">threshold_niblack</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="n">q</span>
</pre></div>
</div>
<p>for some value <code class="docutils literal notranslate"><span class="pre">q</span></code>. By default, Bradley and Roth use <code class="docutils literal notranslate"><span class="pre">q=1</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r7717d478b316-1"><span class="brackets">1</span></dt>
<dd><p>W. Niblack, An introduction to Digital Image Processing,
Prentice-Hall, 1986.</p>
</dd>
<dt class="label" id="r7717d478b316-2"><span class="brackets">2</span></dt>
<dd><p>D. Bradley and G. Roth, &ldquo;Adaptive thresholding using Integral
Image&rdquo;, Journal of Graphics Tools 12(2), pp. 13-21, 2007.
<a class="reference external" href="https://doi.org/10.1080/2151237X.2007.10129236">DOI:10.1080/2151237X.2007.10129236</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">page</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">threshold_image</span> <span class="o">=</span> <span class="n">threshold_niblack</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_otsu">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_otsu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_otsu" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return threshold value based on Otsu&rsquo;s method.</p>
<p>Either image or hist must be provided. If hist is provided, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray, optional</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities.
An alternative use of this function is to pass it only hist.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The input image must be grayscale.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9495d1f0443c-1"><span class="brackets">1</span></dt>
<dd><p>Wikipedia, <a class="reference external" href="https://en.wikipedia.org/wiki/Otsu's_Method">https://en.wikipedia.org/wiki/Otsu&rsquo;s_Method</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_otsu</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_sauvola">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_sauvola</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_sauvola" title="Permalink to this definition">&para;</a></dt>
<dd><p>Applies Sauvola local threshold to an array. Sauvola is a
modification of Niblack technique.</p>
<p>In the original method a threshold T is calculated for every pixel
in the image using the following formula:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">T</span> <span class="o">=</span> <span class="n">m</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="p">((</span><span class="n">s</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>where m(x,y) and s(x,y) are the mean and standard deviation of
pixel (x,y) neighborhood defined by a rectangular window with size w
times w centered around the pixel. k is a configurable parameter
that weights the effect of standard deviation.
R is the maximum standard deviation of a greyscale image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>window_size</strong><span class="classifier">int, or iterable of int, optional</span></dt><dd><p>Window size specified as a single odd integer (3, 5, 7, &hellip;),
or an iterable of length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code> containing only odd
integers (e.g. <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">5,</span> <span class="pre">5)</span></code>).</p>
</dd>
<dt><strong>k</strong><span class="classifier">float, optional</span></dt><dd><p>Value of the positive parameter k.</p>
</dd>
<dt><strong>r</strong><span class="classifier">float, optional</span></dt><dd><p>Value of R, the dynamic range of standard deviation.
If None, set to the half of the image dtype range.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Threshold mask. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This algorithm is originally designed for text recognition.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r44c24a249523-1"><span class="brackets">1</span></dt>
<dd><p>J. Sauvola and M. Pietikainen, &ldquo;Adaptive document image
binarization,&rdquo; Pattern Recognition 33(2),
pp. 225-236, 2000.
<a class="reference external" href="https://doi.org/10.1016/S0031-3203(99)00055-2">DOI:10.1016/S0031-3203(99)00055-2</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">page</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t_sauvola</span> <span class="o">=</span> <span class="n">threshold_sauvola</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">t_sauvola</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_triangle">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_triangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_triangle" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return threshold value based on the triangle algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M[, &hellip;, P]) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r22136cd60ce5-1"><span class="brackets">1</span></dt>
<dd><p>Zack, G. W., Rogers, W. E. and Latt, S. A., 1977,
Automatic Measurement of Sister Chromatid Exchange Frequency,
Journal of Histochemistry and Cytochemistry 25 (7), pp. 741-753
<a class="reference external" href="https://doi.org/10.1177/25.7.70454">DOI:10.1177/25.7.70454</a></p>
</dd>
<dt class="label" id="r22136cd60ce5-2"><span class="brackets">2</span></dt>
<dd><p>ImageJ AutoThresholder code,
<a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_triangle</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&gt;</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.threshold_yen">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">threshold_yen</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.threshold_yen" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return threshold value based on Yen&rsquo;s method.
Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray, optional</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>nbins</strong><span class="classifier">int, optional</span></dt><dd><p>Number of bins used to calculate histogram. This value is ignored for
integer arrays.</p>
</dd>
<dt><strong>hist</strong><span class="classifier">array, or 2-tuple of arrays, optional</span></dt><dd><p>Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities.
An alternative use of this function is to pass it only hist.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>Upper threshold value. All pixels with an intensity higher than
this value are assumed to be foreground.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r32f25fa7ee23-1"><span class="brackets">1</span></dt>
<dd><p>Yen J.C., Chang F.J., and Chang S. (1995) &ldquo;A New Criterion
for Automatic Multilevel Thresholding&rdquo; IEEE Trans. on Image
Processing, 4(3): 370-378. <a class="reference external" href="https://doi.org/10.1109/83.366472">DOI:10.1109/83.366472</a></p>
</dd>
<dt class="label" id="r32f25fa7ee23-2"><span class="brackets">2</span></dt>
<dd><p>Sezgin M. and Sankur B. (2004) &ldquo;Survey over Image Thresholding
Techniques and Quantitative Performance Evaluation&rdquo; Journal of
Electronic Imaging, 13(1): 146-165, <a class="reference external" href="https://doi.org/10.1117/1.1631315">DOI:10.1117/1.1631315</a>
<a class="reference external" href="http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf">http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf</a></p>
</dd>
<dt class="label" id="r32f25fa7ee23-3"><span class="brackets">3</span></dt>
<dd><p>ImageJ AutoThresholder code, <a class="reference external" href="http://fiji.sc/wiki/index.php/Auto_Threshold">http://fiji.sc/wiki/index.php/Auto_Threshold</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">camera</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">camera</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">thresh</span> <span class="o">=</span> <span class="n">threshold_yen</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary</span> <span class="o">=</span> <span class="n">image</span> <span class="o">&lt;=</span> <span class="n">thresh</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.try_all_threshold">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">try_all_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">figsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(8,</span> <span class="pre">5)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.try_all_threshold" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns a figure comparing the outputs of different thresholding methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>figsize</strong><span class="classifier">tuple, optional</span></dt><dd><p>Figure size (in inches).</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>Print function name for each method.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>fig, ax</strong><span class="classifier">tuple</span></dt><dd><p>Matplotlib figure and axes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The following algorithms are used:</p>
<ul class="simple">
<li><p>isodata</p></li>
<li><p>li</p></li>
<li><p>mean</p></li>
<li><p>minimum</p></li>
<li><p>otsu</p></li>
<li><p>triangle</p></li>
<li><p>yen</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">text</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">try_all_threshold</span><span class="p">(</span><span class="n">text</span><span class="p">(),</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.unsharp_mask">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">unsharp_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">amount</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.unsharp_mask" title="Permalink to this definition">&para;</a></dt>
<dd><p>Unsharp masking filter.</p>
<p>The sharp details are identified as the difference between the original
image and its blurred version. These details are then scaled, and added
back to the original image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">[P, &hellip;, ]M[, N][, C] ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">scalar or sequence of scalars, optional</span></dt><dd><p>If a scalar is given, then its value is used for all dimensions.
If sequence is given, then there must be exactly one radius
for each dimension except the last dimension for multichannel images.
Note that 0 radius means no blurring, and negative values are
not allowed.</p>
</dd>
<dt><strong>amount</strong><span class="classifier">scalar, optional</span></dt><dd><p>The details will be amplified with this factor. The factor could be 0
or negative. Typically, it is a small positive number, e.g. 1.0.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the last <code class="docutils literal notranslate"><span class="pre">image</span></code> dimension is considered as a color channel,
otherwise as spatial. Color channels are processed individually.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <code class="docutils literal notranslate"><span class="pre">img_as_float</span></code>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">[P, &hellip;, ]M[, N][, C] ndarray of float</span></dt><dd><p>Image with unsharp mask applied.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Unsharp masking is an image sharpening technique. It is a linear image
operation, and numerically stable, unlike deconvolution which is an
ill-posed problem. Because of this stability, it is often
preferred over deconvolution.</p>
<p>The main idea is as follows: sharp details are identified as the
difference between the original image and its blurred version.
These details are added back to the original image after a scaling step:</p>
<blockquote>
<div><p>enhanced image = original + amount * (original - blurred)</p>
</div></blockquote>
<p>When applying this filter to several color layers independently,
color bleeding may occur. More visually pleasing result can be
achieved by processing only the brightness/lightness/intensity
channel in a suitable color space such as HSV, HSL, YUV, or YCbCr.</p>
<p>Unsharp masking is described in most introductory digital image
processing books. This implementation is based on <a class="reference internal" href="#r82e4adc9e646-1" id="id138">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r82e4adc9e646-1"><span class="brackets"><a class="fn-backref" href="#id138">1</a></span></dt>
<dd><p>Maria Petrou, Costas Petrou
&ldquo;Image Processing: The Fundamentals&rdquo;, (2010), ed ii., page 357,
ISBN 13: 9781119994398  <a class="reference external" href="https://doi.org/10.1002/9781119994398">DOI:10.1002/9781119994398</a></p>
</dd>
<dt class="label" id="r82e4adc9e646-2"><span class="brackets">2</span></dt>
<dd><p>Wikipedia. Unsharp masking
<a class="reference external" href="https://en.wikipedia.org/wiki/Unsharp_masking">https://en.wikipedia.org/wiki/Unsharp_masking</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">120</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span>
<span class="go">array([[100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 120, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100],</span>
<span class="go">       [100, 100, 100, 100, 100]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unsharp_mask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.39, 0.39, 0.39, 0.39, 0.39],</span>
<span class="go">       [0.39, 0.39, 0.38, 0.39, 0.39],</span>
<span class="go">       [0.39, 0.38, 0.53, 0.38, 0.39],</span>
<span class="go">       [0.39, 0.39, 0.38, 0.39, 0.39],</span>
<span class="go">       [0.39, 0.39, 0.39, 0.39, 0.39]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">array</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">array</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">127</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unsharp_mask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
<span class="go">array([[0.79, 0.79, 0.79, 0.79, 0.79],</span>
<span class="go">       [0.79, 0.78, 0.75, 0.78, 0.79],</span>
<span class="go">       [0.79, 0.75, 1.  , 0.75, 0.79],</span>
<span class="go">       [0.79, 0.78, 0.75, 0.78, 0.79],</span>
<span class="go">       [0.79, 0.79, 0.79, 0.79, 0.79]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="n">unsharp_mask</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">amount</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>                       <span class="n">preserve_range</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
<span class="gp">... </span>          <span class="mi">2</span><span class="p">)</span>
<span class="go">array([[100.  , 100.  ,  99.99, 100.  , 100.  ],</span>
<span class="go">       [100.  ,  99.39,  95.48,  99.39, 100.  ],</span>
<span class="go">       [ 99.99,  95.48, 147.59,  95.48,  99.99],</span>
<span class="go">       [100.  ,  99.39,  95.48,  99.39, 100.  ],</span>
<span class="go">       [100.  , 100.  ,  99.99, 100.  , 100.  ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.wiener">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impulse_response</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">K</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.25</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">predefined_filter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.wiener" title="Permalink to this definition">&para;</a></dt>
<dd><p>Minimum Mean Square Error (Wiener) inverse filter.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">(M,N) ndarray</span></dt><dd><p>Input data.</p>
</dd>
<dt><strong>K</strong><span class="classifier">float or (M,N) ndarray</span></dt><dd><p>Ratio between power spectrum of noise and undegraded
image.</p>
</dd>
<dt><strong>impulse_response</strong><span class="classifier">callable <cite>f(r, c, **filter_params)</cite></span></dt><dd><p>Impulse response of the filter.  See LPIFilter2D.__init__.</p>
</dd>
<dt><strong>filter_params</strong><span class="classifier">dict</span></dt><dd><p>Additional keyword parameters to the impulse_response function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Other Parameters</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>predefined_filter</strong><span class="classifier">LPIFilter2D</span></dt><dd><p>If you need to apply the same filter multiple times over different
images, construct the LPIFilter2D and specify it here.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.filters.window">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.filters.</span></span><span class="sig-name descname"><span class="pre">window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">warp_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.filters.window" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return an n-dimensional window of a given size and dimensionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window_type</strong><span class="classifier">string, float, or tuple</span></dt><dd><p>The type of window to be created. Any window type supported by
<code class="docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code> is allowed here. See notes below for a
current list, or the SciPy documentation for the version of SciPy
on your machine.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple of int or int</span></dt><dd><p>The shape of the window along each axis. If an integer is provided,
a 1D window is generated.</p>
</dd>
<dt><strong>warp_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <cite>skimage.transform.warp</cite> (e.g.,
<code class="docutils literal notranslate"><span class="pre">warp_kwargs={'order':3}</span></code> to change interpolation method).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nd_window</strong><span class="classifier">ndarray</span></dt><dd><p>A window of the specified <code class="docutils literal notranslate"><span class="pre">shape</span></code>. <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is <code class="docutils literal notranslate"><span class="pre">np.double</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is based on <code class="docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code> and thus can access
all of the window types available to that function
(e.g., <code class="docutils literal notranslate"><span class="pre">"hann"</span></code>, <code class="docutils literal notranslate"><span class="pre">"boxcar"</span></code>). Note that certain window types require
parameters that have to be supplied with the window name as a tuple
(e.g., <code class="docutils literal notranslate"><span class="pre">("tukey",</span> <span class="pre">0.8)</span></code>). If only a float is supplied, it is interpreted
as the beta parameter of the Kaiser window.</p>
<p>See <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html">https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html</a>
for more details.</p>
<p>Note that this function generates a double precision array of the specified
<code class="docutils literal notranslate"><span class="pre">shape</span></code> and can thus generate very large arrays that consume a large
amount of available memory.</p>
<p>The approach taken here to create nD windows is to first calculate the
Euclidean distance from the center of the intended nD window to each
position in the array. That distance is used to sample, with
interpolation, from a 1D window returned from <code class="docutils literal notranslate"><span class="pre">scipy.signal.get_window</span></code>.
The method of interpolation can be changed with the <code class="docutils literal notranslate"><span class="pre">order</span></code> keyword
argument passed to <cite>skimage.transform.warp</cite>.</p>
<p>Some coordinates in the output window will be outside of the original
signal; these will be filled in with zeros.</p>
<p>Window types:
- boxcar
- triang
- blackman
- hamming
- hann
- bartlett
- flattop
- parzen
- bohman
- blackmanharris
- nuttall
- barthann
- kaiser (needs beta)
- gaussian (needs standard deviation)
- general_gaussian (needs power, width)
- slepian (needs width)
- dpss (needs normalized half-bandwidth)
- chebwin (needs attenuation)
- exponential (needs decay scale)
- tukey (needs taper fraction)</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r616b68e37c96-1"><span class="brackets">1</span></dt>
<dd><p>Two-dimensional window design, Wikipedia,
<a class="reference external" href="https://en.wikipedia.org/wiki/Two_dimensional_window_design">https://en.wikipedia.org/wiki/Two_dimensional_window_design</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Return a Hann window with shape (512, 512):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.filters</span> <span class="kn">import</span> <span class="n">window</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="s1">'hann'</span><span class="p">,</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mi">512</span><span class="p">))</span>
</pre></div>
</div>
<p>Return a Kaiser window with beta parameter of 16 and shape (256, 256, 35):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">window</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">35</span><span class="p">))</span>
</pre></div>
</div>
<p>Return a Tukey window with an alpha parameter of 0.8 and shape (100, 300):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">w</span> <span class="o">=</span> <span class="n">window</span><span class="p">((</span><span class="s1">'tukey'</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">),</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.measure">
<span id="measure"></span><h3>measure<a class="headerlink" href="#module-cucim.skimage.measure" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.approximate_polygon">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">approximate_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tolerance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.approximate_polygon" title="Permalink to this definition">&para;</a></dt>
<dd><p>Approximate a polygonal chain with the specified tolerance.</p>
<p>It is based on the Douglas-Peucker algorithm.</p>
<p>Note that the approximated polygon is always within the convex hull of the
original polygon.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Maximum distance from original points of polygon to approximated
polygonal chain. If tolerance is 0, the original coordinate array
is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Approximated polygonal chain where M &lt;= N.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r10376cd04fb0-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.block_reduce">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">block_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em>, <em class="sig-param"><span class="pre">block_size</span></em>, <em class="sig-param"><span class="pre">func=&lt;function</span> <span class="pre">sum&gt;</span></em>, <em class="sig-param"><span class="pre">cval=0</span></em>, <em class="sig-param"><span class="pre">func_kwargs=None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.block_reduce" title="Permalink to this definition">&para;</a></dt>
<dd><p>Downsample image by applying function <cite>func</cite> to local blocks.</p>
<p>This function is useful for max and mean pooling, for example.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>block_size</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>func</strong><span class="classifier">callable</span></dt><dd><p>Function object which is used to calculate the return value for each
local block. This function must implement an <code class="docutils literal notranslate"><span class="pre">axis</span></code> parameter.
Primary functions are <code class="docutils literal notranslate"><span class="pre">numpy.sum</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.min</span></code>, <code class="docutils literal notranslate"><span class="pre">numpy.max</span></code>,
<code class="docutils literal notranslate"><span class="pre">numpy.mean</span></code> and <code class="docutils literal notranslate"><span class="pre">numpy.median</span></code>.  See also <cite>func_kwargs</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
block size.</p>
</dd>
<dt><strong>func_kwargs</strong><span class="classifier">dict</span></dt><dd><p>Keyword arguments passed to <cite>func</cite>. Notably useful for passing dtype
argument to <code class="docutils literal notranslate"><span class="pre">np.mean</span></code>. Takes dictionary of inputs, e.g.:
<code class="docutils literal notranslate"><span class="pre">func_kwargs={'dtype':</span> <span class="pre">np.float16})</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">block_reduce</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="mi">3</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> 
<span class="go">array([[[ 0,  1,  2,  3],</span>
<span class="go">        [ 4,  5,  6,  7],</span>
<span class="go">        [ 8,  9, 10, 11]],</span>
<span class="go">       [[12, 13, 14, 15],</span>
<span class="go">        [16, 17, 18, 19],</span>
<span class="go">        [20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27],</span>
<span class="go">        [28, 29, 30, 31],</span>
<span class="go">        [32, 33, 34, 35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([[[16., 17., 18., 19.]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max1</span> 
<span class="go">array([[[11]],</span>
<span class="go">       [[23]],</span>
<span class="go">       [[35]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> <span class="o">=</span> <span class="n">block_reduce</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_max2</span> 
<span class="go">array([[[27],</span>
<span class="go">        [31],</span>
<span class="go">        [35]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.centroid">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">centroid</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.centroid" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return the (weighted) centroid of an image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>center</strong><span class="classifier">tuple of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The centroid of the (nonzero) pixels in <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">centroid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="go">array([13.16666667, 13.16666667])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.inertia_tensor">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">inertia_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em>, <em class="sig-param"><span class="pre">mu=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.inertia_tensor" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the inertia tensor of the input image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>. The inertia tensor
computation requires the central moments of the image. If an
application requires both the central moments and the inertia tensor
(for example, <cite>skimage.measure.regionprops</cite>), then it is more
efficient to pre-compute them and pass them to the inertia tensor
call.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The inertia tensor of the input image. <span class="math notranslate nohighlight">\(T_{i, j}\)</span> contains
the covariance of image intensity along axes <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(j\)</span>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r4e965d45b9bb-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor">https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor</a></p>
</dd>
<dt class="label" id="r4e965d45b9bb-2"><span class="brackets">2</span></dt>
<dd><p>Bernd J&auml;hne. Spatio-Temporal Image Processing: Theory and
Scientific Applications. (Chapter 8: Tensor Methods) Springer, 1993.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.inertia_tensor_eigvals">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">inertia_tensor_eigvals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em>, <em class="sig-param"><span class="pre">mu=None</span></em>, <em class="sig-param"><span class="pre">T=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.inertia_tensor_eigvals" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the eigenvalues of the inertia tensor of the image.</p>
<p>The inertia tensor measures covariance of the image intensity along
the image axes. (See <cite>inertia_tensor</cite>.) The relative magnitude of the
eigenvalues of the tensor is thus a measure of the elongation of a
(bright) object in the image.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">array</span></dt><dd><p>The input image.</p>
</dd>
<dt><strong>mu</strong><span class="classifier">array, optional</span></dt><dd><p>The pre-computed central moments of <code class="docutils literal notranslate"><span class="pre">image</span></code>.</p>
</dd>
<dt><strong>T</strong><span class="classifier">array, shape <code class="docutils literal notranslate"><span class="pre">(image.ndim,</span> <span class="pre">image.ndim)</span></code></span></dt><dd><p>The pre-computed inertia tensor. If <code class="docutils literal notranslate"><span class="pre">T</span></code> is given, <code class="docutils literal notranslate"><span class="pre">mu</span></code> and
<code class="docutils literal notranslate"><span class="pre">image</span></code> are ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eigvals</strong><span class="classifier">list of float, length <code class="docutils literal notranslate"><span class="pre">image.ndim</span></code></span></dt><dd><p>The eigenvalues of the inertia tensor of <code class="docutils literal notranslate"><span class="pre">image</span></code>, in descending
order.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Computing the eigenvalues requires the inertia tensor of the input image.
This is much faster if the central moments (<code class="docutils literal notranslate"><span class="pre">mu</span></code>) are provided, or,
alternatively, one can provide the inertia tensor (<code class="docutils literal notranslate"><span class="pre">T</span></code>) directly.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.label">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">label</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_num</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.label" title="Permalink to this definition">&para;</a></dt>
<dd><p>Label connected regions of an integer array.</p>
<p>Two pixels are connected when they are neighbors and have the same value.
In 2D, they can be neighbors either in a 1- or 2-connected sense.
The value refers to the maximum number of orthogonal hops to consider a
pixel/voxel a neighbor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">-</span><span class="n">connectivity</span>     <span class="mi">2</span><span class="o">-</span><span class="n">connectivity</span>     <span class="n">diagonal</span> <span class="n">connection</span> <span class="n">close</span><span class="o">-</span><span class="n">up</span>

     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>             <span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               \  <span class="o">|</span>  <span class="o">/</span>                 <span class="o">|</span>  <span class="o">&lt;-</span> <span class="n">hop</span> <span class="mi">2</span>
<span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>      <span class="p">[</span> <span class="p">]</span><span class="o">--</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>        <span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">--</span><span class="p">[</span> <span class="p">]</span>
      <span class="o">|</span>               <span class="o">/</span>  <span class="o">|</span>  \             <span class="n">hop</span> <span class="mi">1</span>
     <span class="p">[</span> <span class="p">]</span>           <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>  <span class="p">[</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Image to label.</p>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>Consider all pixels with this value as background pixels, and label
them as 0. By default, 0-valued pixels are considered as background
pixels.</p>
</dd>
<dt><strong>return_num</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to return the number of assigned labels.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum number of orthogonal hops to consider a pixel/voxel
as a neighbor.
Accepted values are ranging from  1 to input.ndim. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, a full
connectivity of <code class="docutils literal notranslate"><span class="pre">input.ndim</span></code> is used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">ndarray of dtype int</span></dt><dd><p>Labeled array, where all connected regions are assigned the
same integer value.</p>
</dd>
<dt><strong>num</strong><span class="classifier">int, optional</span></dt><dd><p>Number of labels, which equals the maximum label index and is only
returned if return_num is <cite>True</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.measure.regionprops" title="cucim.skimage.measure.regionprops"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cucim.skimage.measure.regionprops_table" title="cucim.skimage.measure.regionprops_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">regionprops_table</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Currently the cucim implementation of this function always uses 32-bit
integers for the label array. This is done for performance. In the future
64-bit integer support may also be added for better skimage compatibility.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra24cf73accd3-1"><span class="brackets">1</span></dt>
<dd><p>Christophe Fiorio and Jens Gustedt, &ldquo;Two linear time Union-Find
strategies for image processing&rdquo;, Theoretical Computer Science
154 (1996), pp. 165-181.</p>
</dd>
<dt class="label" id="ra24cf73accd3-2"><span class="brackets">2</span></dt>
<dd><p>Kensheng Wu, Ekow Otoo and Arie Shoshani, &ldquo;Optimizing connected
component labeling algorithms&rdquo;, Paper LBNL-56864, 2005,
Lawrence Berkeley National Laboratory (University of California),
<a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 2 0]</span>
<span class="go"> [0 0 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [0 1 0]</span>
<span class="go"> [0 0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">background</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="go">[[1 2 2]</span>
<span class="go"> [2 1 2]</span>
<span class="go"> [2 2 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="gp">... </span>                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">label</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 1 2]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD floating point or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>m</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Raw image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r962b59a8bdb8-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r962b59a8bdb8-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r962b59a8bdb8-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r962b59a8bdb8-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(14.5, 14.5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_central">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_central</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_central" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<p>The center coordinates (cr, cc) can be calculated from the raw moments as:
{<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p>
<p>Note that central moments are translation invariant but not scale and
rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">nD floating point or uint8 array</span></dt><dd><p>Rasterized shape as image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The maximum order of moments computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>mu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb0a3ccb395bd-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="rb0a3ccb395bd-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="rb0a3ccb395bd-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="rb0a3ccb395bd-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments</span><span class="p">,</span> <span class="n">moments_central</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_coords">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_coords" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate all raw image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) floating point or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>M</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, &hellip;) array</span></dt><dd><p>Raw image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb6e66d7e5174-1"><span class="brackets">1</span></dt>
<dd><p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments_coords</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span>
<span class="go">(14.5, 15.5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_coords_central">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_coords_central</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_coords_central" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate all central image moments up to a certain order.</p>
<dl class="simple">
<dt>The following properties can be calculated from raw image moments:</dt><dd><ul class="simple">
<li><p>Area as: <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">0]</span></code>.</p></li>
<li><p>Centroid as: {<code class="docutils literal notranslate"><span class="pre">M[1,</span> <span class="pre">0]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>, <code class="docutils literal notranslate"><span class="pre">M[0,</span> <span class="pre">1]</span> <span class="pre">/</span> <span class="pre">M[0,</span> <span class="pre">0]</span></code>}.</p></li>
</ul>
</dd>
</dl>
<p>Note that raw moments are neither translation, scale nor rotation
invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) floating point or uint8 array</span></dt><dd><p>Array of N points that describe an image of D dimensionality in
Cartesian space. A tuple of coordinates as returned by
<code class="docutils literal notranslate"><span class="pre">cp.nonzero</span></code> is also accepted as input.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of float, optional</span></dt><dd><p>Coordinates of the image centroid. This will be computed if it
is not provided.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>Mc</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>, &hellip;) array</span></dt><dd><p>Central image moments. (D dimensions)</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r70c1250f8c31-1"><span class="brackets">1</span></dt>
<dd><p>Johannes Kilian. Simple Image Analysis By Moments. Durham
University, version 0.2, Durham, 2001.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">moments_coords_central</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="mi">17</span><span class="p">)</span>
<span class="gp">... </span>                   <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">18</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
<span class="go">array([[16.,  0., 20.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.],</span>
<span class="go">       [20.,  0., 25.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.,  0.]])</span>
</pre></div>
</div>
<p>As seen above, for symmetric objects, odd-order moments (columns 1 and 3,
rows 1 and 3) are zero when centered on the centroid, or center of mass,
of the object (the default). If we break the symmetry by adding a new
point, this no longer holds:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">coords</span><span class="p">,</span> <span class="p">[[</span><span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords2</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">decimals</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  
<span class="go">array([[17.  ,  0.  , 22.12, -2.49],</span>
<span class="go">       [ 0.  ,  3.53,  1.73,  7.4 ],</span>
<span class="go">       [25.88,  6.02, 36.63,  8.83],</span>
<span class="go">       [ 4.15, 19.17, 14.8 , 39.6 ]])</span>
</pre></div>
</div>
<p>Image moments and central image moments are equivalent (by definition)
when the center is (0, 0):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">moments_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">),</span>
<span class="gp">... </span>            <span class="n">moments_coords_central</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_hu">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_hu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nu</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_hu" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate Hu&rsquo;s set of image moments (2D-only).</p>
<p>Note that this set of moments is proofed to be translation, scale and
rotation invariant.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(M, M) array</span></dt><dd><p>Normalized central image moments, where M must be &gt;= 4.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nu</strong><span class="classifier">(7,) array</span></dt><dd><p>Hu&rsquo;s set of image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Due to the small array sizes, this function will be faster on the CPU.
Consider transfering <code class="docutils literal notranslate"><span class="pre">nu</span></code> to the host and running
<code class="docutils literal notranslate"><span class="pre">skimage.measure.moments_hu</span></code> if the moments are not needed on the
device.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r13b44116663b-1"><span class="brackets">1</span></dt>
<dd><p>M. K. Hu, &ldquo;Visual Pattern Recognition by Moment Invariants&rdquo;,
IRE Trans. Info. Theory, vol. IT-8, pp. 179-187, 1962</p>
</dd>
<dt class="label" id="r13b44116663b-2"><span class="brackets">2</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r13b44116663b-3"><span class="brackets">3</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r13b44116663b-4"><span class="brackets">4</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r13b44116663b-5"><span class="brackets">5</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="p">(</span><span class="n">moments_central</span><span class="p">,</span> <span class="n">moments_hu</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">moments_normalized</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">:</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nu</span> <span class="o">=</span> <span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_hu</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
<span class="go">array([7.45370370e-01, 3.51165981e-01, 1.04049179e-01, 4.06442107e-02,</span>
<span class="go">       2.64312299e-03, 2.40854582e-02, 4.33680869e-19])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.moments_normalized">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">moments_normalized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.moments_normalized" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate all normalized central image moments up to a certain order.</p>
<p>Note that normalized central moments are translation and scale invariant
but not rotation invariant.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mu</strong><span class="classifier">(M,[ &hellip;,] M) array</span></dt><dd><p>Central image moments, where M must be greater than or equal
to <code class="docutils literal notranslate"><span class="pre">order</span></code>.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Maximum order of moments. Default is 3.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>nu</strong><span class="classifier">(<code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>,[ &hellip;,] <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code>) array</span></dt><dd><p>Normalized central image moments.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Due to the small array sizes, this function should be faster on the CPU.
Consider transfering <code class="docutils literal notranslate"><span class="pre">mu</span></code> to the host and running
<code class="docutils literal notranslate"><span class="pre">skimage.measure.moments_normalized</span></code>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r653fe38b1244-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r653fe38b1244-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r653fe38b1244-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r653fe38b1244-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="p">(</span><span class="n">moments</span><span class="p">,</span> <span class="n">moments_central</span><span class="p">,</span>
<span class="gp">... </span>                                     <span class="n">moments_normalized</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span><span class="p">[</span><span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">,</span> <span class="mi">13</span><span class="p">:</span><span class="mi">17</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">moments</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centroid</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mu</span> <span class="o">=</span> <span class="n">moments_central</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">centroid</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">moments_normalized</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
<span class="go">array([[       nan,        nan, 0.078125  , 0.        ],</span>
<span class="go">       [       nan, 0.        , 0.        , 0.        ],</span>
<span class="go">       [0.078125  , 0.        , 0.00610352, 0.        ],</span>
<span class="go">       [0.        , 0.        , 0.        , 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.perimeter">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">perimeter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbourhood</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.perimeter" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate total perimeter of all objects in binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>2D binary image.</p>
</dd>
<dt><strong>neighbourhood</strong><span class="classifier">4 or 8, optional</span></dt><dd><p>Neighborhood connectivity for border pixel determination. It is used to
compute the contour. A higher neighbourhood widens the border on which
the perimeter is computed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Total perimeter of all objects in binary image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf0def8f1c63b-1"><span class="brackets">1</span></dt>
<dd><p>K. Benkrid, D. Crookes. Design and FPGA Implementation of
a Perimeter Estimator. The Queen&rsquo;s University of Belfast.
<a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.measure</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># coins image (binary)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_coins</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># total perimeter of all objects in the image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighbourhood</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>  
<span class="go">7796.867...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">perimeter</span><span class="p">(</span><span class="n">img_coins</span><span class="p">,</span> <span class="n">neighbourhood</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>  
<span class="go">8806.268...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.profile_line">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">profile_line</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em>, <em class="sig-param"><span class="pre">src</span></em>, <em class="sig-param"><span class="pre">dst</span></em>, <em class="sig-param"><span class="pre">linewidth=1</span></em>, <em class="sig-param"><span class="pre">order=None</span></em>, <em class="sig-param"><span class="pre">mode=None</span></em>, <em class="sig-param"><span class="pre">cval=0.0</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">reduce_func=&lt;function</span> <span class="pre">mean&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.profile_line" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return the intensity profile of an image measured along a scan line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray, shape (M, N[, C])</span></dt><dd><p>The image, either grayscale (2D array) or multichannel
(3D array, where the final axis contains the channel
information).</p>
</dd>
<dt><strong>src</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the start point of the scan line.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">array_like, shape (2, )</span></dt><dd><p>The coordinates of the end point of the scan
line. The destination point is <em>included</em> in the profile, in
contrast to standard numpy indexing.</p>
</dd>
<dt><strong>linewidth</strong><span class="classifier">int, optional</span></dt><dd><p>Width of the scan, perpendicular to the line</p>
</dd>
<dt><strong>order</strong><span class="classifier">int in {0, 1, 2, 3, 4, 5}, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;nearest&rsquo;, &lsquo;reflect&rsquo;, &lsquo;mirror&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>How to compute any values falling outside of the image.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>If <cite>mode</cite> is &lsquo;constant&rsquo;, what constant value to use outside the image.</p>
</dd>
<dt><strong>reduce_func</strong><span class="classifier">callable, optional</span></dt><dd><p>Function used to calculate the aggregation of pixel values
perpendicular to the profile_line direction when <cite>linewidth</cite> &gt; 1.
If set to None the unreduced array will be returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>return_value</strong><span class="classifier">array</span></dt><dd><p>The intensity profile along the scan line. The length of the profile
is the ceil of the computed length of the scan line.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span>
<span class="go">array([[0, 0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [1, 1, 1, 2, 2, 2],</span>
<span class="go">       [0, 0, 0, 0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">))</span>
<span class="go">array([1., 1., 2., 2.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">cval</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 4.])</span>
</pre></div>
</div>
<p>The destination point is included in the profile, in contrast to
standard numpy indexing.
For example:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>  <span class="c1"># The final point is out of bounds</span>
<span class="go">array([1., 1., 1., 2., 2., 2., 0.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>  <span class="c1"># This accesses the full first row</span>
<span class="go">array([1., 1., 1., 2., 2., 2.])</span>
</pre></div>
</div>
<p>For different reduce_func inputs:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">mean</span><span class="p">)</span>
<span class="go">array([0.66666667, 0.66666667, 0.66666667, 1.33333333])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
<span class="go">array([1, 1, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sum</span><span class="p">)</span>
<span class="go">array([2, 2, 2, 4])</span>
</pre></div>
</div>
<p>The unreduced array will be returned when <cite>reduce_func</cite> is None or when
<cite>reduce_func</cite> acts on each pixel value individually.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">reduce_func</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="go">array([[1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [1, 1, 2],</span>
<span class="go">       [0, 0, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile_line</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">reduce_func</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">)</span>
<span class="go">array([[1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.        , 1.        , 0.        ],</span>
<span class="go">       [1.41421356, 1.41421356, 0.        ]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.regionprops">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">regionprops</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordinates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.regionprops" title="Permalink to this definition">&para;</a></dt>
<dd><p>Measure properties of labeled image regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(M, N[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.14.1: </span>Previously, <code class="docutils literal notranslate"><span class="pre">label_image</span></code> was processed by <code class="docutils literal notranslate"><span class="pre">numpy.squeeze</span></code> and
so any number of singleton dimensions was allowed. This resulted in
inconsistent handling of images with singleton dimensions. To
recover the old behaviour, use
<code class="docutils literal notranslate"><span class="pre">regionprops(np.squeeze(label_image),</span> <span class="pre">...)</span></code>.</p>
</div>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>coordinates</strong><span class="classifier">DEPRECATED</span></dt><dd><p>This argument is deprecated and will be removed in a future version
of scikit-image.</p>
<p>See <a class="reference external" href="https://scikit-image.org/docs/0.18.x/user_guide/numpy_images.html#coordinate-conventions">Coordinate conventions</a>
for more details.</p>
<div class="deprecated">
<p><span class="versionmodified deprecated">Deprecated since version 0.16.0: </span>Use &ldquo;rc&rdquo; coordinates everywhere. It may be sufficient to call
<code class="docutils literal notranslate"><span class="pre">numpy.transpose</span></code> on your label image to get the same values as
0.15 and earlier. However, for some properties, the transformation
will be less trivial. For example, the new orientation is
<span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span> plus the old orientation.</p>
</div>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property wil not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>properties</strong><span class="classifier">list of RegionProperties</span></dt><dd><p>Each item describes one labeled region, and can be accessed using the
attributes listed below.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.measure.label" title="cucim.skimage.measure.label"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The following properties can be accessed as attributes or keys:</p>
<dl>
<dt><strong>area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of the region.</p>
</dd>
<dt><strong>bbox</strong><span class="classifier">tuple</span></dt><dd><p>Bounding box <code class="docutils literal notranslate"><span class="pre">(min_row,</span> <span class="pre">min_col,</span> <span class="pre">max_row,</span> <span class="pre">max_col)</span></code>.
Pixels belonging to the bounding box are in the half-open interval
<code class="docutils literal notranslate"><span class="pre">[min_row;</span> <span class="pre">max_row)</span></code> and <code class="docutils literal notranslate"><span class="pre">[min_col;</span> <span class="pre">max_col)</span></code>.</p>
</dd>
<dt><strong>bbox_area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of bounding box.</p>
</dd>
<dt><strong>centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>.</p>
</dd>
<dt><strong>convex_area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of convex hull image, which is the smallest convex
polygon that encloses the region.</p>
</dd>
<dt><strong>convex_image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary convex hull image which has the same size as bounding box.</p>
</dd>
<dt><strong>coords</strong><span class="classifier">(N, 2) ndarray</span></dt><dd><p>Coordinate list <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> of the region.</p>
</dd>
<dt><strong>eccentricity</strong><span class="classifier">float</span></dt><dd><p>Eccentricity of the ellipse that has the same second-moments as the
region. The eccentricity is the ratio of the focal distance
(distance between focal points) over the major axis length.
The value is in the interval [0, 1).
When it is 0, the ellipse becomes a circle.</p>
</dd>
<dt><strong>equivalent_diameter</strong><span class="classifier">float</span></dt><dd><p>The diameter of a circle with the same area as the region.</p>
</dd>
<dt><strong>euler_number</strong><span class="classifier">int</span></dt><dd><p>Euler characteristic of the set of non-zero pixels.
Computed as number of connected components subtracted by number of
holes (input.ndim connectivity). In 3D, number of connected
components plus number of holes subtracted by number of tunnels.</p>
</dd>
<dt><strong>extent</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels in the total bounding box.
Computed as <code class="docutils literal notranslate"><span class="pre">area</span> <span class="pre">/</span> <span class="pre">(rows</span> <span class="pre">*</span> <span class="pre">cols)</span></code></p>
</dd>
<dt><strong>feret_diameter_max</strong><span class="classifier">float</span></dt><dd><p>Maximum Feret&rsquo;s diameter computed as the longest distance between
points around a region&rsquo;s convex hull contour as determined by
<code class="docutils literal notranslate"><span class="pre">find_contours</span></code>. <a class="reference internal" href="#r357b1e388f3a-5" id="id167">[5]</a></p>
</dd>
<dt><strong>filled_area</strong><span class="classifier">int</span></dt><dd><p>Number of pixels of the region will all the holes filled in. Describes
the area of the filled_image.</p>
</dd>
<dt><strong>filled_image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Binary region image with filled holes which has the same size as
bounding box.</p>
</dd>
<dt><strong>image</strong><span class="classifier">(H, J) ndarray</span></dt><dd><p>Sliced binary region image which has the same size as bounding box.</p>
</dd>
<dt><strong>inertia_tensor</strong><span class="classifier">ndarray</span></dt><dd><p>Inertia tensor of the region for the rotation around its mass.</p>
</dd>
<dt><strong>inertia_tensor_eigvals</strong><span class="classifier">tuple</span></dt><dd><p>The eigenvalues of the inertia tensor in decreasing order.</p>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">ndarray</span></dt><dd><p>Image inside region bounding box.</p>
</dd>
<dt><strong>label</strong><span class="classifier">int</span></dt><dd><p>The label in the labeled input image.</p>
</dd>
<dt><strong>local_centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box.</p>
</dd>
<dt><strong>major_axis_length</strong><span class="classifier">float</span></dt><dd><p>The length of the major axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>max_intensity</strong><span class="classifier">float</span></dt><dd><p>Value with the greatest intensity in the region.</p>
</dd>
<dt><strong>mean_intensity</strong><span class="classifier">float</span></dt><dd><p>Value with the mean intensity in the region.</p>
</dd>
<dt><strong>min_intensity</strong><span class="classifier">float</span></dt><dd><p>Value with the least intensity in the region.</p>
</dd>
<dt><strong>minor_axis_length</strong><span class="classifier">float</span></dt><dd><p>The length of the minor axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
<dt><strong>moments</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">m_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region.</p>
</dd>
<dt><strong>moments_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region,
and <cite>row_c</cite> and <cite>col_c</cite> are the coordinates of the region&rsquo;s centroid.</p>
</dd>
<dt><strong>moments_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant).</p>
</dd>
<dt><strong>moments_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">nu_ij</span> <span class="o">=</span> <span class="n">mu_ij</span> <span class="o">/</span> <span class="n">m_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <cite>m_00</cite> is the zeroth spatial moment.</p>
</dd>
<dt><strong>orientation</strong><span class="classifier">float</span></dt><dd><p>Angle between the 0th axis (rows) and the major
axis of the ellipse that has the same second moments as the region,
ranging from <cite>-pi/2</cite> to <cite>pi/2</cite> counter-clockwise.</p>
</dd>
<dt><strong>perimeter</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object which approximates the contour as a line
through the centers of border pixels using a 4-connectivity.</p>
</dd>
<dt><strong>perimeter_crofton</strong><span class="classifier">float</span></dt><dd><p>Perimeter of object approximated by the Crofton formula in 4
directions.</p>
</dd>
<dt><strong>slice</strong><span class="classifier">tuple of slices</span></dt><dd><p>A slice to extract the object from the source image.</p>
</dd>
<dt><strong>solidity</strong><span class="classifier">float</span></dt><dd><p>Ratio of pixels in the region to pixels of the convex hull image.</p>
</dd>
<dt><strong>weighted_centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> weighted with intensity
image.</p>
</dd>
<dt><strong>weighted_local_centroid</strong><span class="classifier">array</span></dt><dd><p>Centroid coordinate tuple <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code>, relative to region bounding
box, weighted with intensity image.</p>
</dd>
<dt><strong>weighted_moments</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Spatial moments of intensity image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wm_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="n">row</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="n">col</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region.</p>
</dd>
<dt><strong>weighted_moments_central</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Central moments (translation invariant) of intensity image up to
3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wmu_ij</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">{</span> <span class="n">array</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">row_c</span><span class="p">)</span><span class="o">^</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="n">col_c</span><span class="p">)</span><span class="o">^</span><span class="n">j</span> <span class="p">}</span>
</pre></div>
</div>
<p>where the sum is over the <cite>row</cite>, <cite>col</cite> coordinates of the region,
and <cite>row_c</cite> and <cite>col_c</cite> are the coordinates of the region&rsquo;s weighted
centroid.</p>
</dd>
<dt><strong>weighted_moments_hu</strong><span class="classifier">tuple</span></dt><dd><p>Hu moments (translation, scale and rotation invariant) of intensity
image.</p>
</dd>
<dt><strong>weighted_moments_normalized</strong><span class="classifier">(3, 3) ndarray</span></dt><dd><p>Normalized moments (translation and scale invariant) of intensity
image up to 3rd order:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">wnu_ij</span> <span class="o">=</span> <span class="n">wmu_ij</span> <span class="o">/</span> <span class="n">wm_00</span><span class="o">^</span><span class="p">[(</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">wm_00</span></code> is the zeroth spatial moment (intensity-weighted area).</p>
</dd>
</dl>
<p>Each region also supports iteration, so that you can do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">region</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="n">region</span><span class="p">[</span><span class="n">prop</span><span class="p">])</span>
</pre></div>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r357b1e388f3a-1"><span class="brackets">1</span></dt>
<dd><p>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</p>
</dd>
<dt class="label" id="r357b1e388f3a-2"><span class="brackets">2</span></dt>
<dd><p>B. J&auml;hne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</p>
</dd>
<dt class="label" id="r357b1e388f3a-3"><span class="brackets">3</span></dt>
<dd><p>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</p>
</dd>
<dt class="label" id="r357b1e388f3a-4"><span class="brackets">4</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Image_moment">https://en.wikipedia.org/wiki/Image_moment</a></p>
</dd>
<dt class="label" id="r357b1e388f3a-5"><span class="brackets"><a class="fn-backref" href="#id167">5</a></span></dt>
<dd><p>W. Pabst, E. Gregorov&aacute;. Characterization of particles and particle
systems, pp. 27-28. ICT Prague, 2007.
<a class="reference external" href="https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf">https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># centroid of first labeled object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">'centroid'</span><span class="p">]</span>
<span class="go">(22.72987986048314, 81.91228523446583)</span>
</pre></div>
</div>
<p>Add custom measurements by passing functions as <code class="docutils literal notranslate"><span class="pre">extra_properties</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.measure</span> <span class="kn">import</span> <span class="n">label</span><span class="p">,</span> <span class="n">regionprops</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">util</span><span class="o">.</span><span class="n">img_as_ubyte</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">pixelcount</span><span class="p">(</span><span class="n">regionmask</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">regionmask</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">,</span> <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">pixelcount</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pixelcount</span>
<span class="go">7741</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">'pixelcount'</span><span class="p">]</span>
<span class="go">42</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.regionprops_table">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">regionprops_table</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">('label',</span> <span class="pre">'bbox')</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'-'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_properties</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.regionprops_table" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute image properties and return them as a pandas-compatible table.</p>
<p>The table is a dictionary mapping column names to value arrays. See Notes
section below for details.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.16.</span></p>
</div>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_image</strong><span class="classifier">(N, M[, P]) ndarray</span></dt><dd><p>Labeled input image. Labels with value 0 are ignored.</p>
</dd>
<dt><strong>intensity_image</strong><span class="classifier">(M, N[, P][, C]) ndarray, optional</span></dt><dd><p>Intensity (i.e., input) image with same size as labeled image, plus
optionally an extra dimension for multichannel data.
Default is None.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.18.0: </span>The ability to provide an extra dimension for channels was added.</p>
</div>
</dd>
<dt><strong>properties</strong><span class="classifier">tuple or list of str, optional</span></dt><dd><p>Properties that will be included in the resulting dictionary
For a list of available properties, please see <a class="reference internal" href="#cucim.skimage.measure.regionprops" title="cucim.skimage.measure.regionprops"><code class="xref py py-func docutils literal notranslate"><span class="pre">regionprops()</span></code></a>.
Users should remember to add &ldquo;label&rdquo; to keep track of region
identities.</p>
</dd>
<dt><strong>cache</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether to cache calculated properties. The computation is
much faster for cached properties, whereas the memory consumption
increases.</p>
</dd>
<dt><strong>separator</strong><span class="classifier">str, optional</span></dt><dd><p>For non-scalar properties not listed in OBJECT_COLUMNS, each element
will appear in its own column, with the index of that element separated
from the property name by this separator. For example, the inertia
tensor of a 2D region will appear in four columns:
<code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-0</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-0-1</span></code>, <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-0</span></code>,
and <code class="docutils literal notranslate"><span class="pre">inertia_tensor-1-1</span></code> (where the separator is <code class="docutils literal notranslate"><span class="pre">-</span></code>).</p>
<p>Object columns are those that cannot be split in this way because the
number of columns would change depending on the object. For example,
<code class="docutils literal notranslate"><span class="pre">image</span></code> and <code class="docutils literal notranslate"><span class="pre">coords</span></code>.</p>
</dd>
<dt><strong>extra_properties</strong><span class="classifier">Iterable of callables</span></dt><dd><p>Add extra property computation functions that are not included with
skimage. The name of the property is derived from the function name,
the dtype is inferred by calling the function on a small sample.
If the name of an extra property clashes with the name of an existing
property the extra property wil not be visible and a UserWarning is
issued. A property computation function must take a region mask as its
first argument. If the property requires an intensity image, it must
accept the intensity image as the second argument.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out_dict</strong><span class="classifier">dict</span></dt><dd><p>Dictionary mapping property names to an array of values of that
property, one value per region. This dictionary can be used as input to
pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to map property names to columns in the frame and
regions to rows. If the image has no regions,
the arrays will have length 0, but the correct type.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Each column contains either a scalar property, an object property, or an
element in a multidimensional array.</p>
<p>Properties with scalar values for each region, such as &ldquo;eccentricity&rdquo;, will
appear as a float or int array with that property name as key.</p>
<p>Multidimensional properties <em>of fixed size</em> for a given image dimension,
such as &ldquo;centroid&rdquo; (every centroid will have three elements in a 3D image,
no matter the region size), will be split into that many columns, with the
name {property_name}{separator}{element_num} (for 1D properties),
{property_name}{separator}{elem_num0}{separator}{elem_num1} (for 2D
properties), and so on.</p>
<p>For multidimensional properties that don&rsquo;t have a fixed size, such as
&ldquo;image&rdquo; (the image of a region varies in size depending on the region
size), an object array will be used, with the corresponding property name
as the key.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                          <span class="n">properties</span><span class="o">=</span><span class="p">[</span><span class="s1">'label'</span><span class="p">,</span> <span class="s1">'inertia_tensor'</span><span class="p">,</span>
<span class="gp">... </span>                                      <span class="s1">'inertia_tensor_eigvals'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span>  
<span class="go">{'label': array([ 1,  2, ...]), ...</span>
<span class="go"> 'inertia_tensor-0-0': array([  4.012...e+03,   8.51..., ...]), ...</span>
<span class="go"> ...,</span>
<span class="go"> 'inertia_tensor_eigvals-1': array([  2.67...e+02,   2.83..., ...])}</span>
</pre></div>
</div>
<p>The resulting dictionary can be directly passed to pandas, if installed, to
obtain a clean DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span>  
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>  
<span class="go">   label  inertia_tensor-0-0  ...  inertia_tensor_eigvals-1</span>
<span class="go">0      1         4012.909888  ...                267.065503</span>
<span class="go">1      2            8.514739  ...                  2.834806</span>
<span class="go">2      3            0.666667  ...                  0.000000</span>
<span class="go">3      4            0.000000  ...                  0.000000</span>
<span class="go">4      5            0.222222  ...                  0.111111</span>
</pre></div>
</div>
<p>[5 rows x 7 columns]</p>
<p>If we want to measure a feature that does not come as a built-in
property, we can define custom functions and pass them as
<code class="docutils literal notranslate"><span class="pre">extra_properties</span></code>. For example, we can create a custom function
that measures the intensity quartiles in a region:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">util</span><span class="p">,</span> <span class="n">measure</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">quartiles</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">intensity</span><span class="p">[</span><span class="n">regionmask</span><span class="p">],</span> <span class="n">q</span><span class="o">=</span><span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">75</span><span class="p">))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coins</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">image</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">regionprops_table</span><span class="p">(</span><span class="n">label_image</span><span class="p">,</span> <span class="n">intensity_image</span><span class="o">=</span><span class="n">image</span><span class="p">,</span>
<span class="gp">... </span>                                  <span class="n">properties</span><span class="o">=</span><span class="p">(</span><span class="s1">'label'</span><span class="p">,),</span>
<span class="gp">... </span>                                  <span class="n">extra_properties</span><span class="o">=</span><span class="p">(</span><span class="n">quartiles</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">props</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span> 
<span class="go">       label  quartiles-0  quartiles-1  quartiles-2</span>
<span class="go">0      1       117.00        123.0        130.0</span>
<span class="go">1      2       111.25        112.0        114.0</span>
<span class="go">2      3       111.00        111.0        111.0</span>
<span class="go">3      4       111.00        111.5        112.5</span>
<span class="go">4      5       112.50        113.0        114.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.shannon_entropy">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">shannon_entropy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.shannon_entropy" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate the Shannon entropy of an image.</p>
<p>The Shannon entropy is defined as S = -sum(pk * log(pk)),
where pk are frequency/probability of pixels of value k.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(N, M) ndarray</span></dt><dd><p>Grayscale input image.</p>
</dd>
<dt><strong>base</strong><span class="classifier">float, optional</span></dt><dd><p>The logarithmic base to use.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>entropy</strong><span class="classifier">0-dimensional float cupy.ndarray</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The returned value is measured in bits or shannon (Sh) for base=2, natural
unit (nat) for base=np.e and hartley (Hart) for base=10.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r12a42ec6364e-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">https://en.wikipedia.org/wiki/Entropy_(information_theory)</a></p>
</dd>
<dt class="label" id="r12a42ec6364e-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="https://en.wiktionary.org/wiki/Shannon_entropy">https://en.wiktionary.org/wiki/Shannon_entropy</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.measure.subdivide_polygon">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.measure.</span></span><span class="sig-name descname"><span class="pre">subdivide_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_ends</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.measure.subdivide_polygon" title="Permalink to this definition">&para;</a></dt>
<dd><p>Subdivision of polygonal curves using B-Splines.</p>
<p>Note that the resulting curve is always within the convex hull of the
original polygon. Circular polygons stay closed after subdivision.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Coordinate array.</p>
</dd>
<dt><strong>degree</strong><span class="classifier">{1, 2, 3, 4, 5, 6, 7}, optional</span></dt><dd><p>Degree of B-Spline. Default is 2.</p>
</dd>
<dt><strong>preserve_ends</strong><span class="classifier">bool, optional</span></dt><dd><p>Preserve first and last coordinate of non-circular polygon. Default is
False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(M, 2) array</span></dt><dd><p>Subdivided coordinate array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8ce9c450b75c-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.metrics">
<span id="metrics"></span><h3>metrics<a class="headerlink" href="#module-cucim.skimage.metrics" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.mean_squared_error">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">mean_squared_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.mean_squared_error" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the mean-squared error between two images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image0, image1</strong><span class="classifier">ndarray</span></dt><dd><p>Images.  Any dimensionality, must have same shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mse</strong><span class="classifier">float</span></dt><dd><p>The mean-squared error (MSE) metric.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_mse</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.mean_squared_error</span></code>.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.normalized_root_mse">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">normalized_root_mse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_test</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'euclidean'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.normalized_root_mse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the normalized root mean-squared error (NRMSE) between two
images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image_true</strong><span class="classifier">ndarray</span></dt><dd><p>Ground-truth image, same shape as im_test.</p>
</dd>
<dt><strong>image_test</strong><span class="classifier">ndarray</span></dt><dd><p>Test image.</p>
</dd>
<dt><strong>normalization</strong><span class="classifier">{&lsquo;euclidean&rsquo;, &lsquo;min-max&rsquo;, &lsquo;mean&rsquo;}, optional</span></dt><dd><p>Controls the normalization method to use in the denominator of the
NRMSE.  There is no standard method of normalization across the
literature <a class="reference internal" href="#r9462348ca58d-1" id="id176">[1]</a>.  The methods available here are as follows:</p>
<ul>
<li><p>&lsquo;euclidean&rsquo; : normalize by the averaged Euclidean norm of
<code class="docutils literal notranslate"><span class="pre">im_true</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NRMSE</span> <span class="o">=</span> <span class="n">RMSE</span> <span class="o">*</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="o">||</span> <span class="n">im_true</span> <span class="o">||</span>
</pre></div>
</div>
<p>where || . || denotes the Frobenius norm and <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">=</span> <span class="pre">im_true.size</span></code>.
This result is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NRMSE</span> <span class="o">=</span> <span class="o">||</span> <span class="n">im_true</span> <span class="o">-</span> <span class="n">im_test</span> <span class="o">||</span> <span class="o">/</span> <span class="o">||</span> <span class="n">im_true</span> <span class="o">||.</span>
</pre></div>
</div>
</li>
<li><p>&lsquo;min-max&rsquo;   : normalize by the intensity range of <code class="docutils literal notranslate"><span class="pre">im_true</span></code>.</p></li>
<li><p>&lsquo;mean&rsquo;      : normalize by the mean of <code class="docutils literal notranslate"><span class="pre">im_true</span></code></p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>nrmse</strong><span class="classifier">float</span></dt><dd><p>The NRMSE metric.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_nrmse</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.normalized_root_mse</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r9462348ca58d-1"><span class="brackets"><a class="fn-backref" href="#id176">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">https://en.wikipedia.org/wiki/Root-mean-square_deviation</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.peak_signal_noise_ratio">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">peak_signal_noise_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_true</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_test</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.peak_signal_noise_ratio" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the peak signal to noise ratio (PSNR) for an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_true</strong><span class="classifier">ndarray</span></dt><dd><p>Ground-truth image, same shape as im_test.</p>
</dd>
<dt><strong>image_test</strong><span class="classifier">ndarray</span></dt><dd><p>Test image.</p>
</dd>
<dt><strong>data_range</strong><span class="classifier">int, optional</span></dt><dd><p>The data range of the input image (distance between minimum and
maximum possible values).  By default, this is estimated from the image
data-type.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>psnr</strong><span class="classifier">float</span></dt><dd><p>The PSNR metric.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_psnr</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.peak_signal_noise_ratio</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1f1d01c3ecbf-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio">https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.metrics.structural_similarity">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.metrics.</span></span><span class="sig-name descname"><span class="pre">structural_similarity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">im1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">im2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">win_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gradient</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gaussian_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.metrics.structural_similarity" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the mean structural similarity index between two images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>im1, im2</strong><span class="classifier">ndarray</span></dt><dd><p>Images. Any dimensionality with same shape.</p>
</dd>
<dt><strong>win_size</strong><span class="classifier">int or None, optional</span></dt><dd><p>The side-length of the sliding window used in comparison. Must be an
odd value. If <cite>gaussian_weights</cite> is True, this is ignored and the
window size will depend on <cite>sigma</cite>.</p>
</dd>
<dt><strong>gradient</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the gradient with respect to im2.</p>
</dd>
<dt><strong>data_range</strong><span class="classifier">float, optional</span></dt><dd><p>The data range of the input image (distance between minimum and
maximum possible values). By default, this is estimated from the image
data-type.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, treat the last dimension of the array as channels. Similarity
calculations are done independently for each channel then averaged.</p>
</dd>
<dt><strong>gaussian_weights</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, each patch has its mean and variance spatially weighted by a
normalized Gaussian kernel of width sigma=1.5.</p>
</dd>
<dt><strong>full</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, also return the full structural similarity image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mssim</strong><span class="classifier">float</span></dt><dd><p>The mean structural similarity index over the image.</p>
</dd>
<dt><strong>grad</strong><span class="classifier">ndarray</span></dt><dd><p>The gradient of the structural similarity between im1 and im2 <a class="reference internal" href="#rb94e0698d256-2" id="id179">[2]</a>.
This is only returned if <cite>gradient</cite> is set to True.</p>
</dd>
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>The full SSIM image.  This is only returned if <cite>full</cite> is set to True.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>use_sample_covariance</strong><span class="classifier">bool</span></dt><dd><p>If True, normalize covariances by N-1 rather than, N where N is the
number of pixels within the sliding window.</p>
</dd>
<dt><strong>K1</strong><span class="classifier">float</span></dt><dd><p>Algorithm parameter, K1 (small constant, see <a class="reference internal" href="#rb94e0698d256-1" id="id180">[1]</a>).</p>
</dd>
<dt><strong>K2</strong><span class="classifier">float</span></dt><dd><p>Algorithm parameter, K2 (small constant, see <a class="reference internal" href="#rb94e0698d256-1" id="id181">[1]</a>).</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float</span></dt><dd><p>Standard deviation for the Gaussian when <cite>gaussian_weights</cite> is True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To match the implementation of Wang et. al. <a class="reference internal" href="#rb94e0698d256-1" id="id182">[1]</a>, set <cite>gaussian_weights</cite>
to True, <cite>sigma</cite> to 1.5, and <cite>use_sample_covariance</cite> to False.</p>
<div class="versionchanged">
<p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code class="docutils literal notranslate"><span class="pre">skimage.measure.compare_ssim</span></code> to
<code class="docutils literal notranslate"><span class="pre">skimage.metrics.structural_similarity</span></code>.</p>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb94e0698d256-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id180">1</a>,<a href="#id181">2</a>,<a href="#id182">3</a>)</span></dt>
<dd><p>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P.
(2004). Image quality assessment: From error visibility to
structural similarity. IEEE Transactions on Image Processing,
13, 600-612.
<a class="reference external" href="https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf">https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf</a>,
<a class="reference external" href="https://doi.org/10.1109/TIP.2003.819861">DOI:10.1109/TIP.2003.819861</a></p>
</dd>
<dt class="label" id="rb94e0698d256-2"><span class="brackets"><a class="fn-backref" href="#id179">2</a></span></dt>
<dd><p>Avanaki, A. N. (2009). Exact global histogram specification
optimized for structural similarity. Optical Review, 16, 613-621.
<a class="reference external" href="https://arxiv.org/abs/0901.0065">arXiv:0901.0065</a>
<a class="reference external" href="https://doi.org/10.1007/s10043-009-0119-z">DOI:10.1007/s10043-009-0119-z</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.morphology">
<span id="morphology"></span><h3>morphology<a class="headerlink" href="#module-cucim.skimage.morphology" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.ball">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">ball</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">radius</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.ball" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a ball-shaped structuring element.</p>
<p>This is the 3D equivalent of a disk.
A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the ball-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_closing">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_closing" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return fast binary morphological closing of an image.</p>
<p>This function returns the same result as greyscale closing but performs
faster for binary images.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. &ldquo;pepper&rdquo;) and connect
small bright cracks. This tends to &ldquo;close&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>closing</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_dilation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_dilation" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return fast binary morphological dilation of an image.</p>
<p>This function returns the same result as greyscale dilation but performs
faster for binary images.</p>
<p>Morphological dilation sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the maximum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Dilation enlarges bright
regions and shrinks dark regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>dilated</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological dilation with values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_erosion">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_erosion" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return fast binary morphological erosion of an image.</p>
<p>This function returns the same result as greyscale erosion but performs
faster for binary images.</p>
<p>Morphological erosion sets a pixel at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code> to the minimum over all
pixels in the neighborhood centered at <code class="docutils literal notranslate"><span class="pre">(i,j)</span></code>. Erosion shrinks bright
regions and enlarges dark regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>eroded</strong><span class="classifier">ndarray of bool or uint</span></dt><dd><p>The result of the morphological erosion taking values in
<code class="docutils literal notranslate"><span class="pre">[False,</span> <span class="pre">True]</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.binary_opening">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">binary_opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.binary_opening" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return fast binary morphological opening of an image.</p>
<p>This function returns the same result as greyscale opening but performs
faster for binary images.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. &ldquo;salt&rdquo;) and connect
small dark cracks. This tends to &ldquo;open&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Binary input image.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use a cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray of bool, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>opening</strong><span class="classifier">ndarray of bool</span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.black_tophat">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">black_tophat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.black_tophat" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return black top hat of an image.</p>
<p>The black top hat of an image is defined as its morphological closing minus
the original image. This operation returns the dark spots of the image that
are smaller than the structuring element. Note that dark spots in the
original image are bright spots after the black top hat.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological black top hat.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.morphology.white_tophat" title="cucim.skimage.morphology.white_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">white_tophat</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb3bcd3b396ca-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Change dark peak to bright peak and subtract background</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dark_on_grey</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">black_tophat</span><span class="p">(</span><span class="n">dark_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.closing">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">closing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.closing" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return greyscale morphological closing of an image.</p>
<p>The morphological closing on an image is defined as a dilation followed by
an erosion. Closing can remove small dark spots (i.e. &ldquo;pepper&rdquo;) and connect
small bright cracks. This tends to &ldquo;close&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1&rsquo;s and 0&rsquo;s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None,
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>closing</strong><span class="classifier">array, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological closing.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Close a gap between two bright lines</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">broken_line</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                          <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">closing</span><span class="p">(</span><span class="n">broken_line</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 1, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.cube">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">cube</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">width</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.cube" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a cube-shaped structuring element.</p>
<p>This is the 3D equivalent of a square.
Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width, height and depth of the cube.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.diamond">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">diamond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">radius</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.diamond" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a flat, diamond-shaped structuring element.</p>
<p>A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the diamond-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.dilation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">dilation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.dilation" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return greyscale morphological dilation of an image.</p>
<p>Morphological dilation sets a pixel at (i,j) to the maximum over all pixels
in the neighborhood centered at (i,j). Dilation enlarges bright regions
and shrinks dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as a 2-D array of 1&rsquo;s and 0&rsquo;s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None, is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>shift_x, shift_y</strong><span class="classifier">bool, optional</span></dt><dd><p>shift structuring element about center point. This only affects
eccentric structuring elements (i.e. selem with even numbered sides).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>dilated</strong><span class="classifier">uint8 array, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological dilation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <cite>uint8</cite> (and <cite>uint16</cite> up to a certain bit-depth) data, the lower
algorithm complexity makes the <cite>skimage.filters.rank.maximum</cite> function more
efficient for larger images and structuring elements.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Dilation enlarges bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_pixel</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                           <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dilation</span><span class="p">(</span><span class="n">bright_pixel</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.disk">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">disk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">radius</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.disk" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a flat, disk-shaped structuring element.</p>
<p>A pixel is within the neighborhood if the Euclidean distance between
it and the origin is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the disk-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.erosion">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">erosion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift_y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.erosion" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return greyscale morphological erosion of an image.</p>
<p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels
in the neighborhood centered at (i,j). Erosion shrinks bright regions and
enlarges dark regions.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1&rsquo;s and 0&rsquo;s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarrays, optional</span></dt><dd><p>The array to store the result of the morphology. If None is
passed, a new array will be allocated.</p>
</dd>
<dt><strong>shift_x, shift_y</strong><span class="classifier">bool, optional</span></dt><dd><p>shift structuring element about center point. This only affects
eccentric structuring elements (i.e. selem with even numbered sides).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>eroded</strong><span class="classifier">array, same shape as <cite>image</cite></span></dt><dd><p>The result of the morphological erosion.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For <code class="docutils literal notranslate"><span class="pre">uint8</span></code> (and <code class="docutils literal notranslate"><span class="pre">uint16</span></code> up to a certain bit-depth) data, the
lower algorithm complexity makes the <cite>skimage.filters.rank.minimum</cite>
function more efficient for larger images and structuring elements.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Erosion shrinks bright regions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_square</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                            <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">erosion</span><span class="p">(</span><span class="n">bright_square</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.octagon">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">octagon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">m</span></em>, <em class="sig-param"><span class="pre">n</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.octagon" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates an octagon shaped structuring element.</p>
<p>For a given size of (m) horizontal and vertical sides
and a given (n) height or width of slanted sides octagon is generated.
The slanted sides are 45 or 135 degrees to the horizontal axis
and hence the widths and heights are equal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>m</strong><span class="classifier">int</span></dt><dd><p>The size of the horizontal and vertical sides.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The height or width of the slanted sides.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.octahedron">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">octahedron</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">radius</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.octahedron" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a octahedron-shaped structuring element.</p>
<p>This is the 3D equivalent of a diamond.
A pixel is part of the neighborhood (i.e. labeled 1) if
the city block/Manhattan distance between it and the center of
the neighborhood is no greater than radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>radius</strong><span class="classifier">int</span></dt><dd><p>The radius of the octahedron-shaped structuring element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.opening">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">opening</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.opening" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return greyscale morphological opening of an image.</p>
<p>The morphological opening on an image is defined as an erosion followed by
a dilation. Opening can remove small bright spots (i.e. &ldquo;salt&rdquo;) and connect
small dark cracks. This tends to &ldquo;open&rdquo; up (dark) gaps between (bright)
features.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1&rsquo;s and 0&rsquo;s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>opening</strong><span class="classifier">array, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological opening.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Open up gap between two bright regions (but also shrink regions)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bad_connection</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">opening</span><span class="p">(</span><span class="n">bad_connection</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [1, 1, 0, 1, 1],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.reconstruction">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">reconstruction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'dilation'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.reconstruction" title="Permalink to this definition">&para;</a></dt>
<dd><p>Perform a morphological reconstruction of an image.</p>
<p>Morphological reconstruction by dilation is similar to basic morphological
dilation: high-intensity values will replace nearby low-intensity values.
The basic dilation operator, however, uses a structuring element to
determine how far a value in the input image can spread. In contrast,
reconstruction uses two images: a &ldquo;seed&rdquo; image, which specifies the values
that spread, and a &ldquo;mask&rdquo; image, which gives the maximum allowed value at
each pixel. The mask image, like the structuring element, limits the spread
of high-intensity values. Reconstruction by erosion is simply the inverse:
low-intensity values spread from the seed image and are limited by the mask
image, which represents the minimum allowed value.</p>
<p>Alternatively, you can think of reconstruction as a way to isolate the
connected regions of an image. For dilation, reconstruction connects
regions marked by local maxima in the seed image: neighboring pixels
less-than-or-equal-to those seeds are connected to the seeded region.
Local maxima with values larger than the seed image will get truncated to
the seed value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>seed</strong><span class="classifier">ndarray</span></dt><dd><p>The seed image (a.k.a. marker image), which specifies the values that
are dilated or eroded.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">ndarray</span></dt><dd><p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p>
</dd>
<dt><strong>method</strong><span class="classifier">{&lsquo;dilation&rsquo;|&rsquo;erosion&rsquo;}, optional</span></dt><dd><p>Perform reconstruction by dilation or erosion. In dilation (or
erosion), the seed image is dilated (or eroded) until limited by the
mask image. For dilation, each seed value must be less than or equal
to the corresponding mask value; for erosion, the reverse is true.
Default is &lsquo;dilation&rsquo;.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an n-D array of 1&rsquo;s and 0&rsquo;s.
Default is the n-D square of radius equal to 1 (i.e. a 3x3 square
for 2D images, a 3x3x3 cube for 3D images, etc.)</p>
</dd>
<dt><strong>offset</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The coordinates of the center of the structuring element.
Default is located on the geometrical center of the selem, in that case
selem dimensions must be odd.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>reconstructed</strong><span class="classifier">ndarray</span></dt><dd><p>The result of morphological reconstruction.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The algorithm is taken from <a class="reference internal" href="#r790032433545-1" id="id186">[1]</a>. Applications for greyscale reconstruction
are discussed in <a class="reference internal" href="#r790032433545-2" id="id187">[2]</a> and <a class="reference internal" href="#r790032433545-3" id="id188">[3]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r790032433545-1"><span class="brackets"><a class="fn-backref" href="#id186">1</a></span></dt>
<dd><p>Robinson, &ldquo;Efficient morphological reconstruction: a downhill
filter&rdquo;, Pattern Recognition Letters 25 (2004) 1759-1767.</p>
</dd>
<dt class="label" id="r790032433545-2"><span class="brackets"><a class="fn-backref" href="#id187">2</a></span></dt>
<dd><p>Vincent, L., &ldquo;Morphological Grayscale Reconstruction in Image
Analysis: Applications and Efficient Algorithms&rdquo;, IEEE Transactions
on Image Processing (1993)</p>
</dd>
<dt class="label" id="r790032433545-3"><span class="brackets"><a class="fn-backref" href="#id188">3</a></span></dt>
<dd><p>Soille, P., &ldquo;Morphological Image Analysis: Principles and
Applications&rdquo;, Chapter 6, 2nd edition (2003), ISBN 3540429883.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">reconstruction</span>
</pre></div>
</div>
<p>First, we create a sinusoidal mask image with peaks at middle and ends.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Then, we create a seed image initialized to the minimum mask value (for
reconstruction by dilation, min-intensity values don&rsquo;t spread) and add
&ldquo;seeds&rdquo; to the left and right peak, but at a fraction of peak value (1).</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span> <span class="o">=</span> <span class="n">y_mask</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_seed</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y_rec</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">y_seed</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">)</span>
</pre></div>
</div>
<p>The reconstructed image (or curve, in this case) is exactly the same as the
mask image, except that the peaks are truncated to 0.5 and 0. The middle
peak disappears completely: Since there were no seed values in this peak
region, its reconstructed value is truncated to the surrounding value (-1).</p>
<p>As a more practical example, we try to extract the bright features of an
image by subtracting a background image created by reconstruction.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">,</span> <span class="p">:</span><span class="mi">20</span><span class="p">:</span><span class="mf">0.5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>To create the background image, set the mask image to the original image,
and the seed image to the original image with an intensity offset, <cite>h</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">seed</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">h</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">background</span> <span class="o">=</span> <span class="n">reconstruction</span><span class="p">(</span><span class="n">seed</span><span class="p">,</span> <span class="n">bumps</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting reconstructed image looks exactly like the original image,
but with the peaks of the bumps cut off. Subtracting this reconstructed
image from the original image leaves just the peaks of the bumps</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">hdome</span> <span class="o">=</span> <span class="n">bumps</span> <span class="o">-</span> <span class="n">background</span>
</pre></div>
</div>
<p>This operation is known as the h-dome of the image and leaves features
of height <cite>h</cite> in the subtracted image.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.rectangle">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">rectangle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">nrows</span></em>, <em class="sig-param"><span class="pre">ncols</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.rectangle" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a flat, rectangular-shaped structuring element.</p>
<p>Every pixel in the rectangle generated for a given width and given height
belongs to the neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nrows</strong><span class="classifier">int</span></dt><dd><p>The number of rows of the rectangle.</p>
</dd>
<dt><strong>ncols</strong><span class="classifier">int</span></dt><dd><p>The number of columns of the rectangle.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The use of <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> has been deprecated in
scikit-image 0.18.0. Use <code class="docutils literal notranslate"><span class="pre">nrows</span></code> and <code class="docutils literal notranslate"><span class="pre">ncols</span></code> instead.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.remove_small_holes">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_small_holes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">area_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_place</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.remove_small_holes" title="Permalink to this definition">&para;</a></dt>
<dd><p>Remove contiguous holes smaller than the specified size.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the connected components of interest.</p>
</dd>
<dt><strong>area_threshold</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The maximum area, in pixels, of a contiguous hole that will be filled.
Replaces <cite>min_size</cite>.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, &hellip;, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel.</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool, optional (default: False)</span></dt><dd><p>If <cite>True</cite>, remove the connected components in the input array itself.
Otherwise, make a copy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <cite>ar</cite></span></dt><dd><p>The input array with small holes within connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the array type is int, it is assumed that it contains already-labeled
objects. The labels are not kept in the output image (this function always
outputs a bool image). It is suggested that labeling is completed after
using this function.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[ True,  True,  True,  True,  True, False],</span>
<span class="go">       [ True,  True,  True, False,  True, False],</span>
<span class="go">       [ True, False, False,  True,  True, False],</span>
<span class="go">       [ True,  True,  True,  True,  True, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_holes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.remove_small_objects">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">remove_small_objects</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">in_place</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.remove_small_objects" title="Permalink to this definition">&para;</a></dt>
<dd><p>Remove objects smaller than the specified size.</p>
<p>Expects ar to be an array with labeled objects, and removes objects
smaller than min_size. If <cite>ar</cite> is bool, the image is first labeled.
This leads to potentially different behavior for bool and 0-and-1
arrays.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">ndarray (arbitrary shape, int or bool type)</span></dt><dd><p>The array containing the objects of interest. If the array type is
int, the ints must be non-negative.</p>
</dd>
<dt><strong>min_size</strong><span class="classifier">int, optional (default: 64)</span></dt><dd><p>The smallest allowable object size.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int, {1, 2, &hellip;, ar.ndim}, optional (default: 1)</span></dt><dd><p>The connectivity defining the neighborhood of a pixel. Used during
labelling if <cite>ar</cite> is bool.</p>
</dd>
<dt><strong>in_place</strong><span class="classifier">bool, optional (default: False)</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, remove the objects in the input array itself.
Otherwise, make a copy.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray, same shape and type as input <cite>ar</cite></span></dt><dd><p>The input array with small connected components removed.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If the input array is of an invalid type, such as float or string.</p>
</dd>
<dt>ValueError</dt><dd><p>If the input array contains negative values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">morphology</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span>
<span class="go">array([[False, False, False,  True, False],</span>
<span class="go">       [ True,  True,  True, False, False],</span>
<span class="go">       [ True,  True,  True, False, False]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">remove_small_objects</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="ow">is</span> <span class="n">a</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.square">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">square</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">width</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.square" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a flat, square-shaped structuring element.</p>
<p>Every pixel along the perimeter has a chessboard distance
no greater than radius (radius=floor(width/2)) pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>The width and height of the square.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>A structuring element consisting only of ones, i.e. every
pixel belongs to the neighborhood.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.star">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">star</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">a</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint8'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.star" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generates a star shaped structuring element.</p>
<p>Start has 8 vertices and is an overlap of square of size <cite>2*a + 1</cite>
with its 45 degree rotated version.
The slanted sides are 45 or 135 degrees to the horizontal axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>a</strong><span class="classifier">int</span></dt><dd><p>Parameter deciding the size of the star structural element. The side
of the square array returned is <cite>2*a + 1 + 2*floor(a / 2)</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>selem</strong><span class="classifier">ndarray</span></dt><dd><p>The structuring element where elements of the neighborhood
are 1 and 0 otherwise.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data-type</span></dt><dd><p>The data type of the structuring element.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.thin">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">thin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.thin" title="Permalink to this definition">&para;</a></dt>
<dd><p>Perform morphological thinning of a binary image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">binary (M, N) ndarray</span></dt><dd><p>The image to be thinned.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int, number of iterations, optional</span></dt><dd><p>Regardless of the value of this parameter, the thinned image
is returned immediately if an iteration produces no change.
If this parameter is specified it thus sets an upper bound on
the number of iterations performed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of bool</span></dt><dd><p>Thinned image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skeletonize</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">medial_axis</span></code></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This algorithm <a class="reference internal" href="#r455cf7e5f861-1" id="id192">[1]</a> works by making multiple passes over the image,
removing pixels matching a set of criteria designed to thin
connected regions while preserving eight-connected components and
2 x 2 squares <a class="reference internal" href="#r455cf7e5f861-2" id="id193">[2]</a>. In each of the two sub-iterations the algorithm
correlates the intermediate skeleton image with a neighborhood mask,
then looks up each neighborhood in a lookup table indicating whether
the central pixel should be deleted in that sub-iteration.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r455cf7e5f861-1"><span class="brackets"><a class="fn-backref" href="#id192">1</a></span></dt>
<dd><p>Z. Guo and R. W. Hall, &ldquo;Parallel thinning with
two-subiteration algorithms,&rdquo; Comm. ACM, vol. 32, no. 3,
pp. 359-373, 1989. <a class="reference external" href="https://doi.org/10.1145/62065.62074">DOI:10.1145/62065.62074</a></p>
</dd>
<dt class="label" id="r455cf7e5f861-2"><span class="brackets"><a class="fn-backref" href="#id193">2</a></span></dt>
<dd><p>Lam, L., Seong-Whan Lee, and Ching Y. Suen, &ldquo;Thinning
Methodologies-A Comprehensive Survey,&rdquo; IEEE Transactions on
Pattern Analysis and Machine Intelligence, Vol 14, No. 9,
p. 879, 1992. <a class="reference external" href="https://doi.org/10.1109/34.161346">DOI:10.1109/34.161346</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">7</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>  <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span> <span class="o">=</span> <span class="n">thin</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">skel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 1, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.morphology.white_tophat">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.morphology.</span></span><span class="sig-name descname"><span class="pre">white_tophat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selem</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.morphology.white_tophat" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return white top hat of an image.</p>
<p>The white top hat of an image is defined as the image minus its
morphological opening. This operation returns the bright spots of the image
that are smaller than the structuring element.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Image array.</p>
</dd>
<dt><strong>selem</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The neighborhood expressed as an array of 1&rsquo;s and 0&rsquo;s.
If None, use cross-shaped structuring element (connectivity=1).</p>
</dd>
<dt><strong>out</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The array to store the result of the morphology. If None
is passed, a new array will be allocated.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape and type as <cite>image</cite></span></dt><dd><p>The result of the morphological white top hat.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.morphology.black_tophat" title="cucim.skimage.morphology.black_tophat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">black_tophat</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r03d2b2716769-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Subtract grey background from bright peak</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.morphology</span> <span class="kn">import</span> <span class="n">square</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bright_on_grey</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="gp">... </span>                             <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">white_tophat</span><span class="p">(</span><span class="n">bright_on_grey</span><span class="p">,</span> <span class="n">square</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
<span class="go">array([[0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 1, 5, 1, 0],</span>
<span class="go">       [0, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.registration">
<span id="registration"></span><h3>registration<a class="headerlink" href="#module-cucim.skimage.registration" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.registration.optical_flow_ilk">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.registration.</span></span><span class="sig-name descname"><span class="pre">optical_flow_ilk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reference_image</span></em>, <em class="sig-param"><span class="pre">moving_image</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">radius=7</span></em>, <em class="sig-param"><span class="pre">num_warp=10</span></em>, <em class="sig-param"><span class="pre">gaussian=False</span></em>, <em class="sig-param"><span class="pre">prefilter=False</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.registration.optical_flow_ilk" title="Permalink to this definition">&para;</a></dt>
<dd><p>Coarse to fine optical flow estimator.</p>
<p>The iterative Lucas-Kanade (iLK) solver is applied at each level
of the image pyramid. iLK <a class="reference internal" href="#r8a901ce569ca-1" id="id197">[1]</a> is a fast and robust alternative to
TVL1 algorithm although less accurate for rendering flat surfaces
and object boundaries (see <a class="reference internal" href="#r8a901ce569ca-2" id="id198">[2]</a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The first gray scale image of the sequence.</p>
</dd>
<dt><strong>moving_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The second gray scale image of the sequence.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">int, optional</span></dt><dd><p>Radius of the window considered around each pixel.</p>
</dd>
<dt><strong>num_warp</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times moving_image is warped.</p>
</dd>
<dt><strong>gaussian</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, a Gaussian kernel is used for the local
integration. Otherwise, a uniform kernel is used.</p>
</dd>
<dt><strong>prefilter</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to prefilter the estimated optical flow before each
image warp. When True, a median filter with window size 3
along each axis is applied. This helps to remove potential
outliers.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type: must be floating point. Single precision
provides good results and saves memory usage and computation
time compared to double precision.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>flow</strong><span class="classifier">ndarray, shape ((reference_image.ndim, M, N[, P[, &hellip;]])</span></dt><dd><p>The estimated optical flow components for each axis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The implemented algorithm is described in <strong>Table2</strong> of <a class="reference internal" href="#r8a901ce569ca-1" id="id199">[1]</a>.</p></li>
<li><p>Color images are not supported.</p></li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r8a901ce569ca-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id197">1</a>,<a href="#id199">2</a>)</span></dt>
<dd><p>Le Besnerais, G., &amp; Champagnat, F. (2005, September). Dense
optical flow by iterative local window registration. In IEEE
International Conference on Image Processing 2005 (Vol. 1,
pp. I-137). IEEE. <a class="reference external" href="https://doi.org/10.1109/ICIP.2005.1529706">DOI:10.1109/ICIP.2005.1529706</a></p>
</dd>
<dt class="label" id="r8a901ce569ca-2"><span class="brackets"><a class="fn-backref" href="#id198">2</a></span></dt>
<dd><p>Plyer, A., Le Besnerais, G., &amp; Champagnat,
F. (2016). Massively parallel Lucas Kanade optical flow for
real-time video processing applications. Journal of Real-Time
Image Processing, 11(4), 713-730. <a class="reference external" href="https://doi.org/10.1007/s11554-014-0423-0">DOI:10.1007/s11554-014-0423-0</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.registration.optical_flow_tvl1">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.registration.</span></span><span class="sig-name descname"><span class="pre">optical_flow_tvl1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">reference_image</span></em>, <em class="sig-param"><span class="pre">moving_image</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">attachment=15</span></em>, <em class="sig-param"><span class="pre">tightness=0.3</span></em>, <em class="sig-param"><span class="pre">num_warp=5</span></em>, <em class="sig-param"><span class="pre">num_iter=10</span></em>, <em class="sig-param"><span class="pre">tol=0.0001</span></em>, <em class="sig-param"><span class="pre">prefilter=False</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float32'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.registration.optical_flow_tvl1" title="Permalink to this definition">&para;</a></dt>
<dd><p>Coarse to fine optical flow estimator.</p>
<p>The TV-L1 solver is applied at each level of the image
pyramid. TV-L1 is a popular algorithm for optical flow estimation
introduced by Zack et al. <a class="reference internal" href="#rfeed16b8dc8b-1" id="id202">[1]</a>, improved in <a class="reference internal" href="#rfeed16b8dc8b-2" id="id203">[2]</a> and detailed in <a class="reference internal" href="#rfeed16b8dc8b-3" id="id204">[3]</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The first gray scale image of the sequence.</p>
</dd>
<dt><strong>moving_image</strong><span class="classifier">ndarray, shape (M, N[, P[, &hellip;]])</span></dt><dd><p>The second gray scale image of the sequence.</p>
</dd>
<dt><strong>attachment</strong><span class="classifier">float, optional</span></dt><dd><p>Attachment parameter (<span class="math notranslate nohighlight">\(\lambda\)</span> in <a class="reference internal" href="#rfeed16b8dc8b-1" id="id205">[1]</a>). The smaller
this parameter is, the smoother the returned result will be.</p>
</dd>
<dt><strong>tightness</strong><span class="classifier">float, optional</span></dt><dd><p>Tightness parameter (<span class="math notranslate nohighlight">\(\tau\)</span> in <a class="reference internal" href="#rfeed16b8dc8b-1" id="id206">[1]</a>). It should have
a small value in order to maintain attachement and
regularization parts in correspondence.</p>
</dd>
<dt><strong>num_warp</strong><span class="classifier">int, optional</span></dt><dd><p>Number of times image1 is warped.</p>
</dd>
<dt><strong>num_iter</strong><span class="classifier">int, optional</span></dt><dd><p>Number of fixed point iteration.</p>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance used as stopping criterion based on the L&sup2; distance
between two consecutive values of (u, v).</p>
</dd>
<dt><strong>prefilter</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to prefilter the estimated optical flow before each
image warp. When True, a median filter with window size 3
along each axis is applied. This helps to remove potential
outliers.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, optional</span></dt><dd><p>Output data type: must be floating point. Single precision
provides good results and saves memory usage and computation
time compared to double precision.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>flow</strong><span class="classifier">ndarray, shape ((image0.ndim, M, N[, P[, &hellip;]])</span></dt><dd><p>The estimated optical flow components for each axis.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Color images are not supported.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rfeed16b8dc8b-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id202">1</a>,<a href="#id205">2</a>,<a href="#id206">3</a>)</span></dt>
<dd><p>Zach, C., Pock, T., &amp; Bischof, H. (2007, September). A
duality based approach for realtime TV-L 1 optical flow. In Joint
pattern recognition symposium (pp. 214-223). Springer, Berlin,
Heidelberg. <a class="reference external" href="https://doi.org/10.1007/978-3-540-74936-3_22">DOI:10.1007/978-3-540-74936-3_22</a></p>
</dd>
<dt class="label" id="rfeed16b8dc8b-2"><span class="brackets"><a class="fn-backref" href="#id203">2</a></span></dt>
<dd><p>Wedel, A., Pock, T., Zach, C., Bischof, H., &amp; Cremers,
D. (2009). An improved algorithm for TV-L 1 optical flow. In
Statistical and geometrical approaches to visual motion analysis
(pp. 23-45). Springer, Berlin, Heidelberg.
<a class="reference external" href="https://doi.org/10.1007/978-3-642-03061-1_2">DOI:10.1007/978-3-642-03061-1_2</a></p>
</dd>
<dt class="label" id="rfeed16b8dc8b-3"><span class="brackets"><a class="fn-backref" href="#id204">3</a></span></dt>
<dd><p>P&eacute;rez, J. S., Meinhardt-Llopis, E., &amp; Facciolo,
G. (2013). TV-L1 optical flow estimation. Image Processing On
Line, 2013, 137-150. <a class="reference external" href="https://doi.org/10.5201/ipol.2013.26">DOI:10.5201/ipol.2013.26</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.color</span> <span class="kn">import</span> <span class="n">rgb2gray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">stereo_motorcycle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.registration</span> <span class="kn">import</span> <span class="n">optical_flow_tvl1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image0</span><span class="p">,</span> <span class="n">image1</span><span class="p">,</span> <span class="n">disp</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">stereo_motorcycle</span><span class="p">()]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># --- Convert the images to gray level: color is not supported.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image0</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">image0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image1</span> <span class="o">=</span> <span class="n">rgb2gray</span><span class="p">(</span><span class="n">image1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">flow</span> <span class="o">=</span> <span class="n">optical_flow_tvl1</span><span class="p">(</span><span class="n">image1</span><span class="p">,</span> <span class="n">image0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.registration.phase_cross_correlation">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.registration.</span></span><span class="sig-name descname"><span class="pre">phase_cross_correlation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reference_image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_image</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upsample_factor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'real'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_error</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reference_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">moving_mask</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlap_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.registration.phase_cross_correlation" title="Permalink to this definition">&para;</a></dt>
<dd><p>Efficient subpixel image translation registration by cross-correlation.</p>
<p>This code gives the same precision as the FFT upsampled cross-correlation
in a fraction of the computation time and with reduced memory requirements.
It obtains an initial estimate of the cross-correlation peak by an FFT and
then refines the shift estimation by upsampling the DFT only in a small
neighborhood of that estimate by means of a matrix-multiply DFT.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>reference_image</strong><span class="classifier">array</span></dt><dd><p>Reference image.</p>
</dd>
<dt><strong>moving_image</strong><span class="classifier">array</span></dt><dd><p>Image to register. Must be same dimensionality as
<code class="docutils literal notranslate"><span class="pre">reference_image</span></code>.</p>
</dd>
<dt><strong>upsample_factor</strong><span class="classifier">int, optional</span></dt><dd><p>Upsampling factor. Images will be registered to within
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">/</span> <span class="pre">upsample_factor</span></code> of a pixel. For example
<code class="docutils literal notranslate"><span class="pre">upsample_factor</span> <span class="pre">==</span> <span class="pre">20</span></code> means the images will be registered
within 1/20th of a pixel. Default is 1 (no upsampling).
Not used if any of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is not None.</p>
</dd>
<dt><strong>space</strong><span class="classifier">string, one of &ldquo;real&rdquo; or &ldquo;fourier&rdquo;, optional</span></dt><dd><p>Defines how the algorithm interprets input data. &ldquo;real&rdquo; means
data will be FFT&rsquo;d to compute the correlation, while &ldquo;fourier&rdquo;
data will bypass FFT of input data. Case insensitive. Not
used if any of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is not
None.</p>
</dd>
<dt><strong>return_error</strong><span class="classifier">bool, optional</span></dt><dd><p>Returns error and phase difference if on, otherwise only
shifts are returned. Has noeffect if any of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or
<code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is not None. In this case only shifts is returned.</p>
</dd>
<dt><strong>reference_mask</strong><span class="classifier">ndarray</span></dt><dd><p>Boolean mask for <code class="docutils literal notranslate"><span class="pre">reference_image</span></code>. The mask should evaluate
to <code class="docutils literal notranslate"><span class="pre">True</span></code> (or 1) on valid pixels. <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> should
have the same shape as <code class="docutils literal notranslate"><span class="pre">reference_image</span></code>.</p>
</dd>
<dt><strong>moving_mask</strong><span class="classifier">ndarray or None, optional</span></dt><dd><p>Boolean mask for <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>. The mask should evaluate to <code class="docutils literal notranslate"><span class="pre">True</span></code>
(or 1) on valid pixels. <code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> should have the same shape
as <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> will be used.</p>
</dd>
<dt><strong>overlap_ratio</strong><span class="classifier">float, optional</span></dt><dd><p>Minimum allowed overlap ratio between images. The correlation for
translations corresponding with an overlap ratio lower than this
threshold will be ignored. A lower <cite>overlap_ratio</cite> leads to smaller
maximum translation, while a higher <cite>overlap_ratio</cite> leads to greater
robustness against spurious matches due to small overlap between
masked images. Used only if one of <code class="docutils literal notranslate"><span class="pre">reference_mask</span></code> or
<code class="docutils literal notranslate"><span class="pre">moving_mask</span></code> is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>shifts</strong><span class="classifier">ndarray</span></dt><dd><p>Shift vector (in pixels) required to register <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>
with <code class="docutils literal notranslate"><span class="pre">reference_image</span></code>. Axis ordering is consistent with
numpy (e.g. Z, Y, X)</p>
</dd>
<dt><strong>error</strong><span class="classifier">float</span></dt><dd><p>Translation invariant normalized RMS error between
<code class="docutils literal notranslate"><span class="pre">reference_image</span></code> and <code class="docutils literal notranslate"><span class="pre">moving_image</span></code>.</p>
</dd>
<dt><strong>phasediff</strong><span class="classifier">float</span></dt><dd><p>Global phase difference between the two images (should be
zero if images are non-negative).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2c60f15ff436-1"><span class="brackets">1</span></dt>
<dd><p>Manuel Guizar-Sicairos, Samuel T. Thurman, and James R. Fienup,
&ldquo;Efficient subpixel image registration algorithms,&rdquo;
Optics Letters 33, 156-158 (2008). <a class="reference external" href="https://doi.org/10.1364/OL.33.000156">DOI:10.1364/OL.33.000156</a></p>
</dd>
<dt class="label" id="r2c60f15ff436-2"><span class="brackets">2</span></dt>
<dd><p>James R. Fienup, &ldquo;Invariant error metrics for image reconstruction&rdquo;
Optics Letters 36, 8352-8357 (1997). <a class="reference external" href="https://doi.org/10.1364/AO.36.008352">DOI:10.1364/AO.36.008352</a></p>
</dd>
<dt class="label" id="r2c60f15ff436-3"><span class="brackets">3</span></dt>
<dd><p>Dirk Padfield. Masked Object Registration in the Fourier Domain.
IEEE Transactions on Image Processing, vol. 21(5),
pp. 2706-2718 (2012). <a class="reference external" href="https://doi.org/10.1109/TIP.2011.2181402">DOI:10.1109/TIP.2011.2181402</a></p>
</dd>
<dt class="label" id="r2c60f15ff436-4"><span class="brackets">4</span></dt>
<dd><p>D. Padfield. &ldquo;Masked FFT registration&rdquo;. In Proc. Computer Vision and
Pattern Recognition, pp. 2918-2925 (2010).
<a class="reference external" href="https://doi.org/10.1109/CVPR.2010.5540032">DOI:10.1109/CVPR.2010.5540032</a></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-cucim.skimage.restoration">
<span id="restoration"></span><h3>restoration<a class="headerlink" href="#module-cucim.skimage.restoration" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.calibrate_denoiser">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">calibrate_denoiser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">denoise_parameters</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">approximate_loss</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_output</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.calibrate_denoiser" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calibrate a denoising function and return optimal J-invariant version.</p>
<p>The returned function is partially evaluated with optimal parameter values
set for denoising the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input data to be denoised (converted using <cite>img_as_float</cite>).</p>
</dd>
<dt><strong>denoise_function</strong><span class="classifier">function</span></dt><dd><p>Denoising function to be calibrated.</p>
</dd>
<dt><strong>denoise_parameters</strong><span class="classifier">dict of list</span></dt><dd><p>Ranges of parameters for <cite>denoise_function</cite> to be calibrated over.</p>
</dd>
<dt><strong>stride</strong><span class="classifier">int, optional</span></dt><dd><p>Stride used in masking procedure that converts <cite>denoise_function</cite>
to J-invariance.</p>
</dd>
<dt><strong>approximate_loss</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to approximate the self-supervised loss used to evaluate the
denoiser by only computing it on one masked version of the image.
If False, the runtime will be a factor of <cite>stride**image.ndim</cite> longer.</p>
</dd>
<dt><strong>extra_output</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, return parameters and losses in addition to the calibrated
denoising function</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>best_denoise_function</strong><span class="classifier">function</span></dt><dd><p>The optimal J-invariant version of <cite>denoise_function</cite>.</p>
</dd>
<dt>If <cite>extra_output</cite> is True, the following tuple is also returned:</dt><dd></dd>
<dt><strong>(parameters_tested, losses)</strong><span class="classifier">tuple (list of dict, list of int)</span></dt><dd><p>List of parameters tested for <cite>denoise_function</cite>, as a dictionary of
kwargs
Self-supervised loss for each set of parameters in <cite>parameters_tested</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The calibration procedure uses a self-supervised mean-square-error loss
to evaluate the performance of J-invariant versions of <cite>denoise_function</cite>.
The minimizer of the self-supervised loss is also the minimizer of the
ground-truth loss (i.e., the true MSE error) [1]. The returned function
can be used on the original noisy image, or other images with similar
characteristics.</p>
<dl class="simple">
<dt>Increasing the stride increases the performance of <cite>best_denoise_function</cite></dt><dd><p>at the expense of increasing its runtime. It has no effect on the runtime
of the calibration.</p>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb96c97e71b15-1"><span class="brackets">1</span></dt>
<dd><p>J. Batson &amp; L. Royer. Noise2Self: Blind Denoising by Self-Supervision,
International Conference on Machine Learning, p. 524-533 (2019).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">color</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.restoration</span> <span class="kn">import</span> <span class="p">(</span><span class="n">denoise_tv_chambolle</span><span class="p">,</span>
<span class="gp">... </span>                                         <span class="n">calibrate_denoiser</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">noisy</span> <span class="o">=</span> <span class="n">img</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'weight'</span><span class="p">:</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">)}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoising_function</span> <span class="o">=</span> <span class="n">calibrate_denoiser</span><span class="p">(</span><span class="n">noisy</span><span class="p">,</span> <span class="n">denoise_tv_chambolle</span><span class="p">,</span>
<span class="gp">... </span>                                        <span class="n">denoise_parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoising_function</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.denoise_tv_chambolle">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">denoise_tv_chambolle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0002</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_iter_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.denoise_tv_chambolle" title="Permalink to this definition">&para;</a></dt>
<dd><p>Perform total-variation denoising on n-dimensional images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray of ints, uints or floats</span></dt><dd><p>Input data to be denoised. <cite>image</cite> can be of any numeric type,
but it is cast into an ndarray of floats for the computation
of the denoised image.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">float, optional</span></dt><dd><p>Denoising weight. The greater <cite>weight</cite>, the more denoising (at
the expense of fidelity to <cite>input</cite>).</p>
</dd>
<dt><strong>eps</strong><span class="classifier">float, optional</span></dt><dd><p>Relative difference of the value of the cost function that
determines the stop criterion. The algorithm stops when:</p>
<blockquote>
<div><p>(E_(n-1) - E_n) &lt; eps * E_0</p>
</div></blockquote>
</dd>
<dt><strong>n_iter_max</strong><span class="classifier">int, optional</span></dt><dd><p>Maximal number of iterations used for the optimization.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Apply total-variation denoising separately for each channel. This
option should be true for color images, otherwise the denoising is
also applied in the channels dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Denoised image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Make sure to set the multichannel parameter appropriately for color images.</p>
<p>The principle of total variation denoising is explained in
<a class="reference external" href="https://en.wikipedia.org/wiki/Total_variation_denoising">https://en.wikipedia.org/wiki/Total_variation_denoising</a></p>
<p>The principle of total variation denoising is to minimize the
total variation of the image, which can be roughly described as
the integral of the norm of the image gradient. Total variation
denoising tends to produce &ldquo;cartoon-like&rdquo; images, that is,
piecewise-constant images.</p>
<p>This code is an implementation of the algorithm of Rudin, Fatemi and Osher
that was proposed by Chambolle in <a class="reference internal" href="#rd494debfd106-1" id="id215">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rd494debfd106-1"><span class="brackets"><a class="fn-backref" href="#id215">1</a></span></dt>
<dd><p>A. Chambolle, An algorithm for total variation minimization and
applications, Journal of Mathematical Imaging and Vision,
Springer, 2004, 20, 89-97.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>2D example on astronaut image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())[:</span><span class="mi">50</span><span class="p">,</span> <span class="p">:</span><span class="mi">50</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denoised_img</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">60</span><span class="p">)</span>
</pre></div>
</div>
<p>3D example on synthetic data:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">22</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="mi">20</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="mi">17</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">**</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask</span> <span class="o">+=</span> <span class="mf">0.2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">denoise_tv_chambolle</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.richardson_lucy">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">richardson_lucy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iterations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filter_epsilon</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.richardson_lucy" title="Permalink to this definition">&para;</a></dt>
<dd><p>Richardson-Lucy deconvolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input degraded image (can be N dimensional).</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>The point spread function.</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">int, optional</span></dt><dd><p>Number of iterations. This parameter plays the role of
regularisation.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If true, pixel value of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
<dt><strong>filter_epsilon: float, optional</strong></dt><dd><p>Value below which intermediate results become 0 to avoid division
by small numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>im_deconv</strong><span class="classifier">ndarray</span></dt><dd><p>The deconvolved image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra93a945e32d4-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution">https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">img_as_float</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">img_as_float</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupyx.scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">'same'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">camera</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">camera</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">camera</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">richardson_lucy</span><span class="p">(</span><span class="n">camera</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.unsupervised_wiener">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">unsupervised_wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">user_params</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.unsupervised_wiener" title="Permalink to this definition">&para;</a></dt>
<dd><p>Unsupervised Wiener-Hunt deconvolution.</p>
<p>Return the deconvolution with a Wiener-Hunt approach, where the
hyperparameters are automatically estimated. The algorithm is a
stochastic iterative process (Gibbs sampler) described in the
reference below. See also <code class="docutils literal notranslate"><span class="pre">wiener</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The input degraded image.</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>The impulse response (input image&rsquo;s space) or the transfer
function (Fourier space). Both are accepted. The transfer
function is automatically recognized as being complex
(<code class="docutils literal notranslate"><span class="pre">cupy.iscomplexobj(psf)</span></code>).</p>
</dd>
<dt><strong>reg</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The regularisation operator. The Laplacian by default. It can
be an impulse response or a transfer function, as for the psf.</p>
</dd>
<dt><strong>user_params</strong><span class="classifier">dict, optional</span></dt><dd><p>Dictionary of parameters for the Gibbs sampler. See below.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If true, pixel values of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>x_postmean</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The deconvolved image (the posterior mean).</p>
</dd>
<dt><strong>chains</strong><span class="classifier">dict</span></dt><dd><p>The keys <code class="docutils literal notranslate"><span class="pre">noise</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> contain the chain list of
noise and prior precision respectively.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>The keys of ``user_params`` are:</strong></dt><dd></dd>
<dt><strong>threshold</strong><span class="classifier">float</span></dt><dd><p>The stopping criterion: the norm of the difference between to
successive approximated solution (empirical mean of object
samples, see Notes section). 1e-4 by default.</p>
</dd>
<dt><strong>burnin</strong><span class="classifier">int</span></dt><dd><p>The number of sample to ignore to start computation of the
mean. 15 by default.</p>
</dd>
<dt><strong>min_iter</strong><span class="classifier">int</span></dt><dd><p>The minimum number of iterations. 30 by default.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations if <code class="docutils literal notranslate"><span class="pre">threshold</span></code> is not
satisfied. 200 by default.</p>
</dd>
<dt><strong>callback</strong><span class="classifier">callable (None by default)</span></dt><dd><p>A user provided callable to which is passed, if the function
exists, the current image sample for whatever purpose. The user
can store the sample, or compute other moments than the
mean. It has no influence on the algorithm execution and is
only for inspection.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The estimated image is design as the posterior mean of a
probability law (from a Bayesian analysis). The mean is defined as
a sum over all the possible images weighted by their respective
probability. Given the size of the problem, the exact sum is not
tractable. This algorithm use of MCMC to draw image under the
posterior law. The practical idea is to only draw highly probable
images since they have the biggest contribution to the mean. At the
opposite, the less probable images are drawn less often since
their contribution is low. Finally the empirical mean of these
samples give us an estimation of the mean, and an exact
computation with an infinite sample set.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbda4effdf2e5-1"><span class="brackets">1</span></dt>
<dd><p>Fran&ccedil;ois Orieux, Jean-Fran&ccedil;ois Giovannelli, and Thomas
Rodet, &ldquo;Bayesian estimation of regularization and point
spread function parameters for Wiener-Hunt deconvolution&rdquo;,
J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p>
<p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p>
<p><a class="reference external" href="http://research.orieux.fr/files/papers/OGR-JOSA10.pdf">http://research.orieux.fr/files/papers/OGR-JOSA10.pdf</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">'same'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved_img</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">unsupervised_wiener</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.restoration.wiener">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.restoration.</span></span><span class="sig-name descname"><span class="pre">wiener</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">balance</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.restoration.wiener" title="Permalink to this definition">&para;</a></dt>
<dd><p>Wiener-Hunt deconvolution</p>
<p>Return the deconvolution with a Wiener-Hunt approach (i.e. with
Fourier diagonalisation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>Input degraded image</p>
</dd>
<dt><strong>psf</strong><span class="classifier">ndarray</span></dt><dd><p>Point Spread Function. This is assumed to be the impulse
response (input image space) if the data-type is real, or the
transfer function (Fourier space) if the data-type is
complex. There is no constraints on the shape of the impulse
response. The transfer function must be of shape <cite>(M, N)</cite> if
<cite>is_real is True</cite>, <cite>(M, N // 2 + 1)</cite> otherwise (see
<cite>cupy.fft.rfftn</cite>).</p>
</dd>
<dt><strong>balance</strong><span class="classifier">float</span></dt><dd><p>The regularisation parameter value that tunes the balance
between the data adequacy that improve frequency restoration
and the prior adequacy that reduce frequency restoration (to
avoid noise artifacts).</p>
</dd>
<dt><strong>reg</strong><span class="classifier">ndarray, optional</span></dt><dd><p>The regularisation operator. The Laplacian by default. It can
be an impulse response or a transfer function, as for the
psf. Shape constraint is the same as for the <cite>psf</cite> parameter.</p>
</dd>
<dt><strong>is_real</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. Specify if <code class="docutils literal notranslate"><span class="pre">psf</span></code> and <code class="docutils literal notranslate"><span class="pre">reg</span></code> are provided
with hermitian hypothesis, that is only half of the frequency
plane is provided (due to the redundancy of Fourier transform
of real signal). It&rsquo;s apply only if <code class="docutils literal notranslate"><span class="pre">psf</span></code> and/or <code class="docutils literal notranslate"><span class="pre">reg</span></code> are
provided as transfer function.  For the hermitian property see
<code class="docutils literal notranslate"><span class="pre">uft</span></code> module or <code class="docutils literal notranslate"><span class="pre">cupy.fft.rfftn</span></code>.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">boolean, optional</span></dt><dd><p>True by default. If True, pixel values of the result above 1 or
under -1 are thresholded for skimage pipeline compatibility.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>im_deconv</strong><span class="classifier">(M, N) ndarray</span></dt><dd><p>The deconvolved image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function applies the Wiener filter to a noisy and degraded
image by an impulse response (or PSF). If the data model is</p>
<div class="math notranslate nohighlight">
\[y = Hx + n\]</div>
<p>where <span class="math notranslate nohighlight">\(n\)</span> is noise, <span class="math notranslate nohighlight">\(H\)</span> the PSF and <span class="math notranslate nohighlight">\(x\)</span> the
unknown original image, the Wiener filter is</p>
<div class="math notranslate nohighlight">
\[\hat x = F^\dagger (|\Lambda_H|^2 + \lambda |\Lambda_D|^2)
\Lambda_H^\dagger F y\]</div>
<p>where <span class="math notranslate nohighlight">\(F\)</span> and <span class="math notranslate nohighlight">\(F^\dagger\)</span> are the Fourier and inverse
Fourier transforms respectively, <span class="math notranslate nohighlight">\(\Lambda_H\)</span> the transfer
function (or the Fourier transform of the PSF, see [Hunt] below)
and <span class="math notranslate nohighlight">\(\Lambda_D\)</span> the filter to penalize the restored image
frequencies (Laplacian by default, that is penalization of high
frequency). The parameter <span class="math notranslate nohighlight">\(\lambda\)</span> tunes the balance
between the data (that tends to increase high frequency, even
those coming from noise), and the regularization.</p>
<p>These methods are then specific to a prior model. Consequently,
the application or the true image nature must corresponds to the
prior model. By default, the prior model (Laplacian) introduce
image smoothness or pixel correlation. It can also be interpreted
as high-frequency penalization to compensate the instability of
the solution with respect to the data (sometimes called noise
amplification or &ldquo;explosive&rdquo; solution).</p>
<p>Finally, the use of Fourier space implies a circulant property of
<span class="math notranslate nohighlight">\(H\)</span>, see [Hunt].</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r33534ae55690-1"><span class="brackets">1</span></dt>
<dd><p>Fran&ccedil;ois Orieux, Jean-Fran&ccedil;ois Giovannelli, and Thomas
Rodet, &ldquo;Bayesian estimation of regularization and point
spread function parameters for Wiener-Hunt deconvolution&rdquo;,
J. Opt. Soc. Am. A 27, 1593-1607 (2010)</p>
<p><a class="reference external" href="https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593">https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593</a></p>
<p><a class="reference external" href="http://research.orieux.fr/files/papers/OGR-JOSA10.pdf">http://research.orieux.fr/files/papers/OGR-JOSA10.pdf</a></p>
</dd>
<dt class="label" id="r33534ae55690-2"><span class="brackets">2</span></dt>
<dd><p>B. R. Hunt &ldquo;A matrix theory proof of the discrete
convolution theorem&rdquo;, IEEE Trans. on Audio and
Electroacoustics, vol. au-19, no. 4, pp. 285-288, dec. 1971</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">restoration</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">color</span><span class="o">.</span><span class="n">rgb2gray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">convolve2d</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">psf</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="o">/</span> <span class="mi">25</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="s1">'same'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">img</span><span class="o">.</span><span class="n">std</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">standard_normal</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deconvolved_img</span> <span class="o">=</span> <span class="n">restoration</span><span class="o">.</span><span class="n">wiener</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">psf</span><span class="p">,</span> <span class="mi">1100</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.segmentation">
<span id="segmentation"></span><h3>segmentation<a class="headerlink" href="#module-cucim.skimage.segmentation" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.checkerboard_level_set">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">checkerboard_level_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">square_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.checkerboard_level_set" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create a checkerboard level set with binary values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_shape</strong><span class="classifier">tuple of positive integers</span></dt><dd><p>Shape of the image.</p>
</dd>
<dt><strong>square_size</strong><span class="classifier">int, optional</span></dt><dd><p>Size of the squares of the checkerboard. It defaults to 5.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array with shape <cite>image_shape</cite></span></dt><dd><p>Binary level set of the checkerboard.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.circle_level_set" title="cucim.skimage.segmentation.circle_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">circle_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.circle_level_set">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">circle_level_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.circle_level_set" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create a circle level set with binary values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_shape</strong><span class="classifier">tuple of positive integers</span></dt><dd><p>Shape of the image</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of positive integers, optional</span></dt><dd><p>Coordinates of the center of the circle given in (row, column). If not
given, it defaults to the center of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the circle. If not given, it is set to the 75% of the
smallest image dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array with shape <cite>image_shape</cite></span></dt><dd><p>Binary level set of the circle with the given <cite>radius</cite> and <cite>center</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Warns</dt>
<dd class="field-odd"><dl>
<dt>Deprecated:</dt><dd><div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span>This function is deprecated and will be removed in scikit-image
0.19. Please use the function named <code class="docutils literal notranslate"><span class="pre">disk_level_set</span></code> instead.</p>
</div>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkerboard_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.disk_level_set">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">disk_level_set</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image_shape</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.disk_level_set" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create a disk level set with binary values.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image_shape</strong><span class="classifier">tuple of positive integers</span></dt><dd><p>Shape of the image</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple of positive integers, optional</span></dt><dd><p>Coordinates of the center of the disk given in (row, column). If not
given, it defaults to the center of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the disk. If not given, it is set to the 75% of the
smallest image dimension.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array with shape <cite>image_shape</cite></span></dt><dd><p>Binary level set of the disk with the given <cite>radius</cite> and <cite>center</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkerboard_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.find_boundaries">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">find_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connectivity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'thick'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.find_boundaries" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return bool array where boundaries between labeled regions are True.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>label_img</strong><span class="classifier">array of int or bool</span></dt><dd><p>An array in which different regions are labeled with either different
integers or boolean values.</p>
</dd>
<dt><strong>connectivity</strong><span class="classifier">int in {1, &hellip;, <cite>label_img.ndim</cite>}, optional</span></dt><dd><p>A pixel is considered a boundary pixel if any of its neighbors
has a different label. <cite>connectivity</cite> controls which pixels are
considered neighbors. A connectivity of 1 (default) means
pixels sharing an edge (in 2D) or a face (in 3D) will be
considered neighbors. A connectivity of <cite>label_img.ndim</cite> means
pixels sharing a corner will be considered neighbors.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string in {&lsquo;thick&rsquo;, &lsquo;inner&rsquo;, &lsquo;outer&rsquo;, &lsquo;subpixel&rsquo;}</span></dt><dd><p>How to mark the boundaries:</p>
<ul class="simple">
<li><p>thick: any pixel not completely surrounded by pixels of the
same label (defined by <cite>connectivity</cite>) is marked as a boundary.
This results in boundaries that are 2 pixels thick.</p></li>
<li><p>inner: outline the pixels <em>just inside</em> of objects, leaving
background pixels untouched.</p></li>
<li><p>outer: outline pixels in the background around object
boundaries. When two objects touch, their boundary is also
marked.</p></li>
<li><p>subpixel: return a doubled image, with pixels <em>between</em> the
original pixels marked as boundary where appropriate.</p></li>
</ul>
</dd>
<dt><strong>background</strong><span class="classifier">int, optional</span></dt><dd><p>For modes &lsquo;inner&rsquo; and &lsquo;outer&rsquo;, a definition of a background
label is required. See <cite>mode</cite> for descriptions of these two.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>boundaries</strong><span class="classifier">array of bool, same shape as <cite>label_img</cite></span></dt><dd><p>A bool image where <code class="docutils literal notranslate"><span class="pre">True</span></code> represents a boundary pixel. For
<cite>mode</cite> equal to &lsquo;subpixel&rsquo;, <code class="docutils literal notranslate"><span class="pre">boundaries.shape[i]</span></code> is equal
to <code class="docutils literal notranslate"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">label_img.shape[i]</span> <span class="pre">-</span> <span class="pre">1</span></code> for all <code class="docutils literal notranslate"><span class="pre">i</span></code> (a pixel is
inserted in between all other pairs of pixels).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'thick'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'inner'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 0, 1, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'outer'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_small</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[::</span><span class="mi">2</span><span class="p">,</span> <span class="p">::</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_small</span>
<span class="go">array([[0, 0, 0, 0],</span>
<span class="go">       [0, 0, 5, 0],</span>
<span class="go">       [0, 1, 5, 0],</span>
<span class="go">       [0, 0, 5, 0],</span>
<span class="go">       [0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">labels_small</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'subpixel'</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="go">array([[0, 0, 0, 0, 0, 0, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 1, 0, 1, 0, 1, 0],</span>
<span class="go">       [0, 1, 1, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 0, 1, 0],</span>
<span class="go">       [0, 0, 0, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bool_image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">],</span>
<span class="gp">... </span>                       <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">,</span>  <span class="kc">True</span><span class="p">]],</span>
<span class="gp">... </span>                      <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">bool_image</span><span class="p">)</span>
<span class="go">array([[False, False, False, False, False],</span>
<span class="go">       [False, False,  True,  True,  True],</span>
<span class="go">       [False,  True,  True,  True,  True],</span>
<span class="go">       [False,  True,  True, False, False],</span>
<span class="go">       [False,  True,  True, False, False]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.inverse_gaussian_gradient">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">inverse_gaussian_gradient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.inverse_gaussian_gradient" title="Permalink to this definition">&para;</a></dt>
<dd><p>Inverse of gradient magnitude.</p>
<p>Compute the magnitude of the gradients in the image and then inverts the
result in the range [0, 1]. Flat areas are assigned values close to 1,
while areas close to borders are assigned values close to 0.</p>
<p>This function or a similar one defined by the user should be applied over
the image as a preprocessing step before calling
<cite>morphological_geodesic_active_contour</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Grayscale image or volume.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float, optional</span></dt><dd><p>Controls the steepness of the inversion. A larger value will make the
transition between the flat areas and border areas steeper in the
resulting array.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Standard deviation of the Gaussian filter applied over the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>gimage</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Preprocessed image (or volume) suitable for
<cite>morphological_geodesic_active_contour</cite>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.join_segmentations">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">join_segmentations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">s1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.join_segmentations" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return the join of the two input segmentations.</p>
<p>The join J of S1 and S2 is defined as the segmentation in which two
voxels are in the same segment if and only if they are in the same
segment in <em>both</em> S1 and S2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s1, s2</strong><span class="classifier">numpy arrays</span></dt><dd><p>s1 and s2 are label fields of the same shape.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>j</strong><span class="classifier">numpy array</span></dt><dd><p>The join segmentation of s1 and s2.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.segmentation</span> <span class="kn">import</span> <span class="n">join_segmentations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>               <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">join_segmentations</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
<span class="go">array([[0, 1, 3, 2],</span>
<span class="go">       [0, 5, 3, 2],</span>
<span class="go">       [4, 5, 5, 3]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.mark_boundaries">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">mark_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label_img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outline_color</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'outer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_label</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.mark_boundaries" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return image with boundaries between labeled regions highlighted.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N[, 3]) array</span></dt><dd><p>Grayscale or RGB image.</p>
</dd>
<dt><strong>label_img</strong><span class="classifier">(M, N) array of int</span></dt><dd><p>Label array where regions are marked by different integer values.</p>
</dd>
<dt><strong>color</strong><span class="classifier">length-3 sequence, optional</span></dt><dd><p>RGB color of boundaries in the output image.</p>
</dd>
<dt><strong>outline_color</strong><span class="classifier">length-3 sequence, optional</span></dt><dd><p>RGB color surrounding boundaries in the output image. If None, no
outline is drawn.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string in {&lsquo;thick&rsquo;, &lsquo;inner&rsquo;, &lsquo;outer&rsquo;, &lsquo;subpixel&rsquo;}, optional</span></dt><dd><p>The mode for finding boundaries.</p>
</dd>
<dt><strong>background_label</strong><span class="classifier">int, optional</span></dt><dd><p>Which label to consider background (this is only useful for
modes <code class="docutils literal notranslate"><span class="pre">inner</span></code> and <code class="docutils literal notranslate"><span class="pre">outer</span></code>).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>marked</strong><span class="classifier">(M, N, 3) array of float</span></dt><dd><p>An image in which the boundaries between labels are
superimposed on the original image.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.find_boundaries" title="cucim.skimage.segmentation.find_boundaries"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_boundaries</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.morphological_chan_vese">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">morphological_chan_vese</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">image</span></em>, <em class="sig-param"><span class="pre">iterations</span></em>, <em class="sig-param"><span class="pre">init_level_set='checkerboard'</span></em>, <em class="sig-param"><span class="pre">smoothing=1</span></em>, <em class="sig-param"><span class="pre">lambda1=1</span></em>, <em class="sig-param"><span class="pre">lambda2=1</span></em>, <em class="sig-param"><span class="pre">iter_callback=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.morphological_chan_vese" title="Permalink to this definition">&para;</a></dt>
<dd><p>Morphological Active Contours without Edges (MorphACWE)</p>
<p>Active contours without edges implemented with morphological operators. It
can be used to segment objects in images and volumes without well defined
borders. It is required that the inside of the object looks different on
average than the outside (i.e., the inner area of the object should be
darker or lighter than the outer area on average).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Grayscale image or volume to be segmented.</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">uint</span></dt><dd><p>Number of iterations to run</p>
</dd>
<dt><strong>init_level_set</strong><span class="classifier">str, (M, N) array, or (L, M, N) array</span></dt><dd><p>Initial level set. If an array is given, it will be binarized and used
as the initial level set. If a string is given, it defines the method
to generate a reasonable initial level set with the shape of the
<cite>image</cite>. Accepted values are &lsquo;checkerboard&rsquo; and &lsquo;circle&rsquo;. See the
documentation of <cite>checkerboard_level_set</cite> and <cite>circle_level_set</cite>
respectively for details about how these level sets are created.</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">uint, optional</span></dt><dd><p>Number of times the smoothing operator is applied per iteration.
Reasonable values are around 1-4. Larger values lead to smoother
segmentations.</p>
</dd>
<dt><strong>lambda1</strong><span class="classifier">float, optional</span></dt><dd><p>Weight parameter for the outer region. If <cite>lambda1</cite> is larger than
<cite>lambda2</cite>, the outer region will contain a larger range of values than
the inner region.</p>
</dd>
<dt><strong>lambda2</strong><span class="classifier">float, optional</span></dt><dd><p>Weight parameter for the inner region. If <cite>lambda2</cite> is larger than
<cite>lambda1</cite>, the inner region will contain a larger range of values than
the outer region.</p>
</dd>
<dt><strong>iter_callback</strong><span class="classifier">function, optional</span></dt><dd><p>If given, this function is called once per iteration with the current
level set as the only argument. This is useful for debugging or for
plotting intermediate results during the evolution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Final segmentation (i.e., the final level set)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.circle_level_set" title="cucim.skimage.segmentation.circle_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">circle_level_set</span></code></a>, <a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkerboard_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This is a version of the Chan-Vese algorithm that uses morphological
operators instead of solving a partial differential equation (PDE) for the
evolution of the contour. The set of morphological operators used in this
algorithm are proved to be infinitesimally equivalent to the Chan-Vese PDE
(see <a class="reference internal" href="#r2416b93d33b0-1" id="id221">[1]</a>). However, morphological operators are do not suffer from the
numerical stability issues typically found in PDEs (it is not necessary to
find the right time step for the evolution), and are computationally
faster.</p>
<p>The algorithm and its theoretical derivation are described in <a class="reference internal" href="#r2416b93d33b0-1" id="id222">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r2416b93d33b0-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id221">1</a>,<a href="#id222">2</a>)</span></dt>
<dd><p>A Morphological Approach to Curvature-based Evolution of Curves and
Surfaces, Pablo M&aacute;rquez-Neila, Luis Baumela, Luis &Aacute;lvarez. In IEEE
Transactions on Pattern Analysis and Machine Intelligence (PAMI),
2014, <a class="reference external" href="https://doi.org/10.1109/TPAMI.2013.106">DOI:10.1109/TPAMI.2013.106</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.morphological_geodesic_active_contour">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">morphological_geodesic_active_contour</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">gimage</span></em>, <em class="sig-param"><span class="pre">iterations</span></em>, <em class="sig-param"><span class="pre">init_level_set='circle'</span></em>, <em class="sig-param"><span class="pre">smoothing=1</span></em>, <em class="sig-param"><span class="pre">threshold='auto'</span></em>, <em class="sig-param"><span class="pre">balloon=0</span></em>, <em class="sig-param"><span class="pre">iter_callback=&lt;function</span> <span class="pre">&lt;lambda&gt;&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.morphological_geodesic_active_contour" title="Permalink to this definition">&para;</a></dt>
<dd><p>Morphological Geodesic Active Contours (MorphGAC).</p>
<p>Geodesic active contours implemented with morphological operators. It can
be used to segment objects with visible but noisy, cluttered, broken
borders.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>gimage</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Preprocessed image or volume to be segmented. This is very rarely the
original image. Instead, this is usually a preprocessed version of the
original image that enhances and highlights the borders (or other
structures) of the object to segment.
<cite>morphological_geodesic_active_contour</cite> will try to stop the contour
evolution in areas where <cite>gimage</cite> is small. See
<cite>morphsnakes.inverse_gaussian_gradient</cite> as an example function to
perform this preprocessing. Note that the quality of
<cite>morphological_geodesic_active_contour</cite> might greatly depend on this
preprocessing.</p>
</dd>
<dt><strong>iterations</strong><span class="classifier">uint</span></dt><dd><p>Number of iterations to run.</p>
</dd>
<dt><strong>init_level_set</strong><span class="classifier">str, (M, N) array, or (L, M, N) array</span></dt><dd><p>Initial level set. If an array is given, it will be binarized and used
as the initial level set. If a string is given, it defines the method
to generate a reasonable initial level set with the shape of the
<cite>image</cite>. Accepted values are &lsquo;checkerboard&rsquo; and &lsquo;circle&rsquo;. See the
documentation of <cite>checkerboard_level_set</cite> and <cite>circle_level_set</cite>
respectively for details about how these level sets are created.</p>
</dd>
<dt><strong>smoothing</strong><span class="classifier">uint, optional</span></dt><dd><p>Number of times the smoothing operator is applied per iteration.
Reasonable values are around 1-4. Larger values lead to smoother
segmentations.</p>
</dd>
<dt><strong>threshold</strong><span class="classifier">float, optional</span></dt><dd><p>Areas of the image with a value smaller than this threshold will be
considered borders. The evolution of the contour will stop in this
areas.</p>
</dd>
<dt><strong>balloon</strong><span class="classifier">float, optional</span></dt><dd><p>Balloon force to guide the contour in non-informative areas of the
image, i.e., areas where the gradient of the image is too small to push
the contour towards a border. A negative value will shrink the contour,
while a positive value will expand the contour in these areas. Setting
this to zero will disable the balloon force.</p>
</dd>
<dt><strong>iter_callback</strong><span class="classifier">function, optional</span></dt><dd><p>If given, this function is called once per iteration with the current
level set as the only argument. This is useful for debugging or for
plotting intermediate results during the evolution.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">(M, N) or (L, M, N) array</span></dt><dd><p>Final segmentation (i.e., the final level set)</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cucim.skimage.segmentation.inverse_gaussian_gradient" title="cucim.skimage.segmentation.inverse_gaussian_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse_gaussian_gradient</span></code></a>, <a class="reference internal" href="#cucim.skimage.segmentation.circle_level_set" title="cucim.skimage.segmentation.circle_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">circle_level_set</span></code></a>, <a class="reference internal" href="#cucim.skimage.segmentation.checkerboard_level_set" title="cucim.skimage.segmentation.checkerboard_level_set"><code class="xref py py-obj docutils literal notranslate"><span class="pre">checkerboard_level_set</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>This is a version of the Geodesic Active Contours (GAC) algorithm that uses
morphological operators instead of solving partial differential equations
(PDEs) for the evolution of the contour. The set of morphological operators
used in this algorithm are proved to be infinitesimally equivalent to the
GAC PDEs (see <a class="reference internal" href="#ra07eed798308-1" id="id224">[1]</a>). However, morphological operators are do not suffer
from the numerical stability issues typically found in PDEs (e.g., it is
not necessary to find the right time step for the evolution), and are
computationally faster.</p>
<p>The algorithm and its theoretical derivation are described in <a class="reference internal" href="#ra07eed798308-1" id="id225">[1]</a>.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra07eed798308-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id224">1</a>,<a href="#id225">2</a>)</span></dt>
<dd><p>A Morphological Approach to Curvature-based Evolution of Curves and
Surfaces, Pablo M&aacute;rquez-Neila, Luis Baumela, Luis &Aacute;lvarez. In IEEE
Transactions on Pattern Analysis and Machine Intelligence (PAMI),
2014, <a class="reference external" href="https://doi.org/10.1109/TPAMI.2013.106">DOI:10.1109/TPAMI.2013.106</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.random_walker">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">random_walker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">130</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cg_j'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_full_prob</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spacing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prob_tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.random_walker" title="Permalink to this definition">&para;</a></dt>
<dd><p>Random walker algorithm for segmentation from markers.</p>
<p>Random walker algorithm is implemented for gray-level or multichannel
images.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">array_like</span></dt><dd><p>Image to be segmented in phases. Gray-level <cite>data</cite> can be two- or
three-dimensional; multichannel data can be three- or four-
dimensional (multichannel=True) with the highest dimension denoting
channels. Data spacing is assumed isotropic unless the <cite>spacing</cite>
keyword argument is used.</p>
</dd>
<dt><strong>labels</strong><span class="classifier">array of ints, of same shape as <cite>data</cite> without channels dimension</span></dt><dd><p>Array of seed markers labeled with different positive integers
for different phases. Zero-labeled pixels are unlabeled pixels.
Negative labels correspond to inactive pixels that are not taken
into account (they are removed from the graph). If labels are not
consecutive integers, the labels array will be transformed so that
labels are consecutive. In the multichannel case, <cite>labels</cite> should have
the same shape as a single channel of <cite>data</cite>, i.e. without the final
dimension denoting channels.</p>
</dd>
<dt><strong>beta</strong><span class="classifier">float, optional</span></dt><dd><p>Penalization coefficient for the random walker motion
(the greater <cite>beta</cite>, the more difficult the diffusion).</p>
</dd>
<dt><strong>mode</strong><span class="classifier">string, available options {&lsquo;cg&rsquo;, &lsquo;cg_j&rsquo;, &lsquo;cg_mg&rsquo;, &lsquo;bf&rsquo;}</span></dt><dd><p>Mode for solving the linear system in the random walker algorithm.</p>
<ul class="simple">
<li><p>&lsquo;bf&rsquo; (brute force): an LU factorization of the Laplacian is
computed. This is fast for small images (&lt;1024x1024), but very slow
and memory-intensive for large images (e.g., 3-D volumes).</p></li>
<li><p>&lsquo;cg&rsquo; (conjugate gradient): the linear system is solved iteratively
using the Conjugate Gradient method from scipy.sparse.linalg. This is
less memory-consuming than the brute force method for large images,
but it is quite slow.</p></li>
<li><p>&lsquo;cg_j&rsquo; (conjugate gradient with Jacobi preconditionner): the
Jacobi preconditionner is applyed during the Conjugate
gradient method iterations. This may accelerate the
convergence of the &lsquo;cg&rsquo; method.</p></li>
<li><p>&lsquo;cg_mg&rsquo; (conjugate gradient with multigrid preconditioner): a
preconditioner is computed using a multigrid solver, then the
solution is computed with the Conjugate Gradient method. This mode
requires that the pyamg module is installed.</p></li>
</ul>
</dd>
<dt><strong>tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance to achieve when solving the linear system using
the conjugate gradient based modes (&lsquo;cg&rsquo;, &lsquo;cg_j&rsquo; and &lsquo;cg_mg&rsquo;).</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If copy is False, the <cite>labels</cite> array will be overwritten with
the result of the segmentation. Use copy=False if you want to
save on memory.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, input data is parsed as multichannel data (see &lsquo;data&rsquo; above
for proper input format in this case).</p>
</dd>
<dt><strong>return_full_prob</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, the probability that a pixel belongs to each of the
labels will be returned, instead of only the most likely
label.</p>
</dd>
<dt><strong>spacing</strong><span class="classifier">iterable of floats, optional</span></dt><dd><p>Spacing between voxels in each spatial dimension. If <cite>None</cite>, then
the spacing between pixels/voxels in each dimension is assumed 1.</p>
</dd>
<dt><strong>prob_tol</strong><span class="classifier">float, optional</span></dt><dd><p>Tolerance on the resulting probability to be in the interval [0, 1].
If the tolerance is not satisfied, a warning is displayed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">ndarray</span></dt><dd><ul class="simple">
<li><p>If <cite>return_full_prob</cite> is False, array of ints of same shape
and data type as <cite>labels</cite>, in which each pixel has been
labeled according to the marker that reached the pixel first
by anisotropic diffusion.</p></li>
<li><p>If <cite>return_full_prob</cite> is True, array of floats of shape
<cite>(nlabels, labels.shape)</cite>. <cite>output[label_nb, i, j]</cite> is the
probability that label <cite>label_nb</cite> reaches the pixel <cite>(i, j)</cite>
first.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">skimage.morphology.watershed</span></code></dt><dd><p>watershed segmentation A segmentation algorithm based on mathematical morphology and &ldquo;flooding&rdquo; of regions from markers.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Multichannel inputs are scaled with all channel data combined. Ensure all
channels are separately normalized prior to running this algorithm.</p>
<p>The <cite>spacing</cite> argument is specifically for anisotropic datasets, where
data points are spaced differently in one or more spatial dimensions.
Anisotropic data is commonly encountered in medical imaging.</p>
<p>The algorithm was first proposed in <a class="reference internal" href="#rbeca6ade2f68-1" id="id227">[1]</a>.</p>
<p>The algorithm solves the diffusion equation at infinite times for
sources placed on markers of each phase in turn. A pixel is labeled with
the phase that has the greatest probability to diffuse first to the pixel.</p>
<p>The diffusion equation is solved by minimizing x.T L x for each phase,
where L is the Laplacian of the weighted graph of the image, and x is
the probability that a marker of the given phase arrives first at a pixel
by diffusion (x=1 on markers of the phase, x=0 on the other markers, and
the other coefficients are looked for). Each pixel is attributed the label
for which it has a maximal value of x. The Laplacian L of the image
is defined as:</p>
<blockquote>
<div><ul class="simple">
<li><p>L_ii = d_i, the number of neighbors of pixel i (the degree of i)</p></li>
<li><p>L_ij = -w_ij if i and j are adjacent pixels</p></li>
</ul>
</div></blockquote>
<p>The weight w_ij is a decreasing function of the norm of the local gradient.
This ensures that diffusion is easier between pixels of similar values.</p>
<p>When the Laplacian is decomposed into blocks of marked and unmarked
pixels:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="n">M</span> <span class="n">B</span><span class="o">.</span><span class="n">T</span>
    <span class="n">B</span> <span class="n">A</span>
</pre></div>
</div>
<p>with first indices corresponding to marked pixels, and then to unmarked
pixels, minimizing x.T L x for one phase amount to solving:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span> <span class="n">x</span> <span class="o">=</span> <span class="o">-</span> <span class="n">B</span> <span class="n">x_m</span>
</pre></div>
</div>
<p>where x_m = 1 on markers of the given phase, and 0 on other markers.
This linear system is solved in the algorithm using a direct method for
small images, and an iterative method for larger images.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rbeca6ade2f68-1"><span class="brackets"><a class="fn-backref" href="#id227">1</a></span></dt>
<dd><p>Leo Grady, Random walks for image segmentation, IEEE Trans Pattern
Anal Mach Intell. 2006 Nov;28(11):1768-83.
<a class="reference external" href="https://doi.org/10.1109/TPAMI.2006.233">DOI:10.1109/TPAMI.2006.233</a>.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cp</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Marker for first phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>  <span class="c1"># Marker for second phase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_walker</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="go">array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span>
<span class="go">       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.segmentation.relabel_sequential">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.segmentation.</span></span><span class="sig-name descname"><span class="pre">relabel_sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label_field</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.segmentation.relabel_sequential" title="Permalink to this definition">&para;</a></dt>
<dd><p>Relabel arbitrary labels to {<cite>offset</cite>, &hellip; <cite>offset</cite> + number_of_labels}.</p>
<p>This function also returns the forward map (mapping the original labels to
the reduced labels) and the inverse map (mapping the reduced labels back
to the original ones).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label_field</strong><span class="classifier">numpy array of int, arbitrary shape</span></dt><dd><p>An array of labels, which must be non-negative integers.</p>
</dd>
<dt><strong>offset</strong><span class="classifier">int, optional</span></dt><dd><p>The return labels will start at <cite>offset</cite>, which should be
strictly positive.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>relabeled</strong><span class="classifier">numpy array of int, same shape as <cite>label_field</cite></span></dt><dd><p>The input label field with labels mapped to
{offset, &hellip;, number_of_labels + offset - 1}.
The data type will be the same as <cite>label_field</cite>, except when
offset + number_of_labels causes overflow of the current data type.</p>
</dd>
<dt><strong>forward_map</strong><span class="classifier">ArrayMap</span></dt><dd><p>The map from the original label space to the returned label
space. Can be used to re-apply the same mapping. See examples
for usage. The output data type will be the same as <cite>relabeled</cite>.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">ArrayMap</span></dt><dd><p>The map from the new label space to the original space. This
can be used to reconstruct the original label field from the
relabeled one. The output data type will be the same as <cite>label_field</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The label 0 is assumed to denote the background and is never remapped.</p>
<p>The forward map can be extremely big for some inputs, since its
length is given by the maximum of the label field. However, in most
situations, <code class="docutils literal notranslate"><span class="pre">label_field.max()</span></code> is much smaller than
<code class="docutils literal notranslate"><span class="pre">label_field.size</span></code>, and in these cases the forward map is
guaranteed to be smaller than either the input or output images.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.segmentation</span> <span class="kn">import</span> <span class="n">relabel_sequential</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_field</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">42</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">relabel_sequential</span><span class="p">(</span><span class="n">label_field</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span>
<span class="go">array([1, 1, 2, 2, 3, 5, 4])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fw</span><span class="p">)</span>
<span class="go">ArrayMap:</span>
<span class="go">  1 &rarr; 1</span>
<span class="go">  5 &rarr; 2</span>
<span class="go">  8 &rarr; 3</span>
<span class="go">  42 &rarr; 4</span>
<span class="go">  99 &rarr; 5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fw</span><span class="p">)</span>
<span class="go">array([0, 1, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,</span>
<span class="go">       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inv</span><span class="p">)</span>
<span class="go">array([ 0,  1,  5,  8, 42, 99])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">fw</span><span class="p">[</span><span class="n">label_field</span><span class="p">]</span> <span class="o">==</span> <span class="n">relab</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">inv</span><span class="p">[</span><span class="n">relab</span><span class="p">]</span> <span class="o">==</span> <span class="n">label_field</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span><span class="p">,</span> <span class="n">fw</span><span class="p">,</span> <span class="n">inv</span> <span class="o">=</span> <span class="n">relabel_sequential</span><span class="p">(</span><span class="n">label_field</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">relab</span>
<span class="go">array([5, 5, 6, 6, 7, 9, 8])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.transform">
<span id="transform"></span><h3>transform<a class="headerlink" href="#module-cucim.skimage.transform" title="Permalink to this headline">&para;</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">AffineTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">matrix=None</span></em>, <em class="sig-param"><span class="pre">scale=None</span></em>, <em class="sig-param"><span class="pre">rotation=None</span></em>, <em class="sig-param"><span class="pre">shear=None</span></em>, <em class="sig-param"><span class="pre">translation=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Affine transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">a2</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">sx</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">sy</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">rotation</span> <span class="o">+</span> <span class="n">shear</span><span class="p">)</span> <span class="o">+</span> <span class="n">b2</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">sx</span></code> and <code class="docutils literal notranslate"><span class="pre">sy</span></code> are scale factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">a1</span>  <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">b1</span>  <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>In 2D, the transformation parameters can be given as the homogeneous
transformation matrix, above, or as the implicit parameters, scale,
rotation, shear, and translation in x (a2) and y (b2). For 3D and higher,
only the matrix form is allowed.</p>
<p>In narrower transforms, such as the Euclidean (only rotation and
translation) or Similarity (rotation, translation, and a global scale
factor) transforms, it is possible to specify 3D transforms using implicit
parameters also.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array, optional</span></dt><dd><p>Homogeneous transformation matrix. If this matrix is provided, it is an
error to provide any of scale, rotation, shear, or translation.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{s as float or (sx, sy) as array, list or tuple}, optional</span></dt><dd><p>Scale factor(s). If a single value, it will be assigned to both
sx and sy. Only available for 2D.</p>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.17: </span>Added support for supplying a single scalar value.</p>
</div>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians. Only
available for 2D.</p>
</dd>
<dt><strong>shear</strong><span class="classifier">float, optional</span></dt><dd><p>Shear angle in counter-clockwise direction as radians. Only available
for 2D.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(tx, ty) as array, list or tuple, optional</span></dt><dd><p>Translation parameters. Only available for 2D.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform. This is not used if any other
parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>ValueError</dt><dd><p>If both <code class="docutils literal notranslate"><span class="pre">matrix</span></code> and any of the other parameters are provided.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.rotation">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.rotation" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.scale">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.scale" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.shear">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">shear</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.shear" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.AffineTransform.translation">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#cucim.skimage.transform.AffineTransform.translation" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.EssentialMatrixTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EssentialMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">rotation=None</span></em>, <em class="sig-param"><span class="pre">translation=None</span></em>, <em class="sig-param"><span class="pre">matrix=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EssentialMatrixTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Essential matrix transformation.</p>
<p>The essential matrix relates corresponding points between a pair of
calibrated images. The matrix transforms normalized, homogeneous image
points in one image to epipolar lines in the other image.</p>
<p>The essential matrix is only defined for a pair of moving images capturing a
non-planar scene. In the case of pure rotation or planar scenes, the
homography describes the geometric relation between two images
(<cite>ProjectiveTransform</cite>). If the intrinsic calibration of the images is
unknown, the fundamental matrix describes the projective relation between
the two images (<cite>FundamentalMatrixTransform</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>rotation</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Rotation matrix of the relative camera motion.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(3, 1) array, optional</span></dt><dd><p>Translation vector of the relative camera motion. The vector must
have unit length.</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r42dd810e13a3-1"><span class="brackets">1</span></dt>
<dd><p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Essential matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.EssentialMatrixTransform.estimate" title="cucim.skimage.transform.EssentialMatrixTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate essential matrix using 8-point algorithm.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.EssentialMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EssentialMatrixTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate essential matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">EuclideanTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">matrix=None</span></em>, <em class="sig-param"><span class="pre">rotation=None</span></em>, <em class="sig-param"><span class="pre">translation=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Euclidean transformation, also known as a rigid transform.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The Euclidean transformation is a rigid transformation with rotation and
translation parameters. The similarity transformation extends the Euclidean
transformation with a single scaling factor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float or sequence of float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians. If given as
a vector, it is interpreted as Euler rotation angles <a class="reference internal" href="#ra85de9f51a41-1" id="id230">[1]</a>. Only 2D
(single rotation) and 3D (Euler rotations) values are supported. For
higher dimensions, you must provide or estimate the transformation
matrix.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">sequence of float, length D, optional</span></dt><dd><p>Translation parameters for each axis.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The dimensionality of the transform.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ra85de9f51a41-1"><span class="brackets"><a class="fn-backref" href="#id230">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions">https://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions</a></p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.EuclideanTransform.estimate" title="cucim.skimage.transform.EuclideanTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, D) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, D) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform.rotation">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">rotation</span></span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform.rotation" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.EuclideanTransform.translation">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">translation</span></span><a class="headerlink" href="#cucim.skimage.transform.EuclideanTransform.translation" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">FundamentalMatrixTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">matrix=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Fundamental matrix transformation.</p>
<p>The fundamental matrix relates corresponding points between a pair of
uncalibrated images. The matrix transforms homogeneous image points in one
image to epipolar lines in the other image.</p>
<p>The fundamental matrix is only defined for a pair of moving images. In the
case of pure rotation or planar scenes, the homography describes the
geometric relation between two images (<cite>ProjectiveTransform</cite>). If the
intrinsic calibration of the images is known, the essential matrix describes
the metric relation between the two images (<cite>EssentialMatrixTransform</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(3, 3) array, optional</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="ree05424bfe6b-1"><span class="brackets">1</span></dt>
<dd><p>Hartley, Richard, and Andrew Zisserman. Multiple view geometry in
computer vision. Cambridge university press, 2003.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Fundamental matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.FundamentalMatrixTransform.estimate" title="cucim.skimage.transform.FundamentalMatrixTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate fundamental matrix using 8-point algorithm.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.FundamentalMatrixTransform.inverse" title="cucim.skimage.transform.FundamentalMatrixTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.FundamentalMatrixTransform.residuals" title="cucim.skimage.transform.FundamentalMatrixTransform.residuals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">residuals</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Compute the Sampson distance.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate fundamental matrix using 8-point algorithm.</p>
<p>The 8-point algorithm requires at least 8 corresponding point pairs for
a well-conditioned solution, otherwise the over-determined solution is
estimated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform.inverse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 3) array</span></dt><dd><p>Epipolar lines in the source image.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.FundamentalMatrixTransform.residuals">
<span class="sig-name descname"><span class="pre">residuals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.FundamentalMatrixTransform.residuals" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the Sampson distance.</p>
<p>The Sampson distance is the first approximation to the geometric error.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>residuals</strong><span class="classifier">(N, ) array</span></dt><dd><p>Sampson distance.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.PiecewiseAffineTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PiecewiseAffineTransform</span></span><a class="headerlink" href="#cucim.skimage.transform.PiecewiseAffineTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Piecewise affine transformation.</p>
<p>Control points are used to define the mapping. The transform is based on
a Delaunay triangulation of the points to form a mesh. Each triangle is
used to find a local affine transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Affine transformations for each triangle in the mesh.</p>
</dd>
<dt><strong>inverse_affines</strong><span class="classifier">list of AffineTransform objects</span></dt><dd><p>Inverse affine transformations for each triangle in the mesh.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.PiecewiseAffineTransform.estimate" title="cucim.skimage.transform.PiecewiseAffineTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.PiecewiseAffineTransform.inverse" title="cucim.skimage.transform.PiecewiseAffineTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PiecewiseAffineTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PiecewiseAffineTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, D) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, D) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PiecewiseAffineTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PiecewiseAffineTransform.inverse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply inverse transformation.</p>
<p>Coordinates outside of the mesh will be set to <cite>- 1</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.PolynomialTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">PolynomialTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">params=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PolynomialTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>2D polynomial transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array, optional</span></dt><dd><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(2, N) array</span></dt><dd><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.PolynomialTransform.estimate" title="cucim.skimage.transform.PolynomialTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst[,&nbsp;order])</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.PolynomialTransform.inverse" title="cucim.skimage.transform.PolynomialTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PolynomialTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
<span class="n">Y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">a_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">order</span><span class="p">](</span> <span class="nb">sum</span><span class="p">[</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">:</span><span class="n">j</span><span class="p">](</span> <span class="n">b_ji</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="o">**</span><span class="n">i</span> <span class="p">))</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span> <span class="mi">0</span> <span class="o">...</span>             <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="o">...</span>                 <span class="mi">0</span> <span class="mi">1</span> <span class="n">x</span> <span class="n">y</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a00</span> <span class="n">a10</span> <span class="n">a11</span> <span class="n">a20</span> <span class="n">a21</span> <span class="n">a22</span> <span class="o">...</span> <span class="n">ann</span>
       <span class="n">b00</span> <span class="n">b10</span> <span class="n">b11</span> <span class="n">b20</span> <span class="n">b21</span> <span class="n">b22</span> <span class="o">...</span> <span class="n">bnn</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Polynomial order (number of coefficients is order + 1).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.PolynomialTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">ProjectiveTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">matrix=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Projective transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <span class="math notranslate nohighlight">\(\mathbf{x} = [x, y, 1]^T\)</span>, its
target position is calculated by multiplying with the given matrix,
<span class="math notranslate nohighlight">\(H\)</span>, to give <span class="math notranslate nohighlight">\(H \mathbf{x}\)</span>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span><span class="p">]</span>
 <span class="p">[</span><span class="n">c0</span> <span class="n">c1</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>  <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="mi">0</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>            <span class="mi">0</span>         <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="mi">1</span> <span class="mi">0</span> <span class="mi">10</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">20</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">1</span> <span class="p">]]</span><span class="o">.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(D+1, D+1) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>dimensionality</strong><span class="classifier">int, optional</span></dt><dd><p>The number of dimensions of the transform. This is ignored if
<code class="docutils literal notranslate"><span class="pre">matrix</span></code> is not None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(D+1, D+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(coords)</p></td>
<td><p>Apply forward transformation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cucim.skimage.transform.ProjectiveTransform.estimate" title="cucim.skimage.transform.ProjectiveTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.ProjectiveTransform.inverse" title="cucim.skimage.transform.ProjectiveTransform.inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inverse</span></code></a>(coords)</p></td>
<td><p>Apply inverse transformation.</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform.dimensionality">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">dimensionality</span></span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform.dimensionality" title="Permalink to this definition">&para;</a></dt>
<dd><p>The dimensionality of the transformation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c0</span> <span class="n">c1</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">A</span>   <span class="o">=</span> <span class="p">[[</span><span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="o">-</span><span class="n">X</span><span class="p">]</span>
       <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="n">x</span> <span class="n">y</span> <span class="mi">1</span> <span class="o">-</span><span class="n">Y</span><span class="p">]</span>
        <span class="o">...</span>
        <span class="o">...</span>
      <span class="p">]</span>
<span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0</span> <span class="n">a1</span> <span class="n">a2</span> <span class="n">b0</span> <span class="n">b1</span> <span class="n">b2</span> <span class="n">c3</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.ProjectiveTransform.inverse">
<span class="sig-name descname"><span class="pre">inverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply inverse transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, D) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords_out</strong><span class="classifier">(N, D) array</span></dt><dd><p>Source coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="cucim.skimage.transform.SimilarityTransform">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">SimilarityTransform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">matrix=None</span></em>, <em class="sig-param"><span class="pre">scale=None</span></em>, <em class="sig-param"><span class="pre">rotation=None</span></em>, <em class="sig-param"><span class="pre">translation=None</span></em>, <em class="sig-param"><span class="pre">*</span></em>, <em class="sig-param"><span class="pre">dimensionality=2</span></em>, <em class="sig-param"><span class="pre">xp=&lt;module</span> <span class="pre">'cupy'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cupy/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.SimilarityTransform" title="Permalink to this definition">&para;</a></dt>
<dd><p>2D similarity transformation.</p>
<p>Has the following form:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">a1</span>

<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">=</span>
  <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">s</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">s</span></code> is a scale factor and the homogeneous transformation matrix is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[[</span><span class="n">a0</span>  <span class="n">b0</span>  <span class="n">a1</span><span class="p">]</span>
 <span class="p">[</span><span class="n">b0</span>  <span class="n">a0</span>  <span class="n">b1</span><span class="p">]</span>
 <span class="p">[</span><span class="mi">0</span>   <span class="mi">0</span>    <span class="mi">1</span><span class="p">]]</span>
</pre></div>
</div>
<p>The similarity transformation extends the Euclidean transformation with a
single scaling factor in addition to the rotation and translation
parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>matrix</strong><span class="classifier">(dim+1, dim+1) array, optional</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">float, optional</span></dt><dd><p>Scale factor. Implemented only for 2D and 3D.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Rotation angle in counter-clockwise direction as radians.
Implemented only for 2D and 3D. For 3D, this is given in XZX Euler
angles.</p>
</dd>
<dt><strong>translation</strong><span class="classifier">(dim,) array-like, optional</span></dt><dd><p>x, y[, z] translation parameters. Implemented only for 2D and 3D.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>params</strong><span class="classifier">(dim+1, dim+1) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cucim.skimage.transform.SimilarityTransform.estimate" title="cucim.skimage.transform.SimilarityTransform.estimate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate</span></code></a>(src,&nbsp;dst)</p></td>
<td><p>Estimate the transformation from a set of corresponding points.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cucim.skimage.transform.SimilarityTransform.estimate">
<span class="sig-name descname"><span class="pre">estimate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate the transformation from a set of corresponding points.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>src</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Source coordinates.</p>
</dd>
<dt><strong>dst</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Destination coordinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>success</strong><span class="classifier">bool</span></dt><dd><p>True, if model estimation succeeds.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="cucim.skimage.transform.SimilarityTransform.scale">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">scale</span></span><a class="headerlink" href="#cucim.skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.downscale_local_mean">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">downscale_local_mean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">factors</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.downscale_local_mean" title="Permalink to this definition">&para;</a></dt>
<dd><p>Down-sample N-dimensional image by local averaging.</p>
<p>The image is padded with <cite>cval</cite> if it is not perfectly divisible by the
integer factors.</p>
<p>In contrast to interpolation in <cite>skimage.transform.resize</cite> and
<cite>skimage.transform.rescale</cite> this function calculates the local mean of
elements in each block of size <cite>factors</cite> in the input image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>N-dimensional input image.</p>
</dd>
<dt><strong>factors</strong><span class="classifier">array_like</span></dt><dd><p>Array containing down-sampling integer factor along each axis.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Constant padding value if image is not perfectly divisible by the
integer factors.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Unused, but kept here for API consistency with the other transforms
in this module. (The local mean will never fall outside the range
of values in the input image, assuming the provided <cite>cval</cite> also
falls within that range.)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Down-sampled image with same number of dimensions as input image.
For integer inputs, the output dtype will be <code class="docutils literal notranslate"><span class="pre">float64</span></code>.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.mean()</span></code> for details.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 0,  1,  2,  3,  4],</span>
<span class="go">       [ 5,  6,  7,  8,  9],</span>
<span class="go">       [10, 11, 12, 13, 14]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">downscale_local_mean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">array([[3.5, 4. ],</span>
<span class="go">       [5.5, 4.5]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.estimate_transform">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">estimate_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ttype</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.estimate_transform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ttype</strong><span class="classifier">{&lsquo;euclidean&rsquo;, similarity&rsquo;, &lsquo;affine&rsquo;, &lsquo;piecewise-affine&rsquo;,              &lsquo;projective&rsquo;, &lsquo;polynomial&rsquo;}</span></dt><dd><p>Type of transform.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">array or int</span></dt><dd><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>NAME / TTYPE        FUNCTION PARAMETERS
'euclidean'         `src, `dst`
'similarity'        `src, `dst`
'affine'            `src, `dst`
'piecewise-affine'  `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order,
                                          default order is 2)
</pre></div>
</div>
<p>Also see examples below.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>tform</strong><span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometricTransform</span></code></span></dt><dd><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage</span> <span class="kn">import</span> <span class="n">transform</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s1">'similarity'</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)),</span> <span class="n">src</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transform</span><span class="o">.</span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span> 
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">),</span> <span class="n">tform2</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">)))</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.integral_image">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integral_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.integral_image" title="Permalink to this definition">&para;</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math notranslate nohighlight">
\[S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image/summed area table of same shape as input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rf29e65fd98a8-1"><span class="brackets">1</span></dt>
<dd><p>F.C. Crow, &ldquo;Summed-area tables for texture mapping,&rdquo;
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.integrate">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">integrate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ii</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.integrate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>ii</strong><span class="classifier">ndarray</span></dt><dd><p>Integral image.</p>
</dd>
<dt><strong>start</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <cite>ii</cite></span></dt><dd><p>Coordinates of top left corner of window(s).
Each tuple in the list contains the starting row, col, &hellip; index
i.e <cite>[(row_win1, col_win1, &hellip;), (row_win2, col_win2,&hellip;), &hellip;]</cite>.</p>
</dd>
<dt><strong>end</strong><span class="classifier">List of tuples, each tuple of length equal to dimension of <cite>ii</cite></span></dt><dd><p>Coordinates of bottom right corner of window(s).
Each tuple in the list containing the end row, col, &hellip; index i.e
<cite>[(row_win1, col_win1, &hellip;), (row_win2, col_win2, &hellip;), &hellip;]</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>S</strong><span class="classifier">scalar or ndarray</span></dt><dd><p>Integral (sum) over the given window(s).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ii</span> <span class="o">=</span> <span class="n">integral_image</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># sum from (1, 0) to (1, 2)</span>
<span class="go">array([3.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>  <span class="c1"># sum from (3, 3) to (4, 5)</span>
<span class="go">array([6.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># sum from (1, 0) to (1, 2) and from (3, 3) to (4, 5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">integrate</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)],</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)])</span>
<span class="go">array([3., 6.])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.matrix_transform">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">matrix_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.matrix_transform" title="Permalink to this definition">&para;</a></dt>
<dd><p>Apply 2D matrix transform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>x, y coordinates to transform</p>
</dd>
<dt><strong>matrix</strong><span class="classifier">(3, 3) array</span></dt><dd><p>Homogeneous transformation matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>coords</strong><span class="classifier">(N, 2) array</span></dt><dd><p>Transformed coordinates.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_expand">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_expand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_expand" title="Permalink to this definition">&para;</a></dt>
<dd><p>Upsample and then smooth image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>upscale</strong><span class="classifier">float, optional</span></dt><dd><p>Upscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * upscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of upsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Upsampled and smoothed float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r50c57162be63-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_gaussian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_gaussian" title="Permalink to this definition">&para;</a></dt>
<dd><p>Yield images of the Gaussian pyramid formed by the input image.</p>
<p>Recursively applies the <cite>pyramid_reduce</cite> function to the image, and yields
the downscaled images.</p>
<p>Note that the first image of the pyramid will be the original, unscaled
image. The total number of images is <cite>max_layer + 1</cite>. In case all layers
are computed, the last image is either a one-pixel image or the image where
the reduction does not change its shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r937127d69afe-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_laplacian">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_laplacian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_layer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_laplacian" title="Permalink to this definition">&para;</a></dt>
<dd><p>Yield images of the laplacian pyramid formed by the input image.</p>
<p>Each layer contains the difference between the downsampled and the
downsampled, smoothed image:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">layer</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">)</span> <span class="o">-</span> <span class="n">smooth</span><span class="p">(</span><span class="n">resize</span><span class="p">(</span><span class="n">prev_layer</span><span class="p">))</span>
</pre></div>
</div>
<p>Note that the first image of the pyramid will be the difference between the
original, unscaled image and its smoothed version. The total number of
images is <cite>max_layer + 1</cite>. In case all layers are computed, the last image
is either a one-pixel image or the image where the reduction does not
change its shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>max_layer</strong><span class="classifier">int, optional</span></dt><dd><p>Number of layers for the pyramid. 0th layer is the original image.
Default is -1 which builds all possible layers.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pyramid</strong><span class="classifier">generator</span></dt><dd><p>Generator yielding pyramid layers as float images.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r0b6b3170da35-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
<dt class="label" id="r0b6b3170da35-2"><span class="brackets">2</span></dt>
<dd><p><a class="reference external" href="http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html">http://sepwww.stanford.edu/data/media/public/sep/morgan/texturematch/paper_html/node3.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.pyramid_reduce">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">pyramid_reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">downscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.pyramid_reduce" title="Permalink to this definition">&para;</a></dt>
<dd><p>Smooth and then downsample image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>downscale</strong><span class="classifier">float, optional</span></dt><dd><p>Downscale factor.</p>
</dd>
<dt><strong>sigma</strong><span class="classifier">float, optional</span></dt><dd><p>Sigma for Gaussian filter. Default is <cite>2 * downscale / 6.0</cite> which
corresponds to a filter mask twice the size of the scale factor that
covers more than 99% of the Gaussian distribution.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>Order of splines used in interpolation of downsampling. See
<cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;reflect&rsquo;, &lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>The mode parameter determines how the array borders are handled, where
cval is the value when mode is equal to &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Value to fill past edges of input if mode is &lsquo;constant&rsquo;.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">array</span></dt><dd><p>Smoothed and downsampled float image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rb5aed66567c5-1"><span class="brackets">1</span></dt>
<dd><p><a class="reference external" href="http://persci.mit.edu/pub_pdfs/pyramid83.pdf">http://persci.mit.edu/pub_pdfs/pyramid83.pdf</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.rescale">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rescale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.rescale" title="Permalink to this definition">&para;</a></dt>
<dd><p>Scale image by a certain factor.</p>
<p>Performs interpolation to up-scale or down-scale N-dimensional images.
Note that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<cite>skimage.transform.downscale_local_mean</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>scale</strong><span class="classifier">{float, tuple of floats}</span></dt><dd><p>Scale factors. Separate scale factors can be defined as
<cite>(rows, cols[, &hellip;][, dim])</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>scaled</strong><span class="classifier">ndarray</span></dt><dd><p>Scaled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the last axis of the image is to be interpreted as multiple
channels or another spatial dimension.</p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes &lsquo;reflect&rsquo; and &lsquo;symmetric&rsquo; are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">rescale</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(51, 51)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rescale</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(256, 256)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.resize">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">resize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">anti_aliasing_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.resize" title="Permalink to this definition">&para;</a></dt>
<dd><p>Resize image to match a certain size.</p>
<p>Performs interpolation to up-size or down-size N-dimensional images. Note
that anti-aliasing should be enabled when down-sizing images to avoid
aliasing artifacts. For down-sampling with an integer factor also see
<cite>skimage.transform.downscale_local_mean</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple or ndarray</span></dt><dd><p>Size of the generated output image <cite>(rows, cols[, &hellip;][, dim])</cite>. If
<cite>dim</cite> is not provided, the number of channels is preserved. In case the
number of input channels does not equal the number of output channels a
n-dimensional interpolation is applied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>resized</strong><span class="classifier">ndarray</span></dt><dd><p>Resized version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see <a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
<dt><strong>anti_aliasing</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to apply a Gaussian filter to smooth the image prior
to down-scaling. It is crucial to filter when down-sampling
the image to avoid aliasing artifacts. If input image data
type is bool, no anti-aliasing is applied.</p>
</dd>
<dt><strong>anti_aliasing_sigma</strong><span class="classifier">{float, tuple of floats}, optional</span></dt><dd><p>Standard deviation for Gaussian filtering to avoid aliasing artifacts.
By default, this value is chosen as (s - 1) / 2 where s is the
down-scaling factor, where s &gt; 1. For the up-size case, s &lt; 1, no
anti-aliasing is performed prior to rescaling.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes &lsquo;reflect&rsquo; and &lsquo;symmetric&rsquo; are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">resize</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.rotate">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.rotate" title="Permalink to this definition">&para;</a></dt>
<dd><p>Rotate image by a certain angle around its center.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>angle</strong><span class="classifier">float</span></dt><dd><p>Rotation angle in degrees in counter-clockwise direction.</p>
</dd>
<dt><strong>resize</strong><span class="classifier">bool, optional</span></dt><dd><p>Determine whether the shape of the output image will be automatically
calculated, so the complete rotated image exactly fits. Default is
False.</p>
</dd>
<dt><strong>center</strong><span class="classifier">iterable of length 2</span></dt><dd><p>The rotation center. If <code class="docutils literal notranslate"><span class="pre">center=None</span></code>, the image is rotated around
its center, i.e. <code class="docutils literal notranslate"><span class="pre">center=(cols</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5,</span> <span class="pre">rows</span> <span class="pre">/</span> <span class="pre">2</span> <span class="pre">-</span> <span class="pre">0.5)</span></code>.  Please
note that this parameter is (cols, rows), contrary to normal skimage
ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>rotated</strong><span class="classifier">ndarray</span></dt><dd><p>Rotated version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Modes &lsquo;reflect&rsquo; and &lsquo;symmetric&rsquo; are similar, but differ in whether the edge
pixels are duplicated during the reflection.  As an example, if an array
has values [0, 1, 2] and was padded to the right by four values using
symmetric, the result would be [0, 1, 2, 2, 1, 0, 0], while for reflect it
would be [0, 1, 2, 1, 0, 1, 2].</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">rotate</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(530, 530)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rotate</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="mi">90</span><span class="p">,</span> <span class="n">resize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(512, 512)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.swirl">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">swirl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'reflect'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.swirl" title="Permalink to this definition">&para;</a></dt>
<dd><p>Perform a swirl transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>center</strong><span class="classifier">(column, row) tuple or (2,) ndarray, optional</span></dt><dd><p>Center coordinate of transformation.</p>
</dd>
<dt><strong>strength</strong><span class="classifier">float, optional</span></dt><dd><p>The amount of swirling applied.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <cite>radius</cite>.</p>
</dd>
<dt><strong>rotation</strong><span class="classifier">float, optional</span></dt><dd><p>Additional rotation applied to the image.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>swirled</strong><span class="classifier">ndarray</span></dt><dd><p>Swirled version of the input.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Other Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><p>The order of the spline interpolation, default is 0 if
image.dtype is bool and 1 otherwise. The order has to be in
the range 0-5. See <cite>skimage.transform.warp</cite> for detail.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode, with &lsquo;constant&rsquo; used as the default. Modes match
the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.warp">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_map</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'constant'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_range</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.warp" title="Permalink to this definition">&para;</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>inverse_map</strong><span class="classifier">transformation object, callable <code class="docutils literal notranslate"><span class="pre">cr</span> <span class="pre">=</span> <span class="pre">f(cr,</span> <span class="pre">**kwargs)</span></code>, or ndarray</span></dt><dd><p>Inverse coordinate map, which transforms coordinates in the output
images into their corresponding coordinates in the input image.</p>
<p>There are a number of different options to define this map, depending
on the dimensionality of the input image. A 2-D image can have 2
dimensions for gray-scale images, or 3 dimensions with color
information.</p>
<blockquote>
<div><ul class="simple">
<li><p>For 2-D images, you can directly pass a transformation object,
e.g. <cite>skimage.transform.SimilarityTransform</cite>, or its inverse.</p></li>
<li><p>For 2-D images, you can pass a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> homogeneous
transformation matrix, e.g.
<cite>skimage.transform.SimilarityTransform.params</cite>.</p></li>
<li><p>For 2-D images, a function that transforms a <code class="docutils literal notranslate"><span class="pre">(M,</span> <span class="pre">2)</span></code> array of
<code class="docutils literal notranslate"><span class="pre">(col,</span> <span class="pre">row)</span></code> coordinates in the output image to their
corresponding coordinates in the input image. Extra parameters to
the function can be specified through <cite>map_args</cite>.</p></li>
<li><p>For N-D images, you can directly pass an array of coordinates.
The first dimension specifies the coordinates in the input image,
while the subsequent dimensions determine the position in the
output image. E.g. in case of 2-D images, you need to pass an array
of shape <code class="docutils literal notranslate"><span class="pre">(2,</span> <span class="pre">rows,</span> <span class="pre">cols)</span></code>, where <cite>rows</cite> and <cite>cols</cite> determine the
shape of the output image, and the first dimension contains the
<code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> coordinate in the input image.
See <cite>scipy.ndimage.map_coordinates</cite> for further documentation.</p></li>
</ul>
</div></blockquote>
<p>Note, that a <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">3)</span></code> matrix is interpreted as a homogeneous
transformation matrix, so you cannot interpolate values from a 3-D
input, if the output is of shape <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>.</p>
<p>See example section for usage.</p>
</dd>
<dt><strong>map_args</strong><span class="classifier">dict, optional</span></dt><dd><p>Keyword arguments passed to <cite>inverse_map</cite>.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (rows, cols), optional</span></dt><dd><p>Shape of the output image generated. By default the shape of the input
image is preserved.  Note that, even for multi-band images, only rows
and columns need to be specified.</p>
</dd>
<dt><strong>order</strong><span class="classifier">int, optional</span></dt><dd><dl>
<dt>The order of interpolation. The order has to be in the range 0-5:</dt><dd><ul class="simple">
<li><p>0: Nearest-neighbor</p></li>
<li><p>1: Bi-linear (default)</p></li>
<li><p>2: Bi-quadratic</p></li>
<li><p>3: Bi-cubic</p></li>
<li><p>4: Bi-quartic</p></li>
<li><p>5: Bi-quintic</p></li>
</ul>
<p>Default is 0 if image.dtype is bool and 1 otherwise.</p>
</dd>
</dl>
</dd>
<dt><strong>mode</strong><span class="classifier">{&lsquo;constant&rsquo;, &lsquo;edge&rsquo;, &lsquo;symmetric&rsquo;, &lsquo;reflect&rsquo;, &lsquo;wrap&rsquo;}, optional</span></dt><dd><p>Points outside the boundaries of the input are filled according
to the given mode.  Modes match the behaviour of <cite>numpy.pad</cite>.</p>
</dd>
<dt><strong>cval</strong><span class="classifier">float, optional</span></dt><dd><p>Used in conjunction with mode &lsquo;constant&rsquo;, the value outside
the image boundaries.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to clip the output to the range of values of the input image.
This is enabled by default, since higher order interpolation may
produce values outside the given input range.</p>
</dd>
<dt><strong>preserve_range</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to keep the original range of values. Otherwise, the input
image is converted according to the conventions of <cite>img_as_float</cite>.
Also see
<a class="reference external" href="https://scikit-image.org/docs/dev/user_guide/data_types.html">https://scikit-image.org/docs/dev/user_guide/data_types.html</a></p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">double ndarray</span></dt><dd><p>The warped input image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The input image is converted to a <cite>double</cite> image.</p></li>
<li><p>In case of a <cite>SimilarityTransform</cite>, <cite>AffineTransform</cite> and
<cite>ProjectiveTransform</cite> and <cite>order</cite> in [0, 3] this function uses the
underlying transformation matrix to warp the image with a much faster
routine.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">())</span>
</pre></div>
</div>
<p>The following image warps are all equal but differ substantially in
execution time. The image is shifted to the bottom.</p>
<p>Use a geometric transform to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a callable (slow):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_down</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_down</span><span class="p">)</span>
</pre></div>
</div>
<p>Use a transformation matrix to warp an image (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">matrix</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">matrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">ProjectiveTransform</span><span class="p">,</span> <span class="n">warp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">ProjectiveTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">matrix</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also use the inverse of a geometric transformation (fast):</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<p>For N-D images you can pass a coordinate array, that specifies the
coordinates in the input image for every element in the output image. E.g.
if you want to rescale a 3-D cube, you can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cube_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cube</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="o">*</span><span class="n">cube_shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Setup the coordinate array, that defines the scaling:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">output_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">scale</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">cube_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">:</span><span class="n">output_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">coords0</span><span class="p">,</span> <span class="n">coords1</span><span class="p">,</span> <span class="n">coords2</span><span class="p">])</span>
</pre></div>
</div>
<p>Assume that the cube contains spatial data, where the first array element
center is at coordinate (0.5, 0.5, 0.5) in real space, i.e. we have to
account for this extra offset when scaling the image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">coords</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">/</span> <span class="n">scale</span> <span class="o">-</span> <span class="mf">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp</span><span class="p">(</span><span class="n">cube</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.warp_coords">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_coords</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">coord_map</span></em>, <em class="sig-param"><span class="pre">shape</span></em>, <em class="sig-param"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.warp_coords" title="Permalink to this definition">&para;</a></dt>
<dd><p>Build the source coordinates for the output of a 2-D image warp.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>coord_map</strong><span class="classifier">callable like GeometricTransform.inverse</span></dt><dd><p>Return input coordinates for given output coordinates.
Coordinates are in the shape (P, 2), where P is the number
of coordinates and each element is a <code class="docutils literal notranslate"><span class="pre">(row,</span> <span class="pre">col)</span></code> pair.</p>
</dd>
<dt><strong>shape</strong><span class="classifier">tuple</span></dt><dd><p>Shape of output image <code class="docutils literal notranslate"><span class="pre">(rows,</span> <span class="pre">cols[,</span> <span class="pre">bands])</span></code>.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">np.dtype or string</span></dt><dd><p>dtype for return value (sane choices: float32 or float64).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>coords</strong><span class="classifier">(ndim, rows, cols[, bands]) array of dtype <cite>dtype</cite></span></dt><dd><p>Coordinates for <cite>scipy.ndimage.map_coordinates</cite>, that will yield
an image of shape (orows, ocols, bands) by drawing from source
points according to the <cite>coord_transform_fn</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This is a lower-level routine that produces the source coordinates for 2-D
images used by <cite>warp()</cite>.</p>
<p>It is provided separately from <cite>warp</cite> to give additional flexibility to
users who would like, for example, to re-use a particular coordinate
mapping, to use specific dtypes at various points along the the
image-warping process, or to implement different post-processing logic
than <cite>warp</cite> performs after the call to <cite>ndi.map_coordinates</cite>.</p>
<p class="rubric">Examples</p>
<p>Produce a coordinate map that shifts an image up and to the right:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">warp_coords</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cupyx.scipy.ndimage</span> <span class="kn">import</span> <span class="n">map_coordinates</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_up10_left20</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span> <span class="o">-</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">])[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">float32</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">coords</span> <span class="o">=</span> <span class="n">warp_coords</span><span class="p">(</span><span class="n">shift_up10_left20</span><span class="p">,</span> <span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped_image</span> <span class="o">=</span> <span class="n">map_coordinates</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">coords</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.transform.warp_polar">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.transform.</span></span><span class="sig-name descname"><span class="pre">warp_polar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'linear'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multichannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.transform.warp_polar" title="Permalink to this definition">&para;</a></dt>
<dd><p>Remap image to polar or log-polar coordinates space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image. Only 2-D arrays are accepted by default. If
<cite>multichannel=True</cite>, 3-D arrays are accepted and the last axis is
interpreted as multiple channels.</p>
</dd>
<dt><strong>center</strong><span class="classifier">tuple (row, col), optional</span></dt><dd><p>Point in image that represents the center of the transformation (i.e.,
the origin in cartesian space). Values can be of type <cite>float</cite>.
If no value is given, the center is assumed to be the center point
of the image.</p>
</dd>
<dt><strong>radius</strong><span class="classifier">float, optional</span></dt><dd><p>Radius of the circle that bounds the area to be transformed.</p>
</dd>
<dt><strong>output_shape</strong><span class="classifier">tuple (row, col), optional</span></dt><dd></dd>
<dt><strong>scaling</strong><span class="classifier">{&lsquo;linear&rsquo;, &lsquo;log&rsquo;}, optional</span></dt><dd><p>Specify whether the image warp is polar or log-polar. Defaults to
&lsquo;linear&rsquo;.</p>
</dd>
<dt><strong>multichannel</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether the image is a 3-D array in which the third axis is to be
interpreted as multiple channels. If set to <cite>False</cite> (default), only 2-D
arrays are accepted.</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">keyword arguments</span></dt><dd><p>Passed to <cite>transform.warp</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>warped</strong><span class="classifier">ndarray</span></dt><dd><p>The polar or log-polar warped image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Perform a basic polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.transform</span> <span class="kn">import</span> <span class="n">warp_polar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">checkerboard</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">'log'</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a grayscale image while specifying center,
radius, and output shape:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="n">output_shape</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">'log'</span><span class="p">)</span>
</pre></div>
</div>
<p>Perform a log-polar warp on a color image:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warped</span> <span class="o">=</span> <span class="n">warp_polar</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">'log'</span><span class="p">,</span> <span class="n">multichannel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cucim.skimage.util">
<span id="util"></span><h3>util<a class="headerlink" href="#module-cucim.skimage.util" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.crop">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">crop</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crop_width</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'K'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.crop" title="Permalink to this definition">&para;</a></dt>
<dd><p>Crop array <cite>ar</cite> by <cite>crop_width</cite> along each dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ar</strong><span class="classifier">array-like of rank N</span></dt><dd><p>Input array.</p>
</dd>
<dt><strong>crop_width</strong><span class="classifier">{sequence, int}</span></dt><dd><p>Number of values to remove from the edges of each axis.
<code class="docutils literal notranslate"><span class="pre">((before_1,</span> <span class="pre">after_1),</span></code> &hellip; <code class="docutils literal notranslate"><span class="pre">(before_N,</span> <span class="pre">after_N))</span></code> specifies
unique crop widths at the start and end of each axis.
<code class="docutils literal notranslate"><span class="pre">((before,</span> <span class="pre">after),)</span> <span class="pre">or</span> <span class="pre">(before,</span> <span class="pre">after)</span></code> specifies
a fixed start and end crop for every axis.
<code class="docutils literal notranslate"><span class="pre">(n,)</span></code> or <code class="docutils literal notranslate"><span class="pre">n</span></code> for integer <code class="docutils literal notranslate"><span class="pre">n</span></code> is a shortcut for
before = after = <code class="docutils literal notranslate"><span class="pre">n</span></code> for all axes.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, optional</span></dt><dd><p>If <cite>True</cite>, ensure the returned array is a contiguous copy. Normally,
a crop operation will return a discontiguous view of the underlying
input array.</p>
</dd>
<dt><strong>order</strong><span class="classifier">{&lsquo;C&rsquo;, &lsquo;F&rsquo;, &lsquo;A&rsquo;, &lsquo;K&rsquo;}, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">copy==True</span></code>, control the memory layout of the copy. See
<code class="docutils literal notranslate"><span class="pre">np.copy</span></code>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cropped</strong><span class="classifier">array</span></dt><dd><p>The cropped array. If <code class="docutils literal notranslate"><span class="pre">copy=False</span></code> (default), this is a sliced
view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.dtype_limits">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">dtype_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip_negative</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.dtype_limits" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return intensity limits, i.e. (min, max) tuple, of the image&rsquo;s dtype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>clip_negative</strong><span class="classifier">bool, optional</span></dt><dd><p>If True, clip the negative range (i.e. return 0 for min intensity)
even if the image dtype allows negative values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>imin, imax</strong><span class="classifier">tuple</span></dt><dd><p>Lower and upper intensity limits.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_bool">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_bool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_bool" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to boolean format.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">ndarray of bool (<cite>bool_</cite>)</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The upper half of the input dtype&rsquo;s positive range is True, and the lower
half is False. All negative values (if present) are False.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_float">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_float</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_float" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to floating point format.</p>
<p>This function is similar to <cite>img_as_float64</cite>, but will not convert
lower-precision floating point arrays to <cite>float64</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of float</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.
If the input image has a float type, intensity values are not modified
and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_float32">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_float32</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_float32" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to single-precision (32-bit) floating point format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of float32</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.
If the input image has a float type, intensity values are not modified
and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_float64">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_float64</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_float64" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to double-precision (64-bit) floating point format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of float64</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively.
If the input image has a float type, intensity values are not modified
and can be outside the ranges [0.0, 1.0] or [-1.0, 1.0].</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_int">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_int" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to 16-bit signed integer format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of int16</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The values are scaled between -32768 and 32767.
If the input data-type is positive-only (e.g., uint8), then
the output image will still only have positive values.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_ubyte">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_ubyte</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_ubyte" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to 8-bit unsigned integer format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of ubyte (uint8)</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Negative input values will be clipped.
Positive values are scaled between 0 and 255.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.img_as_uint">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">img_as_uint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">force_copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.img_as_uint" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert an image to 16-bit unsigned integer format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>force_copy</strong><span class="classifier">bool, optional</span></dt><dd><p>Force a copy of the data, irrespective of its current dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray of uint16</span></dt><dd><p>Output image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Negative input values will be clipped.
Positive values are scaled between 0 and 65535.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.invert">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">invert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">signed_float</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.invert" title="Permalink to this definition">&para;</a></dt>
<dd><p>Invert an image.</p>
<p>Invert the intensity range of the input image, so that the dtype maximum
is now the dtype minimum, and vice-versa. This operation is
slightly different depending on the input dtype:</p>
<ul class="simple">
<li><p>unsigned integers: subtract the image from the dtype maximum</p></li>
<li><p>signed integers: subtract the image from -1 (see Notes)</p></li>
<li><p>floats: subtract the image from 1 (if signed_float is False, so we
assume the image is unsigned), or from 0 (if signed_float is True).</p></li>
</ul>
<p>See the examples for clarification.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image.</p>
</dd>
<dt><strong>signed_float</strong><span class="classifier">bool, optional</span></dt><dd><p>If True and the image is of type float, the range is assumed to
be [-1, 1]. If False and the image is of type float, the range is
assumed to be [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>inverted</strong><span class="classifier">ndarray</span></dt><dd><p>Inverted image.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Ideally, for signed integers we would simply multiply by -1. However,
signed integer ranges are asymmetric. For example, for np.int8, the range
of possible values is [-128, 127], so that -128 * -1 equals -128! By
subtracting from -1, we correctly map the maximum dtype value to the
minimum.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">100</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">200</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span>   <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>                    <span class="p">[</span> <span class="mi">30</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="go">array([[155, 255,  55],</span>
<span class="go">       [255, 205, 255],</span>
<span class="go">       [225, 255,   0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img2</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">128</span><span class="p">],</span>
<span class="gp">... </span>                     <span class="p">[</span><span class="mi">127</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>    <span class="mi">5</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img2</span><span class="p">)</span>
<span class="go">array([[   1,   -1,  127],</span>
<span class="go">       [-128,   -1,   -6]], dtype=int8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img3</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img3</span><span class="p">)</span>
<span class="go">array([[1.  , 0.  , 0.5 , 0.25]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img4</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.25</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">invert</span><span class="p">(</span><span class="n">img4</span><span class="p">,</span> <span class="n">signed_float</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[-0.  , -1.  ,  1.  ,  0.25]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.map_array">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">map_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_vals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.map_array" title="Permalink to this definition">&para;</a></dt>
<dd><p>Map values from input array from input_vals to output_vals.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_arr</strong><span class="classifier">array of int, shape (M[, N][, P][, &hellip;])</span></dt><dd><p>The input label image.</p>
</dd>
<dt><strong>input_vals</strong><span class="classifier">array of int, shape (N,)</span></dt><dd><p>The values to map from.</p>
</dd>
<dt><strong>output_vals</strong><span class="classifier">array, shape (N,)</span></dt><dd><p>The values to map to.</p>
</dd>
<dt><strong>out: array, same shape as `input_arr`</strong></dt><dd><p>The output array. Will be created if not provided. It should
have the same dtype as <cite>output_vals</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>out</strong><span class="classifier">array, same shape as <cite>input_arr</cite></span></dt><dd><p>The array of mapped values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.random_noise">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">random_noise</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'gaussian'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clip</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.random_noise" title="Permalink to this definition">&para;</a></dt>
<dd><p>Function to add random noise of various types to a floating-point image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>image</strong><span class="classifier">ndarray</span></dt><dd><p>Input image data. Will be converted to float.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">str, optional</span></dt><dd><p>One of the following strings, selecting the type of noise to add:</p>
<ul class="simple">
<li><p>&lsquo;gaussian&rsquo;  Gaussian-distributed additive noise.</p></li>
<li><dl class="simple">
<dt>&lsquo;localvar&rsquo;  Gaussian-distributed additive noise, with specified</dt><dd><p>local variance at each point of <cite>image</cite>.</p>
</dd>
</dl>
</li>
<li><p>&lsquo;poisson&rsquo;   Poisson-distributed noise generated from the data.</p></li>
<li><p>&lsquo;salt&rsquo;      Replaces random pixels with 1.</p></li>
<li><dl class="simple">
<dt>&lsquo;pepper&rsquo;    Replaces random pixels with 0 (for unsigned images) or</dt><dd><p>-1 (for signed images).</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>&lsquo;s&amp;p&rsquo;       Replaces random pixels with either 1 or <cite>low_val</cite>, where</dt><dd><p><cite>low_val</cite> is 0 for unsigned images or -1 for signed
images.</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>&lsquo;speckle&rsquo;   Multiplicative noise using out = image + n*image, where</dt><dd><p>n is Gaussian noise with specified mean &amp; variance.</p>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>seed</strong><span class="classifier">int, optional</span></dt><dd><p>If provided, this will set the random seed before generating noise,
for valid pseudo-random comparisons.</p>
</dd>
<dt><strong>clip</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), the output will be clipped after noise applied
for modes <cite>&lsquo;speckle&rsquo;</cite>, <cite>&lsquo;poisson&rsquo;</cite>, and <cite>&lsquo;gaussian&rsquo;</cite>. This is
needed to maintain the proper image data range. If False, clipping
is not applied, and the output may extend beyond the range [-1, 1].</p>
</dd>
<dt><strong>mean</strong><span class="classifier">float, optional</span></dt><dd><p>Mean of random distribution. Used in &lsquo;gaussian&rsquo; and &lsquo;speckle&rsquo;.
Default : 0.</p>
</dd>
<dt><strong>var</strong><span class="classifier">float, optional</span></dt><dd><p>Variance of random distribution. Used in &lsquo;gaussian&rsquo; and &lsquo;speckle&rsquo;.
Note: variance = (standard deviation) ** 2. Default : 0.01</p>
</dd>
<dt><strong>local_vars</strong><span class="classifier">ndarray, optional</span></dt><dd><p>Array of positive floats, same shape as <cite>image</cite>, defining the local
variance at every image point. Used in &lsquo;localvar&rsquo;.</p>
</dd>
<dt><strong>amount</strong><span class="classifier">float, optional</span></dt><dd><p>Proportion of image pixels to replace with noise on range [0, 1].
Used in &lsquo;salt&rsquo;, &lsquo;pepper&rsquo;, and &lsquo;salt &amp; pepper&rsquo;. Default : 0.05</p>
</dd>
<dt><strong>salt_vs_pepper</strong><span class="classifier">float, optional</span></dt><dd><p>Proportion of salt vs. pepper noise for &lsquo;s&amp;p&rsquo; on range [0, 1].
Higher values represent more salt. Default : 0.5 (equal amounts)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">ndarray</span></dt><dd><p>Output floating-point image data on range [0, 1] or [-1, 1] if the
input <cite>image</cite> was unsigned or signed, respectively.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Speckle, Poisson, Localvar, and Gaussian noise may generate noise outside
the valid image range. The default is to clip (not alias) these values,
but they may be preserved by setting <cite>clip=False</cite>. Note that in this case
the output may contain values outside the ranges [0, 1] or [-1, 1].
Use this option with care.</p>
<p>Because of the prevalence of exclusively positive floating-point images in
intermediate calculations, it is not possible to intuit if an input is
signed based on dtype alone. Instead, negative values are explicitly
searched for. Only if found does this function assume signed input.
Unexpected results only occur in rare, poorly exposes cases (e.g. if all
values are above 50 percent gray in a signed <cite>image</cite>). In this event,
manually scaling the input to the positive domain will solve the problem.</p>
<p>The Poisson distribution is only defined for positive integers. To apply
this noise type, the number of unique values in the image is found and
the next round power of two is used to scale up the floating-point result,
after which it is scaled back down to the floating-point image range.</p>
<p>To generate Poisson noise against a signed image, the signed image is
temporarily converted to an unsigned image in the floating point domain,
Poisson noise is generated, then it is returned to the original range.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.view_as_blocks">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">view_as_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_shape</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.view_as_blocks" title="Permalink to this definition">&para;</a></dt>
<dd><p>Block view of the input n-dimensional array (using re-striding).</p>
<p>Blocks are non-overlapping views of the input array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr_in</strong><span class="classifier">ndarray</span></dt><dd><p>N-d input array.</p>
</dd>
<dt><strong>block_shape</strong><span class="classifier">tuple</span></dt><dd><p>The shape of the block. Each dimension must divide evenly into the
corresponding dimensions of <cite>arr_in</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr_out</strong><span class="classifier">ndarray</span></dt><dd><p>Block view of the input array.  If <cite>arr_in</cite> is non-contiguous, a
copy is made.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.util.shape</span> <span class="kn">import</span> <span class="n">view_as_blocks</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[2, 3],</span>
<span class="go">       [6, 7]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">13</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="o">*</span><span class="mi">6</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>  
<span class="go">array([[[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">        [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">        [12, 13, 14, 15, 16, 17],</span>
<span class="go">        [18, 19, 20, 21, 22, 23]],</span>
<span class="go">       [[24, 25, 26, 27, 28, 29],</span>
<span class="go">        [30, 31, 32, 33, 34, 35],</span>
<span class="go">        [36, 37, 38, 39, 40, 41],</span>
<span class="go">        [42, 43, 44, 45, 46, 47]],</span>
<span class="go">       [[48, 49, 50, 51, 52, 53],</span>
<span class="go">        [54, 55, 56, 57, 58, 59],</span>
<span class="go">        [60, 61, 62, 63, 64, 65],</span>
<span class="go">        [66, 67, 68, 69, 70, 71]],</span>
<span class="go">       [[72, 73, 74, 75, 76, 77],</span>
<span class="go">        [78, 79, 80, 81, 82, 83],</span>
<span class="go">        [84, 85, 86, 87, 88, 89],</span>
<span class="go">        [90, 91, 92, 93, 94, 95]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_blocks</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">block_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(4, 2, 3, 1, 2, 2)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>  
<span class="go">array([[[[52, 53],</span>
<span class="go">         [58, 59]]],</span>
<span class="go">       [[[76, 77],</span>
<span class="go">         [82, 83]]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cucim.skimage.util.view_as_windows">
<span class="sig-prename descclassname"><span class="pre">cucim.skimage.util.</span></span><span class="sig-name descname"><span class="pre">view_as_windows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">window_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cucim.skimage.util.view_as_windows" title="Permalink to this definition">&para;</a></dt>
<dd><p>Rolling window view of the input n-dimensional array.</p>
<p>Windows are overlapping views of the input array, with adjacent windows
shifted by a single row or column (or an index of a higher dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>arr_in</strong><span class="classifier">ndarray</span></dt><dd><p>N-d input array.</p>
</dd>
<dt><strong>window_shape</strong><span class="classifier">integer or tuple of length arr_in.ndim</span></dt><dd><p>Defines the shape of the elementary n-dimensional orthotope
(better know as hyperrectangle <a class="reference internal" href="#rba40a1c6483a-1" id="id239">[1]</a>) of the rolling window view.
If an integer is given, the shape will be a hypercube of
sidelength given by its value.</p>
</dd>
<dt><strong>step</strong><span class="classifier">integer or tuple of length arr_in.ndim</span></dt><dd><p>Indicates step size at which extraction shall be performed.
If integer is given, then the step is uniform in all dimensions.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>arr_out</strong><span class="classifier">ndarray</span></dt><dd><p>(rolling) window view of the input array.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>One should be very careful with rolling views when it comes to
memory usage.  Indeed, although a &lsquo;view&rsquo; has the same memory
footprint as its base array, the actual array that emerges when this
&lsquo;view&rsquo; is used in a computation is generally a (much) larger array
than the original, especially for 2-dimensional arrays and above.</p>
<p>For example, let us consider a 3 dimensional array of size (100,
100, 100) of <code class="docutils literal notranslate"><span class="pre">float64</span></code>. This array takes about 8*100**3 Bytes for
storage which is just 8 MB. If one decides to build a rolling view
on this array with a window of (3, 3, 3) the hypothetical size of
the rolling view (if one was to reshape the view for example) would
be 8*(100-3+1)**3*3**3 which is about 203 MB! The scaling becomes
even worse as the dimension of the input array becomes larger.</p>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="rba40a1c6483a-1"><span class="brackets"><a class="fn-backref" href="#id239">1</a></span></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Hyperrectangle">https://en.wikipedia.org/wiki/Hyperrectangle</a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cupy</span> <span class="k">as</span> <span class="nn">cp</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">cucim.skimage.util.shape</span> <span class="kn">import</span> <span class="n">view_as_windows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">array([[0, 1],</span>
<span class="go">       [4, 5]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="go">array([[1, 2],</span>
<span class="go">       [5, 6]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(8, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>
<span class="go">array([[0, 1, 2],</span>
<span class="go">       [1, 2, 3],</span>
<span class="go">       [2, 3, 4],</span>
<span class="go">       [3, 4, 5],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [5, 6, 7],</span>
<span class="go">       [6, 7, 8],</span>
<span class="go">       [7, 8, 9]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span>
<span class="go">array([[ 0,  1,  2,  3],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15],</span>
<span class="go">       [16, 17, 18, 19]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">window_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">view_as_windows</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">window_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 4, 3)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span>  
<span class="go">array([[[[ 0,  1,  2],</span>
<span class="go">         [ 4,  5,  6],</span>
<span class="go">         [ 8,  9, 10],</span>
<span class="go">         [12, 13, 14]],</span>
<span class="go">        [[ 1,  2,  3],</span>
<span class="go">         [ 5,  6,  7],</span>
<span class="go">         [ 9, 10, 11],</span>
<span class="go">         [13, 14, 15]]],</span>
<span class="go">       [[[ 4,  5,  6],</span>
<span class="go">         [ 8,  9, 10],</span>
<span class="go">         [12, 13, 14],</span>
<span class="go">         [16, 17, 18]],</span>
<span class="go">        [[ 5,  6,  7],</span>
<span class="go">         [ 9, 10, 11],</span>
<span class="go">         [13, 14, 15],</span>
<span class="go">         [17, 18, 19]]]])</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="submodule-contents">
<h2>Submodule Contents<a class="headerlink" href="#submodule-contents" title="Permalink to this headline">&para;</a></h2>
<section id="module-cucim.skimage">
<span id="skimage"></span><h3>skimage<a class="headerlink" href="#module-cucim.skimage" title="Permalink to this headline">&para;</a></h3>
<p>GPU Image Processing for Python</p>
<p>This module is a CuPy based implementation of a subset of scikit-image.</p>
<p>It is a collection of algorithms for image processing and computer vision.</p>
<p>The main package only provides a few utilities for converting between image
data types; for most features, you need to import one of the following
subpackages:</p>
<section id="subpackages">
<h4>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">&para;</a></h4>
<dl class="simple">
<dt>color</dt><dd><p>Color space conversion.</p>
</dd>
<dt>exposure</dt><dd><p>Image intensity adjustment, e.g., histogram equalization, etc.</p>
</dd>
<dt>feature</dt><dd><p>Feature detection and extraction, e.g., texture analysis corners, etc.</p>
</dd>
<dt>filters</dt><dd><p>Sharpening, edge finding, rank filters, thresholding, etc.</p>
</dd>
<dt>measure</dt><dd><p>Measurement of image properties, e.g., region properties and contours.</p>
</dd>
<dt>metrics</dt><dd><p>Metrics corresponding to images, e.g. distance metrics, similarity, etc.</p>
</dd>
<dt>morphology</dt><dd><p>Morphological operations, e.g., opening or skeletonization.</p>
</dd>
<dt>restoration</dt><dd><p>Restoration algorithms, e.g., deconvolution algorithms, denoising, etc.</p>
</dd>
<dt>segmentation</dt><dd><p>Partitioning an image into multiple regions.</p>
</dd>
<dt>transform</dt><dd><p>Geometric and other transforms, e.g., rotation or the Radon transform.</p>
</dd>
<dt>util</dt><dd><p>Generic utilities.</p>
</dd>
</dl>
</section>
<section id="utility-functions">
<h4>Utility Functions<a class="headerlink" href="#utility-functions" title="Permalink to this headline">&para;</a></h4>
<dl class="simple">
<dt>img_as_float</dt><dd><p>Convert an image to floating point format, with values in [0, 1].
Is similar to <cite>img_as_float64</cite>, but will not convert lower-precision
floating point arrays to <cite>float64</cite>.</p>
</dd>
<dt>img_as_float32</dt><dd><p>Convert an image to single-precision (32-bit) floating point format,
with values in [0, 1].</p>
</dd>
<dt>img_as_float64</dt><dd><p>Convert an image to double-precision (64-bit) floating point format,
with values in [0, 1].</p>
</dd>
<dt>img_as_uint</dt><dd><p>Convert an image to unsigned integer format, with values in [0, 65535].</p>
</dd>
<dt>img_as_int</dt><dd><p>Convert an image to signed integer format, with values in [-32768, 32767].</p>
</dd>
<dt>img_as_ubyte</dt><dd><p>Convert an image to unsigned byte format, with values in [0, 255].</p>
</dd>
<dt>img_as_bool</dt><dd><p>Convert an image to boolean format, with values either True or False.</p>
</dd>
<dt>dtype_limits</dt><dd><p>Return intensity limits, i.e. (min, max) tuple, of the image&rsquo;s dtype.</p>
</dd>
</dl>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div aria-label="Footer" class="rst-footer-buttons" role="navigation">
        <a accesskey="p" class="btn btn-neutral float-left" href="index.html" rel="prev" title="Welcome to cuCIM&rsquo;s documentation!"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
    </div>

  <hr>

  <div role="contentinfo">
    <p>&copy; Copyright 2020-2021, NVIDIA.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>