<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.19" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcudf: Factories</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="rapids.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">libnvstrings</a><a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">nvstrings</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (0.15)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.16)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">stable (0.15)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.14)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Factories<div class="ingroups"><a class="el" href="group__cudf__classes.html">Classes</a> » <a class="el" href="group__column__classes.html">Column</a></div></div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga1390d45e0836457c0af214f921ca099e"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga1390d45e0836457c0af214f921ca099e">cudf::make_dictionary_column</a> (<a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;keys_column, <a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp;indices_column, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:ga1390d45e0836457c0af214f921ca099e"><td class="mdescLeft"> </td><td class="mdescRight">Construct a dictionary column by copying the provided <code>keys</code> and <code>indices</code>.  <a href="group__column__factories.html#ga1390d45e0836457c0af214f921ca099e">More...</a><br/></td></tr>
<tr class="separator:ga1390d45e0836457c0af214f921ca099e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga33ca90c88bf49b7f8a5985253d36de66"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga33ca90c88bf49b7f8a5985253d36de66">cudf::make_dictionary_column</a> (std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; keys_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; indices_column, rmm::device_buffer &amp;&amp;null_mask, size_type null_count)</td></tr>
<tr class="memdesc:ga33ca90c88bf49b7f8a5985253d36de66"><td class="mdescLeft"> </td><td class="mdescRight">Construct a dictionary column by taking ownership of the provided keys and indices columns.  <a href="group__column__factories.html#ga33ca90c88bf49b7f8a5985253d36de66">More...</a><br/></td></tr>
<tr class="separator:ga33ca90c88bf49b7f8a5985253d36de66"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6d0ae7e2382f3c5761946f83763d6d94"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga6d0ae7e2382f3c5761946f83763d6d94">cudf::make_empty_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga6d0ae7e2382f3c5761946f83763d6d94"><td class="mdescLeft"> </td><td class="mdescRight">Creates an empty column of the specified <code>type</code>.  <a href="group__column__factories.html#ga6d0ae7e2382f3c5761946f83763d6d94">More...</a><br/></td></tr>
<tr class="separator:ga6d0ae7e2382f3c5761946f83763d6d94"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaec37365eabe1d44e35da4b1e1f180410"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaec37365eabe1d44e35da4b1e1f180410">cudf::make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=mask_state::UNALLOCATED, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gaec37365eabe1d44e35da4b1e1f180410"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="group__column__factories.html#gaec37365eabe1d44e35da4b1e1f180410">More...</a><br/></td></tr>
<tr class="separator:gaec37365eabe1d44e35da4b1e1f180410"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7bcaaa009a6de4a88ba26b8479fb3c57"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:ga7bcaaa009a6de4a88ba26b8479fb3c57"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga7bcaaa009a6de4a88ba26b8479fb3c57">cudf::make_numeric_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga7bcaaa009a6de4a88ba26b8479fb3c57"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="group__column__factories.html#ga7bcaaa009a6de4a88ba26b8479fb3c57">More...</a><br/></td></tr>
<tr class="separator:ga7bcaaa009a6de4a88ba26b8479fb3c57"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7f42fbb142d31f0fd2ab30eb6e9181b1"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga7f42fbb142d31f0fd2ab30eb6e9181b1">cudf::make_timestamp_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=mask_state::UNALLOCATED, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga7f42fbb142d31f0fd2ab30eb6e9181b1"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="group__column__factories.html#ga7f42fbb142d31f0fd2ab30eb6e9181b1">More...</a><br/></td></tr>
<tr class="separator:ga7f42fbb142d31f0fd2ab30eb6e9181b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa2059fd303a1baca0a6c6f45192fa89e"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gaa2059fd303a1baca0a6c6f45192fa89e"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaa2059fd303a1baca0a6c6f45192fa89e">cudf::make_timestamp_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gaa2059fd303a1baca0a6c6f45192fa89e"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="group__column__factories.html#gaa2059fd303a1baca0a6c6f45192fa89e">More...</a><br/></td></tr>
<tr class="separator:gaa2059fd303a1baca0a6c6f45192fa89e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9a3befb00d093459dd4bbfd46ad41597"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga9a3befb00d093459dd4bbfd46ad41597">cudf::make_duration_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=mask_state::UNALLOCATED, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga9a3befb00d093459dd4bbfd46ad41597"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="group__column__factories.html#ga9a3befb00d093459dd4bbfd46ad41597">More...</a><br/></td></tr>
<tr class="separator:ga9a3befb00d093459dd4bbfd46ad41597"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaaf6fe706ecd20578b089772a2433bb8d"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:gaaf6fe706ecd20578b089772a2433bb8d"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaaf6fe706ecd20578b089772a2433bb8d">cudf::make_duration_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gaaf6fe706ecd20578b089772a2433bb8d"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="group__column__factories.html#gaaf6fe706ecd20578b089772a2433bb8d">More...</a><br/></td></tr>
<tr class="separator:gaaf6fe706ecd20578b089772a2433bb8d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf57b914eee04297db99282501796788d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaf57b914eee04297db99282501796788d">cudf::make_fixed_width_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> state=mask_state::UNALLOCATED, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gaf57b914eee04297db99282501796788d"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask.  <a href="group__column__factories.html#gaf57b914eee04297db99282501796788d">More...</a><br/></td></tr>
<tr class="separator:gaf57b914eee04297db99282501796788d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga206743e8bf8c30699498608d0b5876a5"><td class="memTemplParams" colspan="2">template&lt;typename B &gt; </td></tr>
<tr class="memitem:ga206743e8bf8c30699498608d0b5876a5"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga206743e8bf8c30699498608d0b5876a5">cudf::make_fixed_width_column</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type, size_type size, B &amp;&amp;null_mask, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga206743e8bf8c30699498608d0b5876a5"><td class="mdescLeft"> </td><td class="mdescRight">Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask.  <a href="group__column__factories.html#ga206743e8bf8c30699498608d0b5876a5">More...</a><br/></td></tr>
<tr class="separator:ga206743e8bf8c30699498608d0b5876a5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6a2a36602ee4f363136be19f404a7733"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga6a2a36602ee4f363136be19f404a7733">cudf::make_strings_column</a> (const rmm::device_vector&lt; thrust::pair&lt; const char *, size_type &gt;&gt; &amp;strings, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga6a2a36602ee4f363136be19f404a7733"><td class="mdescLeft"> </td><td class="mdescRight">Construct STRING type column given a device vector of pointer/size pairs. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column.  <a href="group__column__factories.html#ga6a2a36602ee4f363136be19f404a7733">More...</a><br/></td></tr>
<tr class="separator:ga6a2a36602ee4f363136be19f404a7733"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa16782c4760d9028daae17f1183316ee"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gaa16782c4760d9028daae17f1183316ee">cudf::make_strings_column</a> (const rmm::device_vector&lt; <a class="el" href="classcudf_1_1string__view.html">string_view</a> &gt; &amp;string_views, const <a class="el" href="classcudf_1_1string__view.html">string_view</a> null_placeholder, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gaa16782c4760d9028daae17f1183316ee"><td class="mdescLeft"> </td><td class="mdescRight">Construct STRING type column given a device vector of <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a>. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column.  <a href="group__column__factories.html#gaa16782c4760d9028daae17f1183316ee">More...</a><br/></td></tr>
<tr class="separator:gaa16782c4760d9028daae17f1183316ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7651e97bd14e50797f0ac4a02115613d"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga7651e97bd14e50797f0ac4a02115613d">cudf::make_strings_column</a> (const rmm::device_vector&lt; char &gt; &amp;strings, const rmm::device_vector&lt; size_type &gt; &amp;offsets, const rmm::device_vector&lt; bitmask_type &gt; &amp;null_mask={}, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga7651e97bd14e50797f0ac4a02115613d"><td class="mdescLeft"> </td><td class="mdescRight">Construct STRING type column given a device vector of chars encoded as UTF-8, a device vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask.  <a href="group__column__factories.html#ga7651e97bd14e50797f0ac4a02115613d">More...</a><br/></td></tr>
<tr class="separator:ga7651e97bd14e50797f0ac4a02115613d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga51497aad59554b0b4ceb042921a6f200"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga51497aad59554b0b4ceb042921a6f200">cudf::make_strings_column</a> (const std::vector&lt; char &gt; &amp;strings, const std::vector&lt; size_type &gt; &amp;offsets, const std::vector&lt; bitmask_type &gt; &amp;null_mask={}, size_type null_count=cudf::UNKNOWN_NULL_COUNT, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga51497aad59554b0b4ceb042921a6f200"><td class="mdescLeft"> </td><td class="mdescRight">Construct STRING type column given a host vector of chars encoded as UTF-8, a host vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask.  <a href="group__column__factories.html#ga51497aad59554b0b4ceb042921a6f200">More...</a><br/></td></tr>
<tr class="separator:ga51497aad59554b0b4ceb042921a6f200"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga751333fab2e84ab56b84062a809c4433"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga751333fab2e84ab56b84062a809c4433">cudf::make_strings_column</a> (size_type num_strings, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; offsets_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; chars_column, size_type null_count, rmm::device_buffer &amp;&amp;null_mask, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga751333fab2e84ab56b84062a809c4433"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a STRING type column given offsets column, chars columns, and null mask and null count. The columns and mask are moved into the resulting strings column.  <a href="group__column__factories.html#ga751333fab2e84ab56b84062a809c4433">More...</a><br/></td></tr>
<tr class="separator:ga751333fab2e84ab56b84062a809c4433"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga8670f70dc6332a285e3a9bcc202ff1ea"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga8670f70dc6332a285e3a9bcc202ff1ea">cudf::make_lists_column</a> (size_type num_lists, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; offsets_column, std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; child_column, size_type null_count, rmm::device_buffer &amp;&amp;null_mask, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga8670f70dc6332a285e3a9bcc202ff1ea"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a LIST type column given offsets column, child column, and null mask and null count.  <a href="group__column__factories.html#ga8670f70dc6332a285e3a9bcc202ff1ea">More...</a><br/></td></tr>
<tr class="separator:ga8670f70dc6332a285e3a9bcc202ff1ea"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga3ded045516a5829ed3da26561b88a017"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#ga3ded045516a5829ed3da26561b88a017">cudf::make_structs_column</a> (size_type num_rows, std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&gt; &amp;&amp;child_columns, size_type null_count, rmm::device_buffer &amp;&amp;null_mask, <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga3ded045516a5829ed3da26561b88a017"><td class="mdescLeft"> </td><td class="mdescRight">Constructs a STRUCT column using specified child columns as members.  <a href="group__column__factories.html#ga3ded045516a5829ed3da26561b88a017">More...</a><br/></td></tr>
<tr class="separator:ga3ded045516a5829ed3da26561b88a017"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae13a6ff9c1b7777e88309f23f44300fa"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__column__factories.html#gae13a6ff9c1b7777e88309f23f44300fa">cudf::make_column_from_scalar</a> (<a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp;s, size_type size, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> stream=0)</td></tr>
<tr class="memdesc:gae13a6ff9c1b7777e88309f23f44300fa"><td class="mdescLeft"> </td><td class="mdescRight">Return a column with size elements that are all equal to the given scalar.  <a href="group__column__factories.html#gae13a6ff9c1b7777e88309f23f44300fa">More...</a><br/></td></tr>
<tr class="separator:gae13a6ff9c1b7777e88309f23f44300fa"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae13a6ff9c1b7777e88309f23f44300fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae13a6ff9c1b7777e88309f23f44300fa">◆ </a></span>make_column_from_scalar()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_column_from_scalar </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1scalar.html">scalar</a> const &amp; </td>
<td class="paramname"><em>s</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Return a column with size elements that are all equal to the given scalar. </p>
<p>The output column will have the same type as <code>s.type()</code> The output column will contain all null rows if <code>s.invalid()==false</code> The output column will be empty if <code>size==0</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">s</td><td>The scalar to use for values in the column. </td></tr>
<tr><td class="paramname">size</td><td>The number of rows for the output column. </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga1390d45e0836457c0af214f921ca099e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1390d45e0836457c0af214f921ca099e">◆ </a></span>make_dictionary_column() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_dictionary_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>keys_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">column_view</a> const &amp; </td>
<td class="paramname"><em>indices_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct a dictionary column by copying the provided <code>keys</code> and <code>indices</code>. </p>
<p>It is expected that <code>keys_column.has_nulls() == false</code>. It is assumed the elements in <code>keys_column</code> are unique and are in a strict, total order. Meaning, <code>keys_column[i]</code> is ordered before <code>keys_column[i+1]</code> for all <code>i in [0,n-1)</code> where <code>n</code> is the number of keys.</p>
<p>The indices values must be in the range [0,keys_column.size()).</p>
<p>The null_mask and null count for the output column are copied from the indices column. If element <code>i</code> in <code>indices_column</code> is null, then element <code>i</code> in the returned dictionary column will also be null.</p>
<div class="fragment"><div class="line">k = [<span class="stringliteral">"a"</span>,<span class="stringliteral">"c"</span>,<span class="stringliteral">"d"</span>]</div>
<div class="line">i = [1,0,<span class="keyword">null</span>,2,2]</div>
<div class="line">d = <a class="code" href="group__column__factories.html#ga1390d45e0836457c0af214f921ca099e">make_dictionary_column</a>(k,i)</div>
<div class="line">d is now {[<span class="stringliteral">"a"</span>,<span class="stringliteral">"c"</span>,<span class="stringliteral">"d"</span>],[1,0,undefined,2,2]} bitmask={1,1,0,1,1}</div>
</div><!-- fragment --><p>The null_mask and null count for the output column are copied from the indices column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if keys_column contains nulls </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if indices_column type is not INT32</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">keys_column</td><td>Column of unique, ordered values to use as the new dictionary column's keys. </td></tr>
<tr><td class="paramname">indices_column</td><td>Indices to use for the new dictionary column. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New dictionary column. </dd></dl>
</div>
</div>
<a id="ga33ca90c88bf49b7f8a5985253d36de66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga33ca90c88bf49b7f8a5985253d36de66">◆ </a></span>make_dictionary_column() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_dictionary_column </td>
<td>(</td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td>
<td class="paramname"><em>keys_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td>
<td class="paramname"><em>indices_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_buffer &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct a dictionary column by taking ownership of the provided keys and indices columns. </p>
<p>The keys_column and indices columns must contain no nulls. It is assumed the elements in <code>keys_column</code> are unique and are in a strict, total order. Meaning, <code>keys_column[i]</code> is ordered before <code>keys_column[i+1]</code> for all <code>i in [0,n-1)</code> where <code>n</code> is the number of keys.</p>
<p>The indices values must be in the range [0,keys_column.size()).</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if keys_column or indices_column contains nulls </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if indices_column type is not INT32</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">keys_column</td><td>Column of unique, ordered values to use as the new dictionary column's keys. </td></tr>
<tr><td class="paramname">indices_column</td><td>Indices to use for the new dictionary column. </td></tr>
<tr><td class="paramname">null_mask</td><td>Null mask for the output column. </td></tr>
<tr><td class="paramname">null_count</td><td>Number of nulls for the output column. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New dictionary column. </dd></dl>
</div>
</div>
<a id="gaaf6fe706ecd20578b089772a2433bb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf6fe706ecd20578b089772a2433bb8d">◆ </a></span>make_duration_column() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_duration_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">B &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a duration type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired duration element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga9a3befb00d093459dd4bbfd46ad41597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9a3befb00d093459dd4bbfd46ad41597">◆ </a></span>make_duration_column() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_duration_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> </td>
<td class="paramname"><em>state</em> = <code>mask_state::UNALLOCATED</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified duration <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a duration type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired duration element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga6d0ae7e2382f3c5761946f83763d6d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d0ae7e2382f3c5761946f83763d6d94">◆ </a></span>make_empty_column()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_empty_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates an empty column of the specified <code>type</code>. </p>
<p>An empty column does not contain any elements or a validity mask.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The desired type </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Empty column with desired type </dd></dl>
</div>
</div>
<a id="ga206743e8bf8c30699498608d0b5876a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206743e8bf8c30699498608d0b5876a5">◆ </a></span>make_fixed_width_column() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_fixed_width_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">B &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a fixed width type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired fixed width element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gaf57b914eee04297db99282501796788d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf57b914eee04297db99282501796788d">◆ </a></span>make_fixed_width_column() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_fixed_width_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> </td>
<td class="paramname"><em>state</em> = <code>mask_state::UNALLOCATED</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified fixed width <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a fixed width type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired fixed width type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga8670f70dc6332a285e3a9bcc202ff1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8670f70dc6332a285e3a9bcc202ff1ea">◆ </a></span>make_lists_column()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; cudf::make_lists_column </td>
<td>(</td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>num_lists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td>
<td class="paramname"><em>offsets_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td>
<td class="paramname"><em>child_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_buffer &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructs a LIST type column given offsets column, child column, and null mask and null count. </p>
<p>The columns and mask are moved into the resulting lists column.</p>
<p>List columns are structured similarly to strings columns. They contain a set of offsets which represents the lengths of the lists in each row, and a "child" column of data that is referenced by the offsets. Since lists are a nested type, the child column may itself be further nested.</p>
<p>When child column at depth N+1 is itself a list, the offsets column at depth N references the offsets column for depth N+1. When the child column at depth N+1 is a leaf type (int, float, etc), the offsets column at depth N references the data for depth N+1.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">List&lt;int&gt;</div>
<div class="line">input:              {{1, 2}, {3, 4, 5}}</div>
<div class="line">offsets (depth 0)   {0, 2, 5}</div>
<div class="line">data    (depth 0)</div>
<div class="line">offsets (depth 1)</div>
<div class="line">data    (depth 1)   {1, 2, 3, 4, 5}</div>
</div><!-- fragment --><div class="fragment"><div class="line">Example:</div>
<div class="line">List&lt;List&lt;int&gt;&gt;</div>
<div class="line">input:              { {{1, 2}}, {{3, 4, 5}, {6, 7}} }</div>
<div class="line">offsets (depth 0)   {0, 1, 3}</div>
<div class="line">data    (depth 0)</div>
<div class="line">offsets (depth 1)   {0, 2, 5, 7}</div>
<div class="line">data    (depth 1)</div>
<div class="line">offsets (depth 2)</div>
<div class="line">data    (depth 1)   {1, 2, 3, 4, 5, 6, 7}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">num_lists</td><td>The number of lists the column represents. </td></tr>
<tr><td class="paramname">offsets_column</td><td>The column of offset values for this column. Each value should represent the starting offset into the child elements that corresponds to the beginning of the row, with the first row starting at 0. The length of row N can be determined by subtracting offsets[N+1] - offsets[N]. The total number of offsets should be 1 longer than the # of rows in the column. </td></tr>
<tr><td class="paramname">child_column</td><td>The column of nested data referenced by the lists represented by the offsets_column. Note: the child column may itself be further nested. </td></tr>
<tr><td class="paramname">null_count</td><td>The number of null list entries. </td></tr>
<tr><td class="paramname">null_mask</td><td>The bits specifying the null lists in device memory. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
<tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels </td></tr>
<tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation of the column's <code>null_mask</code> and children. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga7bcaaa009a6de4a88ba26b8479fb3c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7bcaaa009a6de4a88ba26b8479fb3c57">◆ </a></span>make_numeric_column() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_numeric_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">B &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a numeric type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired numeric element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gaec37365eabe1d44e35da4b1e1f180410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec37365eabe1d44e35da4b1e1f180410">◆ </a></span>make_numeric_column() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_numeric_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> </td>
<td class="paramname"><em>state</em> = <code>mask_state::UNALLOCATED</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a numeric type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired numeric element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga7651e97bd14e50797f0ac4a02115613d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7651e97bd14e50797f0ac4a02115613d">◆ </a></span>make_strings_column() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_strings_column </td>
<td>(</td>
<td class="paramtype">const rmm::device_vector&lt; char &gt; &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const rmm::device_vector&lt; size_type &gt; &amp; </td>
<td class="paramname"><em>offsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const rmm::device_vector&lt; bitmask_type &gt; &amp; </td>
<td class="paramname"><em>null_mask</em> = <code>{}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct STRING type column given a device vector of chars encoded as UTF-8, a device vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask. </p>
<p><code>offsets.front()</code> must always be zero.</p>
<p>The total number of char bytes must not exceed the maximum size of size_type. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. This function makes a deep copy of the strings, offsets, null_mask to create a new column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>The vector of chars in device memory. This char vector is expected to be UTF-8 encoded characters. </td></tr>
<tr><td class="paramname">offsets</td><td>The vector of byte offsets in device memory. The number of elements is one more than the total number of strings so the <code>offsets.back()</code> is the total number of bytes in the strings array. <code>offsets.front()</code> must always be 0 to point to the beginning of <code>strings</code>. </td></tr>
<tr><td class="paramname">null_mask</td><td>Device vector containing the null element indicator bitmask. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
<tr><td class="paramname">null_count</td><td>The number of null string entries. If equal to <code>UNKNOWN_NULL_COUNT</code>, the null count will be computed dynamically on the first invocation of <code><a class="el" href="classcudf_1_1column.html#a2d92092a5214eb9ea8205eea0adbd9bc" title="Returns the count of null elements.">column::null_count()</a></code> </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used for allocation of the column's <code>null_mask</code> and children columns' device memory. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gaa16782c4760d9028daae17f1183316ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa16782c4760d9028daae17f1183316ee">◆ </a></span>make_strings_column() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_strings_column </td>
<td>(</td>
<td class="paramtype">const rmm::device_vector&lt; <a class="el" href="classcudf_1_1string__view.html">string_view</a> &gt; &amp; </td>
<td class="paramname"><em>string_views</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="classcudf_1_1string__view.html">string_view</a> </td>
<td class="paramname"><em>null_placeholder</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct STRING type column given a device vector of <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a>. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. </p>
<dl class="section note"><dt>Note</dt><dd>For each <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a>, if <code>.data()</code> is <code>null_placeholder.data()</code>, that string is considered null. Likewise, a string is considered empty (not null) if <code>.data()</code> is not <code>null_placeholder.data()</code> and <code>.size_bytes()</code> is 0. Otherwise the <code>.data()</code> must be a valid device address pointing to <code>.size_bytes()</code> consecutive bytes. The <code>null_count()</code> for the output column will be equal to the number of input <code><a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a></code>s that are null.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">string_views</td><td>The vector of <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a>. Each <a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a> must point to a device memory address or <code>null_placeholder</code> (indicating a null string). The size must be the number of bytes. </td></tr>
<tr><td class="paramname">null_placeholder</td><td><a class="el" href="classcudf_1_1string__view.html" title="A non-owning, immutable view of device data that is a variable length char array representing a UTF-8...">string_view</a> indicating null string in given list of string_views. </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used for allocation of the column's <code>null_mask</code> and children columns' device memory. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga6a2a36602ee4f363136be19f404a7733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a2a36602ee4f363136be19f404a7733">◆ </a></span>make_strings_column() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_strings_column </td>
<td>(</td>
<td class="paramtype">const rmm::device_vector&lt; thrust::pair&lt; const char *, size_type &gt;&gt; &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct STRING type column given a device vector of pointer/size pairs. The total number of char bytes must not exceed the maximum size of size_type. The string characters are expected to be UTF-8 encoded sequence of char bytes. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> and <code>null_bitmask</code> are determined if a pair contains a null string. That is, for each pair, if <code>.first</code> is null, that string is considered null. Likewise, a string is considered empty (not null) if <code>.first</code> is not null and <code>.second</code> is 0. Otherwise the <code>.first</code> member must be a valid device address pointing to <code>.second</code> consecutive bytes.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>The vector of pointer/size pairs. Each pointer must be a device memory address or <code>nullptr</code> (indicating a null string). The size must be the number of bytes. </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used for allocation of the column's <code>null_mask</code> and children columns' device memory. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga51497aad59554b0b4ceb042921a6f200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51497aad59554b0b4ceb042921a6f200">◆ </a></span>make_strings_column() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_strings_column </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; char &gt; &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; size_type &gt; &amp; </td>
<td class="paramname"><em>offsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const std::vector&lt; bitmask_type &gt; &amp; </td>
<td class="paramname"><em>null_mask</em> = <code>{}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct STRING type column given a host vector of chars encoded as UTF-8, a host vector of byte offsets identifying individual strings within the char vector, and an optional null bitmask. </p>
<p><code>offsets.front()</code> must always be zero.</p>
<p>The total number of char bytes must not exceed the maximum size of size_type. Use the <a class="el" href="classcudf_1_1strings__column__view.html" title="Given a column-view of strings type, an instance of this class provides a wrapper on this compound co...">strings_column_view</a> class to perform strings operations on this type of column. This function makes a deep copy of the strings, offsets, null_mask to create a new column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>The contiguous array of chars in host memory. This char array is expected to be UTF-8 encoded characters. </td></tr>
<tr><td class="paramname">offsets</td><td>The array of byte offsets in host memory. The number of elements is one more than the total number of strings so the <code>offsets.back()</code> is the total number of bytes in the strings array. <code>offsets.front()</code> must always be 0 to point to the beginning of <code>strings</code>. </td></tr>
<tr><td class="paramname">null_mask</td><td>Host vector containing the null element indicator bitmask. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
<tr><td class="paramname">null_count</td><td>The number of null string entries. If equal to <code>UNKNOWN_NULL_COUNT</code>, the null count will be computed dynamically on the first invocation of <code><a class="el" href="classcudf_1_1column.html#a2d92092a5214eb9ea8205eea0adbd9bc" title="Returns the count of null elements.">column::null_count()</a></code> </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used for allocation of the column's <code>null_mask</code> and children columns' device memory. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga751333fab2e84ab56b84062a809c4433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga751333fab2e84ab56b84062a809c4433">◆ </a></span>make_strings_column() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_strings_column </td>
<td>(</td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>num_strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td>
<td class="paramname"><em>offsets_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt; </td>
<td class="paramname"><em>chars_column</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_buffer &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructs a STRING type column given offsets column, chars columns, and null mask and null count. The columns and mask are moved into the resulting strings column. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">num_strings</td><td>The number of strings the column represents. </td></tr>
<tr><td class="paramname">offsets_column</td><td>The column of offset values for this column. The number of elements is one more than the total number of strings so the offset[last] - offset[0] is the total number of bytes in the strings vector. </td></tr>
<tr><td class="paramname">chars_column</td><td>The column of char bytes for all the strings for this column. Individual strings are identified by the offsets and the nullmask. </td></tr>
<tr><td class="paramname">null_count</td><td>The number of null string entries. </td></tr>
<tr><td class="paramname">null_mask</td><td>The bits specifying the null strings in device memory. Arrow format for nulls is used for interpeting this bitmask. </td></tr>
<tr><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used for allocation of the column's <code>null_mask</code> and children columns' device memory. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga3ded045516a5829ed3da26561b88a017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ded045516a5829ed3da26561b88a017">◆ </a></span>make_structs_column()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; cudf::make_structs_column </td>
<td>(</td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>num_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">column</a> &gt;&gt; &amp;&amp; </td>
<td class="paramname"><em>child_columns</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::device_buffer &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Constructs a STRUCT column using specified child columns as members. </p>
<p>Specified child/member columns and null_mask are adopted by resultant struct column.</p>
<p>A struct column requires that all specified child columns have the same number of rows. A struct column's row count equals that of any/all of its child columns. A single struct row at any index is comprised of all the individual child column values at the same index, in the order specified in the list of child columns.</p>
<p>The specified null mask governs which struct row has a null value. This is orthogonal to the null values of individual child columns.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">num_rows</td><td>The number of struct values in the struct column. </td></tr>
<tr><td class="paramname">child_columns</td><td>The list of child/members that the struct is comprised of. </td></tr>
<tr><td class="paramname">null_count</td><td>The number of null values in the struct column. </td></tr>
<tr><td class="paramname">null_mask</td><td>The bits specifying the null struct values in the column. </td></tr>
<tr><td class="paramname">stream</td><td>Optional stream for use with all memory allocation and device kernels. </td></tr>
<tr><td class="paramname">mr</td><td>Optional resource to use for device memory allocation. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gaa2059fd303a1baca0a6c6f45192fa89e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2059fd303a1baca0a6c6f45192fa89e">◆ </a></span>make_timestamp_column() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename B &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_timestamp_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">B &amp;&amp; </td>
<td class="paramname"><em>null_mask</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>null_count</em> = <code>cudf::UNKNOWN_NULL_COUNT</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with a null mask. </p>
<dl class="section note"><dt>Note</dt><dd>null_count is optional and will be computed if not provided.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a timestamp type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired timestamp element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_mask</td><td>Null mask to use for this column. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">null_count</td><td>Optional number of nulls in the null_mask. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ga7f42fbb142d31f0fd2ab30eb6e9181b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f42fbb142d31f0fd2ab30eb6e9181b1">◆ </a></span>make_timestamp_column() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">column</a>&gt; cudf::make_timestamp_column </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_type </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">mask_state</a> </td>
<td class="paramname"><em>state</em> = <code>mask_state::UNALLOCATED</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">cudaStream_t</a> </td>
<td class="paramname"><em>stream</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Construct column with sufficient uninitialized storage to hold <code>size</code> elements of the specified timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> with an optional null mask. </p>
<dl class="section note"><dt>Note</dt><dd><code>null_count()</code> is determined by the requested null mask <code>state</code></dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname">std::bad_alloc</td><td>if device memory allocation fails </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>type</code> is not a timestamp type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">type</td><td>The desired timestamp element type </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of elements in the column </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">state</td><td>Optional, controls allocation/initialization of the column's null mask. By default, no null mask is allocated. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>CUDA stream used for device memory operations and kernel launches. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory </td></tr>
</table>
</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<div class="ttc" id="agroup__column__factories_html_ga1390d45e0836457c0af214f921ca099e"><div class="ttname"><a href="group__column__factories.html#ga1390d45e0836457c0af214f921ca099e">cudf::make_dictionary_column</a></div><div class="ttdeci">std::unique_ptr&lt; column &gt; make_dictionary_column(column_view const &amp;keys_column, column_view const &amp;indices_column, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource(), cudaStream_t stream=0)</div><div class="ttdoc">Construct a dictionary column by copying the provided keys and indices.</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.19
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
