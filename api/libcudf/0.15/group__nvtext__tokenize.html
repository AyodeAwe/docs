<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.19" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcudf: Tokenizing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="rapids.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/legacy">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">legacy (0.15)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.17)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (0.16)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.15)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.19 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Tokenizing<div class="ingroups"><a class="el" href="group__nvtext__apis.html">NVText</a></div></div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtext_1_1hashed__vocabulary.html">nvtext::hashed_vocabulary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The vocabulary data for use with the subword_tokenize function.  <a href="structnvtext_1_1hashed__vocabulary.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structnvtext_1_1tokenizer__result.html">nvtext::tokenizer_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Result object for the subword_tokenize functions.  <a href="structnvtext_1_1tokenizer__result.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8603f724aa881a6608d26225a227e795"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga8603f724aa881a6608d26225a227e795">nvtext::load_vocabulary_file</a> (std::string const &amp;filename_hashed_vocabulary, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga8603f724aa881a6608d26225a227e795"><td class="mdescLeft"> </td><td class="mdescRight">Load the hashed vocabulary file into device memory.  <a href="group__nvtext__tokenize.html#ga8603f724aa881a6608d26225a227e795">More...</a><br/></td></tr>
<tr class="separator:ga8603f724aa881a6608d26225a227e795"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad725d85bccf2869740328e42a3db6ed2"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structnvtext_1_1tokenizer__result.html">tokenizer_result</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#gad725d85bccf2869740328e42a3db6ed2">nvtext::subword_tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, std::string const &amp;filename_hashed_vocabulary, uint32_t max_sequence_length, uint32_t stride, bool do_lower_case, bool do_truncate, uint32_t max_num_strings, uint32_t max_num_chars, uint32_t max_rows_tensor, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gad725d85bccf2869740328e42a3db6ed2"><td class="mdescLeft"> </td><td class="mdescRight">Creates a tokenizer that cleans the text, splits it into tokens and returns token-ids from an input vocabulary.  <a href="group__nvtext__tokenize.html#gad725d85bccf2869740328e42a3db6ed2">More...</a><br/></td></tr>
<tr class="separator:gad725d85bccf2869740328e42a3db6ed2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5cd7e1cc61dd86b1d0d558f5a768acce"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structnvtext_1_1tokenizer__result.html">tokenizer_result</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga5cd7e1cc61dd86b1d0d558f5a768acce">nvtext::subword_tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> const &amp;vocabulary_table, uint32_t max_sequence_length, uint32_t stride, bool do_lower_case, bool do_truncate, uint32_t max_num_strings, uint32_t max_num_chars, uint32_t max_rows_tensor, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga5cd7e1cc61dd86b1d0d558f5a768acce"><td class="mdescLeft"> </td><td class="mdescRight">Creates a tokenizer that cleans the text, splits it into tokens and returns token-ids from an input vocabulary.  <a href="group__nvtext__tokenize.html#ga5cd7e1cc61dd86b1d0d558f5a768acce">More...</a><br/></td></tr>
<tr class="separator:ga5cd7e1cc61dd86b1d0d558f5a768acce"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5a6377b3226915576a277c291c9abf77"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga5a6377b3226915576a277c291c9abf77">nvtext::tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;delimiter=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga5a6377b3226915576a277c291c9abf77"><td class="mdescLeft"> </td><td class="mdescRight">Returns a single column of strings by tokenizing the input strings column using the provided characters as delimiters.  <a href="group__nvtext__tokenize.html#ga5a6377b3226915576a277c291c9abf77">More...</a><br/></td></tr>
<tr class="separator:ga5a6377b3226915576a277c291c9abf77"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga86420ed6ea932602cfd195385b153959"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga86420ed6ea932602cfd195385b153959">nvtext::tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;delimiters, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga86420ed6ea932602cfd195385b153959"><td class="mdescLeft"> </td><td class="mdescRight">Returns a single column of strings by tokenizing the input strings column using multiple strings as delimiters.  <a href="group__nvtext__tokenize.html#ga86420ed6ea932602cfd195385b153959">More...</a><br/></td></tr>
<tr class="separator:ga86420ed6ea932602cfd195385b153959"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga42e284f58436d9eb3b0a4b5985bed67b"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga42e284f58436d9eb3b0a4b5985bed67b">nvtext::count_tokens</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;delimiter=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga42e284f58436d9eb3b0a4b5985bed67b"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of tokens in each string of a strings column.  <a href="group__nvtext__tokenize.html#ga42e284f58436d9eb3b0a4b5985bed67b">More...</a><br/></td></tr>
<tr class="separator:ga42e284f58436d9eb3b0a4b5985bed67b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5fc4729449ab49a49437c08c49aa0c6f"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga5fc4729449ab49a49437c08c49aa0c6f">nvtext::count_tokens</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;delimiters, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga5fc4729449ab49a49437c08c49aa0c6f"><td class="mdescLeft"> </td><td class="mdescRight">Returns the number of tokens in each string of a strings column by using multiple strings delimiters to identify tokens in each string.  <a href="group__nvtext__tokenize.html#ga5fc4729449ab49a49437c08c49aa0c6f">More...</a><br/></td></tr>
<tr class="separator:ga5fc4729449ab49a49437c08c49aa0c6f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf24b3e3b4b57ac50f78a53144e2545a6"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#gaf24b3e3b4b57ac50f78a53144e2545a6">nvtext::character_tokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:gaf24b3e3b4b57ac50f78a53144e2545a6"><td class="mdescLeft"> </td><td class="mdescRight">Returns a single column of strings by converting each character to a string.  <a href="group__nvtext__tokenize.html#gaf24b3e3b4b57ac50f78a53144e2545a6">More...</a><br/></td></tr>
<tr class="separator:gaf24b3e3b4b57ac50f78a53144e2545a6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga16d0139fef798baf52be266b97ac35b3"><td align="right" class="memItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcudf_1_1column.html">cudf::column</a> &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="group__nvtext__tokenize.html#ga16d0139fef798baf52be266b97ac35b3">nvtext::detokenize</a> (<a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp;strings, <a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp;row_indices, <a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp;separator=<a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>(" "), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ga16d0139fef798baf52be266b97ac35b3"><td class="mdescLeft"> </td><td class="mdescRight">Creates a strings column from a strings column of tokens and an associated column of row ids.  <a href="group__nvtext__tokenize.html#ga16d0139fef798baf52be266b97ac35b3">More...</a><br/></td></tr>
<tr class="separator:ga16d0139fef798baf52be266b97ac35b3"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf24b3e3b4b57ac50f78a53144e2545a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf24b3e3b4b57ac50f78a53144e2545a6">◆ </a></span>character_tokenize()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::character_tokenize </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a single column of strings by converting each character to a string. </p>
<p>Each string is converted to multiple strings – one for each character. Note that a character maybe more than one byte.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["hello world", null, "goodbye"]</div>
<div class="line">t = character_tokenize(s)</div>
<div class="line">t is now ["h","e","l","l","o"," ","w","o","r","l","d","g","o","o","d","b","y","e"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings column to tokenize. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>
</div>
</div>
<a id="ga42e284f58436d9eb3b0a4b5985bed67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42e284f58436d9eb3b0a4b5985bed67b">◆ </a></span>count_tokens() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::count_tokens </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp; </td>
<td class="paramname"><em>delimiter</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of tokens in each string of a strings column. </p>
<p>The <code>delimiter</code> may be zero or more characters. If the <code>delimiter</code> is empty, whitespace (character code-point &lt;= ' ') is used for identifying tokens. Also, any consecutive delimiters found in a string are ignored. This means that only empty strings or null rows will result in a token count of 0.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", " ", "d e f"]</div>
<div class="line">t = count_tokens(s)</div>
<div class="line">t is now [1, 2, 0, 3]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows. The number of tokens for a null element is set to 0 in the output column.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings column to use for this operation. </td></tr>
<tr><td class="paramname">delimiter</td><td>Strings used to separate each string into tokens. The default of empty string will separate tokens using whitespace. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New INT32 column of token counts. </dd></dl>
</div>
</div>
<a id="ga5fc4729449ab49a49437c08c49aa0c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5fc4729449ab49a49437c08c49aa0c6f">◆ </a></span>count_tokens() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::count_tokens </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>delimiters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the number of tokens in each string of a strings column by using multiple strings delimiters to identify tokens in each string. </p>
<p>Also, any consecutive delimiters found in a string are ignored. This means that only empty strings or null rows will result in a token count of 0.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", "d.e:f;"]</div>
<div class="line">d = [".", ":", ";"]</div>
<div class="line">t = count_tokens(s,d)</div>
<div class="line">t is now [1, 1, 3]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows. The number of tokens for a null element is set to 0 in the output column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the delimiters column is empty or contains nulls.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings column to use for this operation. </td></tr>
<tr><td class="paramname">delimiters</td><td>Strings used to separate each string into tokens. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New INT32 column of token counts. </dd></dl>
</div>
</div>
<a id="ga16d0139fef798baf52be266b97ac35b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16d0139fef798baf52be266b97ac35b3">◆ </a></span>detokenize()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::detokenize </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1column__view.html">cudf::column_view</a> const &amp; </td>
<td class="paramname"><em>row_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp; </td>
<td class="paramname"><em>separator</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>(" ")</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a strings column from a strings column of tokens and an associated column of row ids. </p>
<p>Multiple tokens from the input column may be combined into a single row (string) in the output column. The tokens are concatenated along with the <code>separator</code> string in the order in which they appear in the <code>row_indices</code> column.</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["hello", "world", "one", "two", "three"]</div>
<div class="line">r = [0, 0, 1, 1, 1]</div>
<div class="line">s1 = detokenize(s,r)</div>
<div class="line">s1 is now ["hello world", "one two three"]</div>
<div class="line">r = [0, 2, 1, 1, 0]</div>
<div class="line">s2 = detokenize(s,r)</div>
<div class="line">s2 is now ["hello three", "one two", "world"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows. The values in <code>row_indices</code> are expected to have positive, sequential values without any missing row indices otherwise the output is undefined.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>is <code>separator</code> is invalid </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>row_indices.size() != strings.size()</code> </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>row_indices</code> contains nulls</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings column to detokenize. </td></tr>
<tr><td class="paramname">row_indices</td><td>The relative output row index assigned for each token in the input column. </td></tr>
<tr><td class="paramname">separator</td><td>String to append after concatenating each token to the proper output row. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>
</div>
</div>
<a id="ga8603f724aa881a6608d26225a227e795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8603f724aa881a6608d26225a227e795">◆ </a></span>load_vocabulary_file()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> nvtext::load_vocabulary_file </td>
<td>(</td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>filename_hashed_vocabulary</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Load the hashed vocabulary file into device memory. </p>
<p>The object here can be used to call the subword_tokenize without incurring the cost of loading the same file each time.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the <code>filename_hashed_vocabulary</code> could not be opened.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">filename_hashed_vocabulary</td><td>A path to the preprocessed vocab.txt file. Note that this is the file AFTER python/perfect_hash.py has been used for preprocessing. </td></tr>
<tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vocabulary hash-table elements </dd></dl>
</div>
</div>
<a id="ga5cd7e1cc61dd86b1d0d558f5a768acce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5cd7e1cc61dd86b1d0d558f5a768acce">◆ </a></span>subword_tokenize() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structnvtext_1_1tokenizer__result.html">tokenizer_result</a> nvtext::subword_tokenize </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structnvtext_1_1hashed__vocabulary.html">hashed_vocabulary</a> const &amp; </td>
<td class="paramname"><em>vocabulary_table</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>stride</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>do_lower_case</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>do_truncate</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_num_strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_num_chars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_rows_tensor</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a tokenizer that cleans the text, splits it into tokens and returns token-ids from an input vocabulary. </p>
<p>The strings are first normalized by converting to lower-case, removing punctuation, replacing a select set of multi-byte characters and whitespace characters.</p>
<p>The strings are then tokenized by using whitespace as a delimiter. Consecutive delimiters are ignored. Each token is then assigned a 4-byte token-id mapped from the provided vocabulary table.</p>
<p>Essentially each string is converted into one or more vectors of token-ids in the output column. The total number of these vectors x <code>max_sequence_length</code> is the size of the output column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>stride &gt; max_sequence_length</code> </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>max_sequence_length * max_rows_tensor</code> is larger than the max value for cudf::size_type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>The input strings to tokenize. </td></tr>
<tr><td class="paramname">filename_hashed_vocabulary</td><td>A path to the preprocessed vocab.txt file. Note that this is the file AFTER python/perfect_hash.py has been used for preprocessing. </td></tr>
<tr><td class="paramname">max_sequence_length</td><td>Limit of the number of token-ids per row in final tensor for each string. </td></tr>
<tr><td class="paramname">stride</td><td>Each row in the output token-ids will replicate <code>max_sequence_length - stride</code> the token-ids from the previous row, unless it is the first string. </td></tr>
<tr><td class="paramname">do_lower_case</td><td>If true, the tokenizer will convert uppercase characters in the input stream to lower-case and strip accents from those characters. If false, accented and uppercase characters are not transformed. </td></tr>
<tr><td class="paramname">do_truncate</td><td>If true, the tokenizer will discard all the token-ids after <code>max_sequence_length</code> for each input string. If false, it will use a new row in the output token-ids to continue generating the output. </td></tr>
<tr><td class="paramname">max_num_strings</td><td>Maximum number of input strings for instantiating the tokenizer. Used for allocating temporary working memory on the GPU. If the input contains a larger number of strings, behavior is undefined. </td></tr>
<tr><td class="paramname">max_num_chars</td><td>Maximum number of characters for instantiating the tokenizer. Used for allocating temporary working memory on the GPU. If input contains larger number of characters, behavior is undefined. </td></tr>
<tr><td class="paramname">max_rows_tensor</td><td>Maximum number of rows for the output token-ids expected to be generated by the tokenizer. Used for allocating temporary working memory on the GPU device. If the output generates a larger number of rows, behavior is undefined. </td></tr>
<tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token-ids, attention-mask, and metadata</dd></dl>
<p>This function differs from the one above by only the hashed vocabulary parameter. The file can be pre-loaded using the <a class="el" href="group__nvtext__tokenize.html#ga8603f724aa881a6608d26225a227e795">load_vocabulary_file</a> API and then passed in place of the file name in a call to this API.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">vocabulary_table</td><td>The vocabulary table pre-loaded into this object. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="gad725d85bccf2869740328e42a3db6ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad725d85bccf2869740328e42a3db6ed2">◆ </a></span>subword_tokenize() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structnvtext_1_1tokenizer__result.html">tokenizer_result</a> nvtext::subword_tokenize </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::string const &amp; </td>
<td class="paramname"><em>filename_hashed_vocabulary</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_sequence_length</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>stride</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>do_lower_case</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>do_truncate</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_num_strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_num_chars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">uint32_t </td>
<td class="paramname"><em>max_rows_tensor</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a tokenizer that cleans the text, splits it into tokens and returns token-ids from an input vocabulary. </p>
<p>The strings are first normalized by converting to lower-case, removing punctuation, replacing a select set of multi-byte characters and whitespace characters.</p>
<p>The strings are then tokenized by using whitespace as a delimiter. Consecutive delimiters are ignored. Each token is then assigned a 4-byte token-id mapped from the provided vocabulary table.</p>
<p>Essentially each string is converted into one or more vectors of token-ids in the output column. The total number of these vectors x <code>max_sequence_length</code> is the size of the output column.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>stride &gt; max_sequence_length</code> </td></tr>
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>max_sequence_length * max_rows_tensor</code> is larger than the max value for cudf::size_type</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>The input strings to tokenize. </td></tr>
<tr><td class="paramname">filename_hashed_vocabulary</td><td>A path to the preprocessed vocab.txt file. Note that this is the file AFTER python/perfect_hash.py has been used for preprocessing. </td></tr>
<tr><td class="paramname">max_sequence_length</td><td>Limit of the number of token-ids per row in final tensor for each string. </td></tr>
<tr><td class="paramname">stride</td><td>Each row in the output token-ids will replicate <code>max_sequence_length - stride</code> the token-ids from the previous row, unless it is the first string. </td></tr>
<tr><td class="paramname">do_lower_case</td><td>If true, the tokenizer will convert uppercase characters in the input stream to lower-case and strip accents from those characters. If false, accented and uppercase characters are not transformed. </td></tr>
<tr><td class="paramname">do_truncate</td><td>If true, the tokenizer will discard all the token-ids after <code>max_sequence_length</code> for each input string. If false, it will use a new row in the output token-ids to continue generating the output. </td></tr>
<tr><td class="paramname">max_num_strings</td><td>Maximum number of input strings for instantiating the tokenizer. Used for allocating temporary working memory on the GPU. If the input contains a larger number of strings, behavior is undefined. </td></tr>
<tr><td class="paramname">max_num_chars</td><td>Maximum number of characters for instantiating the tokenizer. Used for allocating temporary working memory on the GPU. If input contains larger number of characters, behavior is undefined. </td></tr>
<tr><td class="paramname">max_rows_tensor</td><td>Maximum number of rows for the output token-ids expected to be generated by the tokenizer. Used for allocating temporary working memory on the GPU device. If the output generates a larger number of rows, behavior is undefined. </td></tr>
<tr><td class="paramname">mr</td><td>Memory resource to allocate any returned objects. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>token-ids, attention-mask, and metadata </dd></dl>
</div>
</div>
<a id="ga5a6377b3226915576a277c291c9abf77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a6377b3226915576a277c291c9abf77">◆ </a></span>tokenize() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::tokenize </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a> const &amp; </td>
<td class="paramname"><em>delimiter</em> = <code><a class="el" href="classcudf_1_1string__scalar.html">cudf::string_scalar</a>{""}</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a single column of strings by tokenizing the input strings column using the provided characters as delimiters. </p>
<p>The <code>delimiter</code> may be zero or more characters. If the <code>delimiter</code> is empty, whitespace (character code-point &lt;= ' ') is used for identifying tokens. Also, any consecutive delimiters found in a string are ignored. This means only non-empty tokens are returned.</p>
<p>Tokens are found by locating delimiter(s) starting at the beginning of each string. As each string is tokenized, the tokens are appended using input column row order to build the output column. That is, tokens found in input row[i] will be placed in the output column directly before tokens found in input row[i+1].</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", "d  e f "]</div>
<div class="line">t = tokenize(s)</div>
<div class="line">t is now ["a", "b", "c", "d", "e", "f"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings column tokenize. </td></tr>
<tr><td class="paramname">delimiter</td><td>UTF-8 characters used to separate each string into tokens. The default of empty string will separate tokens using whitespace. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>
</div>
</div>
<a id="ga86420ed6ea932602cfd195385b153959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86420ed6ea932602cfd195385b153959">◆ </a></span>tokenize() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt;<a class="el" href="classcudf_1_1column.html">cudf::column</a>&gt; nvtext::tokenize </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>strings</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1strings__column__view.html">cudf::strings_column_view</a> const &amp; </td>
<td class="paramname"><em>delimiters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a single column of strings by tokenizing the input strings column using multiple strings as delimiters. </p>
<p>Tokens are found by locating delimiter(s) starting at the beginning of each string. Any consecutive delimiters found in a string are ignored. This means only non-empty tokens are returned.</p>
<p>As each string is tokenized, the tokens are appended using input column row order to build the output column. That is, tokens found in input row[i] will be placed in the output column directly before tokens found in input row[i+1].</p>
<div class="fragment"><div class="line">Example:</div>
<div class="line">s = ["a", "b c", "d.e:f;"]</div>
<div class="line">d = [".", ":", ";"]</div>
<div class="line">t = tokenize(s,d)</div>
<div class="line">t is now ["a", "b c", "d", "e", "f"]</div>
</div><!-- fragment --><p>All null row entries are ignored and the output contains all valid rows.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if the delimiters column is empty or contains nulls.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">strings</td><td>Strings column to tokenize. </td></tr>
<tr><td class="paramname">delimiters</td><td>Strings used to separate individual strings into tokens. </td></tr>
<tr><td class="paramname">mr</td><td>Device memory resource used to allocate the returned column's device memory. </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New strings columns of tokens. </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html"><img alt="doxygen" class="footer" height="31" src="doxygen.svg" width="104"/></a> 1.8.19
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
