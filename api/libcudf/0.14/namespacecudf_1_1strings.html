<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
  <meta content="IE=9" http-equiv="X-UA-Compatible"/>
  <meta content="Doxygen 1.8.16" name="generator"/>
  <meta content="width=device-width, initial-scale=1" name="viewport"/>
  <title>
   libcudf: cudf::strings Namespace Reference
  </title>
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
  <script src="jquery.js" type="text/javascript">
  </script>
  <script src="dynsections.js" type="text/javascript">
  </script>
  <link href="search/search.css" rel="stylesheet" type="text/css"/>
  <script src="search/searchdata.js" type="text/javascript">
  </script>
  <script src="search/search.js" type="text/javascript">
  </script>
  <link href="doxygen.css" rel="stylesheet" type="text/css"/>
  <link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/>
  <link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/>
 </head>
 <body>
  <div id="top">
   <!-- do not remove this div, it is closed by doxygen! -->
   <div id="titlearea">
    <div id="rapids-doxygen-container">
     <div class="rapids-home-container">
      <a class="rapids-home-container__home-btn" href="/api">
       Home
      </a>
     </div>
     <div class="rapids-selector__container rapids-selector--hidden">
      <div class="rapids-selector__selected">
       libcudf
      </div>
      <div class="rapids-selector__menu">
       <a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">
        clx
       </a>
       <a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">
        cudf
       </a>
       <a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">
        cugraph
       </a>
       <a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">
        cuml
       </a>
       <a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">
        cusignal
       </a>
       <a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">
        cuspatial
       </a>
       <a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">
        cuxfilter
       </a>
       <a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">
        libcudf
       </a>
       <a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">
        libnvstrings
       </a>
       <a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">
        nvstrings
       </a>
       <a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">
        rmm
       </a>
      </div>
     </div>
     <div class="rapids-selector__container rapids-selector--hidden">
      <div class="rapids-selector__selected">
       nightly (0.14)
      </div>
      <div class="rapids-selector__menu">
       <a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/nightly/namespacecudf.html">
        nightly (0.14)
       </a>
       <a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">
        stable (0.13)
       </a>
       <a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">
        legacy (0.12)
       </a>
      </div>
     </div>
    </div>
   </div>
   <!-- end header part -->
   <!-- Generated by Doxygen 1.8.16 -->
   <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
   </script>
   <script src="menudata.js" type="text/javascript">
   </script>
   <script src="menu.js" type="text/javascript">
   </script>
   <script type="text/javascript">
    /* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
   </script>
   <div id="main-nav">
   </div>
   <!-- window showing the filter options -->
   <div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
   </div>
   <!-- iframe showing the search results (closed by default) -->
   <div id="MSearchResultsWindow">
    <iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
    </iframe>
   </div>
   <div class="navpath" id="nav-path">
    <ul>
     <li class="navelem">
      <a class="el" href="namespacecudf.html">
       cudf
      </a>
     </li>
     <li class="navelem">
      <a class="el" href="namespacecudf_1_1strings.html">
       strings
      </a>
     </li>
    </ul>
   </div>
  </div>
  <!-- top -->
  <div class="header">
   <div class="summary">
    <a href="#nested-classes">
     Classes
    </a>
    |
    <a href="#enum-members">
     Enumerations
    </a>
    |
    <a href="#func-members">
     Functions
    </a>
   </div>
   <div class="headertitle">
    <div class="title">
     cudf::strings Namespace Reference
    </div>
   </div>
  </div>
  <!--header-->
  <div class="contents">
   <p>
    Strings column APIs.
    <a href="namespacecudf_1_1strings.html#details">
     More...
    </a>
   </p>
   <table class="memberdecls">
    <tr class="heading">
     <td colspan="2">
      <h2 class="groupheader">
       <a name="nested-classes">
       </a>
       Classes
      </h2>
     </td>
    </tr>
    <tr class="memitem:">
     <td align="right" class="memItemLeft" valign="top">
      struct
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html">
       contiguous_split_record_result
      </a>
     </td>
    </tr>
    <tr class="memdesc:">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      The result(s) of a
      <code>
       contiguous_(r)split_record
      </code>
      <a href="structcudf_1_1strings_1_1contiguous__split__record__result.html#details">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
   </table>
   <table class="memberdecls">
    <tr class="heading">
     <td colspan="2">
      <h2 class="groupheader">
       <a name="enum-members">
       </a>
       Enumerations
      </h2>
     </td>
    </tr>
    <tr class="memitem:acdc71043841f369de3cc8dd827a0eea1">
     <td align="right" class="memItemLeft" valign="top">
      enum
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      : uint32_t {
      <br/>
      <b>
       DECIMAL
      </b>
      = 1 &lt;&lt; 0,
      <b>
       NUMERIC
      </b>
      = 1 &lt;&lt; 1,
      <b>
       DIGIT
      </b>
      = 1 &lt;&lt; 2,
      <b>
       ALPHA
      </b>
      = 1 &lt;&lt; 3,
      <br/>
      <b>
       SPACE
      </b>
      = 1 &lt;&lt; 4,
      <b>
       UPPER
      </b>
      = 1 &lt;&lt; 5,
      <b>
       LOWER
      </b>
      = 1 &lt;&lt; 6,
      <b>
       ALPHANUM
      </b>
      = DECIMAL | NUMERIC | DIGIT | ALPHA,
      <br/>
      <b>
       CASE_TYPES
      </b>
      = UPPER | LOWER,
      <b>
       ALL_TYPES
      </b>
      = ALPHANUM | CASE_TYPES | SPACE
      <br/>
      }
     </td>
    </tr>
    <tr class="memdesc:acdc71043841f369de3cc8dd827a0eea1">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Character type values. These types can be or'd to check for any combination of types.
      <a href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:acdc71043841f369de3cc8dd827a0eea1">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ace598ecf9030296eeebfef46251d7d52">
     <td align="right" class="memItemLeft" valign="top">
      enum
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52">
       pad_side
      </a>
      {
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a684d325a7303f52e64011467ff5c5758">
       pad_side::LEFT
      </a>
      ,
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a21507b40c80068eda19865706fdc2403">
       pad_side::RIGHT
      </a>
      ,
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a6328e5e3186c227a021ef2ff77e40197">
       pad_side::BOTH
      </a>
      }
     </td>
    </tr>
    <tr class="memdesc:ace598ecf9030296eeebfef46251d7d52">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Pad types for the pad method specify where the pad character should be placed.
      <a href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ace598ecf9030296eeebfef46251d7d52">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a78f0999f58b7b8d02fd3a10fffca446e">
     <td align="right" class="memItemLeft" valign="top">
      <a id="a78f0999f58b7b8d02fd3a10fffca446e">
      </a>
      enum
     </td>
     <td class="memItemRight" valign="bottom">
      <b>
       strip_type
      </b>
      {
      <b>
       LEFT
      </b>
      ,
      <b>
       RIGHT
      </b>
      ,
      <b>
       BOTH
      </b>
      }
     </td>
    </tr>
    <tr class="separator:a78f0999f58b7b8d02fd3a10fffca446e">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
   </table>
   <table class="memberdecls">
    <tr class="heading">
     <td colspan="2">
      <h2 class="groupheader">
       <a name="func-members">
       </a>
       Functions
      </h2>
     </td>
    </tr>
    <tr class="memitem:ad48a7f33405d2f44b678bf07e96feaa9">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ad48a7f33405d2f44b678bf07e96feaa9">
       count_characters
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ad48a7f33405d2f44b678bf07e96feaa9">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns an integer numeric column containing the length of each string in characters.
      <a href="namespacecudf_1_1strings.html#ad48a7f33405d2f44b678bf07e96feaa9">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ad48a7f33405d2f44b678bf07e96feaa9">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a404c6362b7373210227c9c6e71eb2f8c">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a404c6362b7373210227c9c6e71eb2f8c">
       count_bytes
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a404c6362b7373210227c9c6e71eb2f8c">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a numeric column containing the length of each string in bytes.
      <a href="namespacecudf_1_1strings.html#a404c6362b7373210227c9c6e71eb2f8c">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a404c6362b7373210227c9c6e71eb2f8c">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a5936f03cb3d47800537a9609525b81a5">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a5936f03cb3d47800537a9609525b81a5">
       code_points
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a5936f03cb3d47800537a9609525b81a5">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Creates a numeric column with code point values (integers) for each character of each string.
      <a href="namespacecudf_1_1strings.html#a5936f03cb3d47800537a9609525b81a5">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a5936f03cb3d47800537a9609525b81a5">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a3e39b32c1d4bf35bfd3ca535710a8509">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a3e39b32c1d4bf35bfd3ca535710a8509">
       capitalize
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a3e39b32c1d4bf35bfd3ca535710a8509">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of capitalized strings.
      <a href="namespacecudf_1_1strings.html#a3e39b32c1d4bf35bfd3ca535710a8509">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a3e39b32c1d4bf35bfd3ca535710a8509">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a3cf6aa64c4c6457f858e0caed366315b">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a3cf6aa64c4c6457f858e0caed366315b">
       title
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a3cf6aa64c4c6457f858e0caed366315b">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Modifies first character after spaces to uppercase and lower-cases the rest.
      <a href="namespacecudf_1_1strings.html#a3cf6aa64c4c6457f858e0caed366315b">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a3cf6aa64c4c6457f858e0caed366315b">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a6022f64064a7ccc1a10f734c8abb7a71">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a6022f64064a7ccc1a10f734c8abb7a71">
       to_lower
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a6022f64064a7ccc1a10f734c8abb7a71">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Converts a column of strings to lower case.
      <a href="namespacecudf_1_1strings.html#a6022f64064a7ccc1a10f734c8abb7a71">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a6022f64064a7ccc1a10f734c8abb7a71">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ae842becdab49326d2c47fc563bab3795">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ae842becdab49326d2c47fc563bab3795">
       to_upper
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ae842becdab49326d2c47fc563bab3795">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Converts a column of strings to upper case.
      <a href="namespacecudf_1_1strings.html#ae842becdab49326d2c47fc563bab3795">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ae842becdab49326d2c47fc563bab3795">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ae2a602f729fda3c72af8e1b9f9d59490">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ae2a602f729fda3c72af8e1b9f9d59490">
       swapcase
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ae2a602f729fda3c72af8e1b9f9d59490">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of strings converting lower case characters to upper case and vice versa.
      <a href="namespacecudf_1_1strings.html#ae2a602f729fda3c72af8e1b9f9d59490">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ae2a602f729fda3c72af8e1b9f9d59490">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a58122989a4651f836b433ec79dba7282">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a58122989a4651f836b433ec79dba7282">
       all_characters_of_type
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      types,
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      verify_types=string_character_types::ALL_TYPES, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a58122989a4651f836b433ec79dba7282">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a boolean column identifying strings entries in which all characters are of the type specified.
      <a href="namespacecudf_1_1strings.html#a58122989a4651f836b433ec79dba7282">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a58122989a4651f836b433ec79dba7282">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a061db2a9c22ec802896de4f7daa83c05">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a061db2a9c22ec802896de4f7daa83c05">
       is_integer
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a061db2a9c22ec802896de4f7daa83c05">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a boolean column identifying strings in which all characters are valid for conversion to integers.
      <a href="namespacecudf_1_1strings.html#a061db2a9c22ec802896de4f7daa83c05">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a061db2a9c22ec802896de4f7daa83c05">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a4be4ba0a0ae6fd1b935c154c79391f54">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a4be4ba0a0ae6fd1b935c154c79391f54">
       is_float
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a4be4ba0a0ae6fd1b935c154c79391f54">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a boolean column identifying strings in which all characters are valid for conversion to floats.
      <a href="namespacecudf_1_1strings.html#a4be4ba0a0ae6fd1b935c154c79391f54">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a4be4ba0a0ae6fd1b935c154c79391f54">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a744918490d90e43a0623da01dd314a13">
     <td align="right" class="memItemLeft" valign="top">
      bool
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a744918490d90e43a0623da01dd314a13">
       all_integer
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a744918490d90e43a0623da01dd314a13">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns
      <code>
       true
      </code>
      if all strings contain characters that are valid for conversion to integers.
      <a href="namespacecudf_1_1strings.html#a744918490d90e43a0623da01dd314a13">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a744918490d90e43a0623da01dd314a13">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ac184249f797a671de763c8bec54e709c">
     <td align="right" class="memItemLeft" valign="top">
      bool
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ac184249f797a671de763c8bec54e709c">
       all_float
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ac184249f797a671de763c8bec54e709c">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns
      <code>
       true
      </code>
      if all strings contain characters that are valid for conversion to floats.
      <a href="namespacecudf_1_1strings.html#ac184249f797a671de763c8bec54e709c">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ac184249f797a671de763c8bec54e709c">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a4fd98e6c74474f5686abe7df409e7d0e">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a4fd98e6c74474f5686abe7df409e7d0e">
       concatenate
      </a>
      (
      <a class="el" href="classcudf_1_1table__view.html">
       table_view
      </a>
      const  &amp;strings_columns,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;separator=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""),
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;narep=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      ("", false), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a4fd98e6c74474f5686abe7df409e7d0e">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Row-wise concatenates the given list of strings columns and returns a single strings column result.
      <a href="namespacecudf_1_1strings.html#a4fd98e6c74474f5686abe7df409e7d0e">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a4fd98e6c74474f5686abe7df409e7d0e">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ab6a77478fadde8b86e5a165283db03d3">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ab6a77478fadde8b86e5a165283db03d3">
       join_strings
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;separator=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""),
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;narep=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      ("", false), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ab6a77478fadde8b86e5a165283db03d3">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Concatenates all strings in the column into one new string delimited by an optional separator string.
      <a href="namespacecudf_1_1strings.html#ab6a77478fadde8b86e5a165283db03d3">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ab6a77478fadde8b86e5a165283db03d3">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a8925af03b35ed4c4f83e9e8af356ccca">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a8925af03b35ed4c4f83e9e8af356ccca">
       contains_re
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a8925af03b35ed4c4f83e9e8af356ccca">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a boolean column identifying rows which match the given regex pattern.
      <a href="namespacecudf_1_1strings.html#a8925af03b35ed4c4f83e9e8af356ccca">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a8925af03b35ed4c4f83e9e8af356ccca">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:af1ae53e101b1a37652d05f18860d8fc2">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#af1ae53e101b1a37652d05f18860d8fc2">
       matches_re
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:af1ae53e101b1a37652d05f18860d8fc2">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a boolean column identifying rows which matching the given regex pattern but only at the beginning the string.
      <a href="namespacecudf_1_1strings.html#af1ae53e101b1a37652d05f18860d8fc2">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:af1ae53e101b1a37652d05f18860d8fc2">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a6e79229088d2c0384f91e51817bb431e">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a6e79229088d2c0384f91e51817bb431e">
       count_re
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a6e79229088d2c0384f91e51817bb431e">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns the number of times the given regex pattern matches in each string.
      <a href="namespacecudf_1_1strings.html#a6e79229088d2c0384f91e51817bb431e">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a6e79229088d2c0384f91e51817bb431e">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a48824af0efa0b6a27a873479efc1e224">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a48824af0efa0b6a27a873479efc1e224">
       to_booleans
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;true_string=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      ("true"), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a48824af0efa0b6a27a873479efc1e224">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new BOOL8 column by parsing boolean values from the strings in the provided strings column.
      <a href="namespacecudf_1_1strings.html#a48824af0efa0b6a27a873479efc1e224">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a48824af0efa0b6a27a873479efc1e224">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:af51463805e485ceee75ab1cab6a53f18">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#af51463805e485ceee75ab1cab6a53f18">
       from_booleans
      </a>
      (
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;booleans,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;true_string=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      ("true"), string_scalar const  &amp;false_string=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      ("false"), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:af51463805e485ceee75ab1cab6a53f18">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new strings column converting the boolean values from the provided column into strings.
      <a href="namespacecudf_1_1strings.html#af51463805e485ceee75ab1cab6a53f18">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:af51463805e485ceee75ab1cab6a53f18">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a9c8dd7fe42bcd7e0f615e730dfe0593a">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       cudf::column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a9c8dd7fe42bcd7e0f615e730dfe0593a">
       to_timestamps
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1data__type.html">
       data_type
      </a>
      timestamp_type, std::string const  &amp;format, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a9c8dd7fe42bcd7e0f615e730dfe0593a">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new timestamp column converting a strings column into timestamps using the provided format pattern.
      <a href="namespacecudf_1_1strings.html#a9c8dd7fe42bcd7e0f615e730dfe0593a">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a9c8dd7fe42bcd7e0f615e730dfe0593a">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:af0b5b7984fdc62ee46929dbecdfa55aa">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#af0b5b7984fdc62ee46929dbecdfa55aa">
       from_timestamps
      </a>
      (
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;timestamps, std::string const  &amp;format="%Y-%m-%dT%H:%M:%SZ", rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:af0b5b7984fdc62ee46929dbecdfa55aa">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new strings column converting a timestamp column into strings using the provided format pattern.
      <a href="namespacecudf_1_1strings.html#af0b5b7984fdc62ee46929dbecdfa55aa">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:af0b5b7984fdc62ee46929dbecdfa55aa">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ab616b3d651ce28bea4ae3ac8f9c9c92a">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ab616b3d651ce28bea4ae3ac8f9c9c92a">
       to_floats
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1data__type.html">
       data_type
      </a>
      output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ab616b3d651ce28bea4ae3ac8f9c9c92a">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new numeric column by parsing float values from each string in the provided strings column.
      <a href="namespacecudf_1_1strings.html#ab616b3d651ce28bea4ae3ac8f9c9c92a">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ab616b3d651ce28bea4ae3ac8f9c9c92a">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:adf9aa5ef3ae6d635ecd8b386e703f189">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#adf9aa5ef3ae6d635ecd8b386e703f189">
       from_floats
      </a>
      (
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;floats, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:adf9aa5ef3ae6d635ecd8b386e703f189">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new strings column converting the float values from the provided column into strings.
      <a href="namespacecudf_1_1strings.html#adf9aa5ef3ae6d635ecd8b386e703f189">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:adf9aa5ef3ae6d635ecd8b386e703f189">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:abb12a54db56fb4e7d5cdc417ef914945">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#abb12a54db56fb4e7d5cdc417ef914945">
       hex_to_integers
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1data__type.html">
       data_type
      </a>
      output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:abb12a54db56fb4e7d5cdc417ef914945">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new integer numeric column parsing hexadecimal values from the provided strings column.
      <a href="namespacecudf_1_1strings.html#abb12a54db56fb4e7d5cdc417ef914945">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:abb12a54db56fb4e7d5cdc417ef914945">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ab5c7bb70d5d915636847e0d1831eba3b">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ab5c7bb70d5d915636847e0d1831eba3b">
       to_integers
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1data__type.html">
       data_type
      </a>
      output_type, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ab5c7bb70d5d915636847e0d1831eba3b">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new integer numeric column parsing integer values from the provided strings column.
      <a href="namespacecudf_1_1strings.html#ab5c7bb70d5d915636847e0d1831eba3b">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ab5c7bb70d5d915636847e0d1831eba3b">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:af82b9b754e250e72d813b4a317c1a87d">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#af82b9b754e250e72d813b4a317c1a87d">
       from_integers
      </a>
      (
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;integers, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:af82b9b754e250e72d813b4a317c1a87d">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new strings column converting the integer values from the provided column into strings.
      <a href="namespacecudf_1_1strings.html#af82b9b754e250e72d813b4a317c1a87d">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:af82b9b754e250e72d813b4a317c1a87d">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a27b917bcbd11873c8b63d14dbb1900b4">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a27b917bcbd11873c8b63d14dbb1900b4">
       ipv4_to_integers
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a27b917bcbd11873c8b63d14dbb1900b4">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Converts IPv4 addresses into integers.
      <a href="namespacecudf_1_1strings.html#a27b917bcbd11873c8b63d14dbb1900b4">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a27b917bcbd11873c8b63d14dbb1900b4">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:af2504d06552234f412049d370f2aef68">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#af2504d06552234f412049d370f2aef68">
       integers_to_ipv4
      </a>
      (
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;integers, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:af2504d06552234f412049d370f2aef68">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Converts integers into IPv4 addresses as strings.
      <a href="namespacecudf_1_1strings.html#af2504d06552234f412049d370f2aef68">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:af2504d06552234f412049d370f2aef68">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:adb3b94151cb452ee3b2daf3f8dbccb54">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#adb3b94151cb452ee3b2daf3f8dbccb54">
       url_encode
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:adb3b94151cb452ee3b2daf3f8dbccb54">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Decodes each string using URL encoding.
      <a href="namespacecudf_1_1strings.html#adb3b94151cb452ee3b2daf3f8dbccb54">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:adb3b94151cb452ee3b2daf3f8dbccb54">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a02d12fd316da740b8975b19ff1757add">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a02d12fd316da740b8975b19ff1757add">
       url_decode
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a02d12fd316da740b8975b19ff1757add">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Encodes each string using URL encoding.
      <a href="namespacecudf_1_1strings.html#a02d12fd316da740b8975b19ff1757add">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a02d12fd316da740b8975b19ff1757add">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a8c5b1014dcd65e3ebbd00a57c26a5ce6">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1experimental_1_1table.html">
       experimental::table
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a8c5b1014dcd65e3ebbd00a57c26a5ce6">
       extract
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a8c5b1014dcd65e3ebbd00a57c26a5ce6">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a vector of strings columns for each matching group specified in the given regular expression pattern.
      <a href="namespacecudf_1_1strings.html#a8c5b1014dcd65e3ebbd00a57c26a5ce6">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a8c5b1014dcd65e3ebbd00a57c26a5ce6">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a8897022e900a9eb090cbd09652e75658">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a8897022e900a9eb090cbd09652e75658">
       find
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;target, size_type start=0, size_type stop=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a8897022e900a9eb090cbd09652e75658">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of character position values where the target string is first found in each string of the provided column.
      <a href="namespacecudf_1_1strings.html#a8897022e900a9eb090cbd09652e75658">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a8897022e900a9eb090cbd09652e75658">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ac216eaea55fe9d42b44aae9c0387d329">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ac216eaea55fe9d42b44aae9c0387d329">
       rfind
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;target, size_type start=0, size_type stop=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ac216eaea55fe9d42b44aae9c0387d329">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of character position values where the target string is first found searching from the end of each string.
      <a href="namespacecudf_1_1strings.html#ac216eaea55fe9d42b44aae9c0387d329">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ac216eaea55fe9d42b44aae9c0387d329">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a6761e18983d2a3279525264407273f18">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a6761e18983d2a3279525264407273f18">
       contains
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a6761e18983d2a3279525264407273f18">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of boolean values for each string where true indicates the target string was found within that string in the provided column.
      <a href="namespacecudf_1_1strings.html#a6761e18983d2a3279525264407273f18">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a6761e18983d2a3279525264407273f18">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a2ce720bbd79edf6247dbb0c804a613d8">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a2ce720bbd79edf6247dbb0c804a613d8">
       starts_with
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a2ce720bbd79edf6247dbb0c804a613d8">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of boolean values for each string where true indicates the target string was found at the beginning of that string in the provided column.
      <a href="namespacecudf_1_1strings.html#a2ce720bbd79edf6247dbb0c804a613d8">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a2ce720bbd79edf6247dbb0c804a613d8">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a30ad0531aeb055967492897851ec5828">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a30ad0531aeb055967492897851ec5828">
       ends_with
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;target, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a30ad0531aeb055967492897851ec5828">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column of boolean values for each string where true indicates the target string was found at the end of that string in the provided column.
      <a href="namespacecudf_1_1strings.html#a30ad0531aeb055967492897851ec5828">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a30ad0531aeb055967492897851ec5828">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:aa14e7275a271183be10919c1042516e7">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#aa14e7275a271183be10919c1042516e7">
       find_multiple
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;targets, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:aa14e7275a271183be10919c1042516e7">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a column with character position values where each of the target strings are found in each string.
      <a href="namespacecudf_1_1strings.html#aa14e7275a271183be10919c1042516e7">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:aa14e7275a271183be10919c1042516e7">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a29cc2e88078299ddac5ceb379a5c367d">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1experimental_1_1table.html">
       experimental::table
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a29cc2e88078299ddac5ceb379a5c367d">
       findall_re
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a29cc2e88078299ddac5ceb379a5c367d">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a table of strings columns for each matching occurrence of the regex pattern within each string.
      <a href="namespacecudf_1_1strings.html#a29cc2e88078299ddac5ceb379a5c367d">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a29cc2e88078299ddac5ceb379a5c367d">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a4f1989aea0aa5e69c1b8559811877570">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a4f1989aea0aa5e69c1b8559811877570">
       pad
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, size_type width,
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52">
       pad_side
      </a>
      side=
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a21507b40c80068eda19865706fdc2403">
       cudf::strings::pad_side::RIGHT
      </a>
      , std::string const  &amp;fill_char=" ", rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a4f1989aea0aa5e69c1b8559811877570">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Add padding to each string using a provided character.
      <a href="namespacecudf_1_1strings.html#a4f1989aea0aa5e69c1b8559811877570">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a4f1989aea0aa5e69c1b8559811877570">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a4d265b414cf6c921ff7ceabc99aeef57">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a4d265b414cf6c921ff7ceabc99aeef57">
       zfill
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, size_type width, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a4d265b414cf6c921ff7ceabc99aeef57">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Add '0' as padding to the left of each string.
      <a href="namespacecudf_1_1strings.html#a4d265b414cf6c921ff7ceabc99aeef57">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a4d265b414cf6c921ff7ceabc99aeef57">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a248c4ad6bc61163e98e214bb0d07f755">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a248c4ad6bc61163e98e214bb0d07f755">
       replace_with_backrefs
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern, std::string const  &amp;repl, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a248c4ad6bc61163e98e214bb0d07f755">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      For each string, replaces any character sequence matching the given pattern using the repl template for back-references.
      <a href="namespacecudf_1_1strings.html#a248c4ad6bc61163e98e214bb0d07f755">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a248c4ad6bc61163e98e214bb0d07f755">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:aae51810f464e8dd637d4f297ca49caae">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#aae51810f464e8dd637d4f297ca49caae">
       replace_re
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::vector&lt; std::string &gt; const  &amp;patterns,
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;repls, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:aae51810f464e8dd637d4f297ca49caae">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      For each string, replaces any character sequence matching the given patterns with the corresponding string in the repls column.
      <a href="namespacecudf_1_1strings.html#aae51810f464e8dd637d4f297ca49caae">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:aae51810f464e8dd637d4f297ca49caae">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a452d1ce407f311d8b22d226db9a5b1b7">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
       replace
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;target,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;repl, int32_t maxrepl=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a452d1ce407f311d8b22d226db9a5b1b7">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Replaces target string within each string with the specified replacement string.
      <a href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a452d1ce407f311d8b22d226db9a5b1b7">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a18d7f0468ef567600563b0493e573dd1">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a18d7f0468ef567600563b0493e573dd1">
       replace_slice
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;repl=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), size_type start=0, size_type stop=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a18d7f0468ef567600563b0493e573dd1">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      This function replaces each string in the column with the provided repl string within the [start,stop) character position range.
      <a href="namespacecudf_1_1strings.html#a18d7f0468ef567600563b0493e573dd1">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a18d7f0468ef567600563b0493e573dd1">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ae6afeee7c45704c3ae7e7aba8935b6b3">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#ae6afeee7c45704c3ae7e7aba8935b6b3">
       replace
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;targets,
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;repls, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:ae6afeee7c45704c3ae7e7aba8935b6b3">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Replaces substrings matching a list of targets with the corresponding replacement strings.
      <a href="namespacecudf_1_1strings.html#ae6afeee7c45704c3ae7e7aba8935b6b3">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:ae6afeee7c45704c3ae7e7aba8935b6b3">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:acf8d376612ac5b0d7f524806b0d4b65b">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#acf8d376612ac5b0d7f524806b0d4b65b">
       replace_nulls
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;repl=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:acf8d376612ac5b0d7f524806b0d4b65b">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Replaces any null string entries with the given string.
      <a href="namespacecudf_1_1strings.html#acf8d376612ac5b0d7f524806b0d4b65b">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:acf8d376612ac5b0d7f524806b0d4b65b">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a4340ab9c096dd15df8d9d570b24cc4a6">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a4340ab9c096dd15df8d9d570b24cc4a6">
       replace_re
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::string const  &amp;pattern,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;repl=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), size_type maxrepl=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a4340ab9c096dd15df8d9d570b24cc4a6">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      For each string, replaces any character sequence matching the given pattern with the provided replacement string.
      <a href="namespacecudf_1_1strings.html#a4340ab9c096dd15df8d9d570b24cc4a6">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a4340ab9c096dd15df8d9d570b24cc4a6">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a3129796eee80274dee431b993862ef89">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1experimental_1_1table.html">
       experimental::table
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a3129796eee80274dee431b993862ef89">
       partition
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;delimiter=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a3129796eee80274dee431b993862ef89">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a set of 3 columns by splitting each string using the specified delimiter.
      <a href="namespacecudf_1_1strings.html#a3129796eee80274dee431b993862ef89">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a3129796eee80274dee431b993862ef89">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a024af33f3d9718f6990e0ef4581bf77a">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1experimental_1_1table.html">
       experimental::table
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a024af33f3d9718f6990e0ef4581bf77a">
       rpartition
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;delimiter=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a024af33f3d9718f6990e0ef4581bf77a">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a set of 3 columns by splitting each string using the specified delimiter starting from the end of each string.
      <a href="namespacecudf_1_1strings.html#a024af33f3d9718f6990e0ef4581bf77a">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a024af33f3d9718f6990e0ef4581bf77a">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a3f6d9db5eb39e7ccc69accfaed9b903e">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1experimental_1_1table.html">
       experimental::table
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a3f6d9db5eb39e7ccc69accfaed9b903e">
       split
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;delimiter=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), size_type maxsplit=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a3f6d9db5eb39e7ccc69accfaed9b903e">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a list of columns by splitting each string using the specified delimiter.
      <a href="namespacecudf_1_1strings.html#a3f6d9db5eb39e7ccc69accfaed9b903e">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a3f6d9db5eb39e7ccc69accfaed9b903e">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a57a8e41a67727b9953f01b939dba70f7">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1experimental_1_1table.html">
       experimental::table
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a57a8e41a67727b9953f01b939dba70f7">
       rsplit
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;delimiter=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), size_type maxsplit=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a57a8e41a67727b9953f01b939dba70f7">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a list of columns by splitting each string using the specified delimiter starting from the end of each string.
      <a href="namespacecudf_1_1strings.html#a57a8e41a67727b9953f01b939dba70f7">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a57a8e41a67727b9953f01b939dba70f7">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:aa495a3dc10581c01f3b24713826cc280">
     <td align="right" class="memItemLeft" valign="top">
      <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html">
       contiguous_split_record_result
      </a>
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#aa495a3dc10581c01f3b24713826cc280">
       contiguous_split_record
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;delimiter=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), size_type maxsplit=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:aa495a3dc10581c01f3b24713826cc280">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Splits each element of the input column to a column of tokens storing the resulting columns in a single contiguous block of memory.
      <a href="namespacecudf_1_1strings.html#aa495a3dc10581c01f3b24713826cc280">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:aa495a3dc10581c01f3b24713826cc280">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a2b94f191051e2e9d0c2d151741da1411">
     <td align="right" class="memItemLeft" valign="top">
      <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html">
       contiguous_split_record_result
      </a>
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a2b94f191051e2e9d0c2d151741da1411">
       contiguous_rsplit_record
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;delimiter=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), size_type maxsplit=-1, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a2b94f191051e2e9d0c2d151741da1411">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Splits each element of the input column from the end to a column of tokens storing the resulting columns in a single contiguous block of memory.
      <a href="namespacecudf_1_1strings.html#a2b94f191051e2e9d0c2d151741da1411">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a2b94f191051e2e9d0c2d151741da1411">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:af21802cd4e0d683a803469d83ef73076">
     <td align="right" class="memItemLeft" valign="top">
      void
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#af21802cd4e0d683a803469d83ef73076">
       print
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, size_type start=0, size_type end=-1, size_type max_width=-1, const char *delimiter="\n")
     </td>
    </tr>
    <tr class="memdesc:af21802cd4e0d683a803469d83ef73076">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Prints the strings to stdout.
      <a href="namespacecudf_1_1strings.html#af21802cd4e0d683a803469d83ef73076">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:af21802cd4e0d683a803469d83ef73076">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a1543a5ccc995db83c1ba9ea5ecd8831b">
     <td align="right" class="memItemLeft" valign="top">
      std::pair&lt; rmm::device_vector&lt; char &gt;, rmm::device_vector&lt; size_type &gt; &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a1543a5ccc995db83c1ba9ea5ecd8831b">
       create_offsets
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">
       cudaStream_t
      </a>
      stream=0, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a1543a5ccc995db83c1ba9ea5ecd8831b">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Create output per Arrow strings format.
      <a href="namespacecudf_1_1strings.html#a1543a5ccc995db83c1ba9ea5ecd8831b">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a1543a5ccc995db83c1ba9ea5ecd8831b">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:afeeda8580beff9f9f486fbc540e8e2b4">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#afeeda8580beff9f9f486fbc540e8e2b4">
       strip
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, strip_type stype=
      <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a6328e5e3186c227a021ef2ff77e40197">
       strip_type::BOTH
      </a>
      ,
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      const  &amp;to_strip=
      <a class="el" href="classcudf_1_1string__scalar.html">
       string_scalar
      </a>
      (""), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:afeeda8580beff9f9f486fbc540e8e2b4">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Removes the specified characters from the beginning or end (or both) of each string.
      <a href="namespacecudf_1_1strings.html#afeeda8580beff9f9f486fbc540e8e2b4">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:afeeda8580beff9f9f486fbc540e8e2b4">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a1852eb5dc4ff8373934038c720bcbf97">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a1852eb5dc4ff8373934038c720bcbf97">
       slice_strings
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1numeric__scalar.html">
       numeric_scalar
      </a>
      &lt; size_type &gt; const  &amp;start=
      <a class="el" href="classcudf_1_1numeric__scalar.html">
       numeric_scalar
      </a>
      &lt; size_type &gt;(0, false),
      <a class="el" href="classcudf_1_1numeric__scalar.html">
       numeric_scalar
      </a>
      &lt; size_type &gt; const  &amp;stop=
      <a class="el" href="classcudf_1_1numeric__scalar.html">
       numeric_scalar
      </a>
      &lt; size_type &gt;(0, false),
      <a class="el" href="classcudf_1_1numeric__scalar.html">
       numeric_scalar
      </a>
      &lt; size_type &gt; const  &amp;step=
      <a class="el" href="classcudf_1_1numeric__scalar.html">
       numeric_scalar
      </a>
      &lt; size_type &gt;(1), rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a1852eb5dc4ff8373934038c720bcbf97">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new strings column that contains substrings of the strings in the provided column.
      <a href="namespacecudf_1_1strings.html#a1852eb5dc4ff8373934038c720bcbf97">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a1852eb5dc4ff8373934038c720bcbf97">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a7c2d10a08ed8bfd9174936afe8236d5b">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a7c2d10a08ed8bfd9174936afe8236d5b">
       slice_strings
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings,
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;starts,
      <a class="el" href="classcudf_1_1column__view.html">
       column_view
      </a>
      const  &amp;stops, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a7c2d10a08ed8bfd9174936afe8236d5b">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Returns a new strings column that contains substrings of the strings in the provided column using unique ranges for each string.
      <a href="namespacecudf_1_1strings.html#a7c2d10a08ed8bfd9174936afe8236d5b">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a7c2d10a08ed8bfd9174936afe8236d5b">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a50d5f0b7b88e886b137e23370b7a8045">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#a50d5f0b7b88e886b137e23370b7a8045">
       translate
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, std::vector&lt; std::pair&lt; char_utf8, char_utf8 &gt;&gt; const  &amp;chars_table, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:a50d5f0b7b88e886b137e23370b7a8045">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Translates individual characters within each string.
      <a href="namespacecudf_1_1strings.html#a50d5f0b7b88e886b137e23370b7a8045">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:a50d5f0b7b88e886b137e23370b7a8045">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:afe8a9627c637f2ad8068de95bae147c7">
     <td align="right" class="memItemLeft" valign="top">
      std::unique_ptr&lt;
      <a class="el" href="classcudf_1_1column.html">
       column
      </a>
      &gt;
     </td>
     <td class="memItemRight" valign="bottom">
      <a class="el" href="namespacecudf_1_1strings.html#afe8a9627c637f2ad8068de95bae147c7">
       wrap
      </a>
      (
      <a class="el" href="classcudf_1_1strings__column__view.html">
       strings_column_view
      </a>
      const  &amp;strings, size_type width, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())
     </td>
    </tr>
    <tr class="memdesc:afe8a9627c637f2ad8068de95bae147c7">
     <td class="mdescLeft">
     </td>
     <td class="mdescRight">
      Wraps strings onto multiple lines shorter than
      <code>
       width
      </code>
      by replacing appropriate white space with new-line characters (ASCII 0x0A).
      <a href="namespacecudf_1_1strings.html#afe8a9627c637f2ad8068de95bae147c7">
       More...
      </a>
      <br/>
     </td>
    </tr>
    <tr class="separator:afe8a9627c637f2ad8068de95bae147c7">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:a15dae9eef4c4616ffdc6711b8a8244f6">
     <td align="right" class="memItemLeft" valign="top">
      <a id="a15dae9eef4c4616ffdc6711b8a8244f6">
      </a>
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
     </td>
     <td class="memItemRight" valign="bottom">
      <b>
       operator|
      </b>
      (
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      lhs,
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      rhs)
     </td>
    </tr>
    <tr class="separator:a15dae9eef4c4616ffdc6711b8a8244f6">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
    <tr class="memitem:ab5013a5b428092810b9af777652e864f">
     <td align="right" class="memItemLeft" valign="top">
      <a id="ab5013a5b428092810b9af777652e864f">
      </a>
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      &amp;
     </td>
     <td class="memItemRight" valign="bottom">
      <b>
       operator|=
      </b>
      (
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      &amp;lhs,
      <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
       string_character_types
      </a>
      rhs)
     </td>
    </tr>
    <tr class="separator:ab5013a5b428092810b9af777652e864f">
     <td class="memSeparator" colspan="2">
     </td>
    </tr>
   </table>
   <a id="details" name="details">
   </a>
   <h2 class="groupheader">
    Detailed Description
   </h2>
   <div class="textblock">
    <p>
     Strings column APIs.
    </p>
   </div>
   <h2 class="groupheader">
    Enumeration Type Documentation
   </h2>
   <a id="ace598ecf9030296eeebfef46251d7d52">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ace598ecf9030296eeebfef46251d7d52">
      ◆
     </a>
    </span>
    pad_side
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="mlabels">
      <tr>
       <td class="mlabels-left">
        <table class="memname">
         <tr>
          <td class="memname">
           enum
           <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52">
            cudf::strings::pad_side
           </a>
          </td>
         </tr>
        </table>
       </td>
       <td class="mlabels-right">
        <span class="mlabels">
         <span class="mlabel">
          strong
         </span>
        </span>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Pad types for the pad method specify where the pad character should be placed.
     </p>
     <table class="fieldtable">
      <tr>
       <th colspan="2">
        Enumerator
       </th>
      </tr>
      <tr>
       <td class="fieldname">
        <a id="ace598ecf9030296eeebfef46251d7d52a684d325a7303f52e64011467ff5c5758">
        </a>
        LEFT
       </td>
       <td class="fielddoc">
        <p>
         Add padding to the left.
        </p>
       </td>
      </tr>
      <tr>
       <td class="fieldname">
        <a id="ace598ecf9030296eeebfef46251d7d52a21507b40c80068eda19865706fdc2403">
        </a>
        RIGHT
       </td>
       <td class="fielddoc">
        <p>
         Add padding to the right.
        </p>
       </td>
      </tr>
      <tr>
       <td class="fieldname">
        <a id="ace598ecf9030296eeebfef46251d7d52a6328e5e3186c227a021ef2ff77e40197">
        </a>
        BOTH
       </td>
       <td class="fielddoc">
        <p>
         Add padding equally to the right and left.
        </p>
       </td>
      </tr>
     </table>
    </div>
   </div>
   <a id="acdc71043841f369de3cc8dd827a0eea1">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#acdc71043841f369de3cc8dd827a0eea1">
      ◆
     </a>
    </span>
    string_character_types
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        enum
        <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
         cudf::strings::string_character_types
        </a>
        : uint32_t
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Character type values. These types can be or'd to check for any combination of types.
     </p>
     <p>
      This cannot be turned into an enum class because or'd entries can result in values that are not in the class. For example, combining NUMERIC|SPACE is a valid, reasonable combination but does not match to any explicitly named enumerator.
     </p>
    </div>
   </div>
   <h2 class="groupheader">
    Function Documentation
   </h2>
   <a id="a58122989a4651f836b433ec79dba7282">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a58122989a4651f836b433ec79dba7282">
      ◆
     </a>
    </span>
    all_characters_of_type()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::all_characters_of_type
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
         string_character_types
        </a>
       </td>
       <td class="paramname">
        <em>
         types
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="namespacecudf_1_1strings.html#acdc71043841f369de3cc8dd827a0eea1">
         string_character_types
        </a>
       </td>
       <td class="paramname">
        <em>
         verify_types
        </em>
        =
        <code>
         string_character_types::ALL_TYPES
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a boolean column identifying strings entries in which all characters are of the type specified.
     </p>
     <p>
      The output row entry will be set to false if the corresponding string element is empty or has at least one character not of the specified type. If all characters fit the type then true is set in that output row entry.
     </p>
     <p>
      To ignore all but specific types, set the
      <code>
       verify_types
      </code>
      to those types which should be checked. Otherwise, the default ALL_TYPES will verify all characters match
      <code>
       types
      </code>
      .
     </p>
     <div class="fragment">
      <div class="line">
       Example:
      </div>
      <div class="line">
       s = [
       <span class="stringliteral">
        'ab'
       </span>
       ,
       <span class="stringliteral">
        'a b'
       </span>
       ,
       <span class="stringliteral">
        'a7'
       </span>
       ,
       <span class="stringliteral">
        'a B'
       </span>
       ]
      </div>
      <div class="line">
       b1 = s.all_characters_of_type(s,LOWER)
      </div>
      <div class="line">
       b1 is [
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ]
      </div>
      <div class="line">
       b2 = s.all_characters_of_type(s,LOWER,LOWER|UPPER)
      </div>
      <div class="line">
       b2 is [
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Any null row results in a null entry for that row in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          types
         </td>
         <td>
          The character types to check in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          verify_types
         </td>
         <td>
          Only verify against these character types. Default
          <code>
           ALL_TYPES
          </code>
          means return
          <code>
           true
          </code>
          iff all characters match
          <code>
           types
          </code>
          .
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of boolean results for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ac184249f797a671de763c8bec54e709c">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ac184249f797a671de763c8bec54e709c">
      ◆
     </a>
    </span>
    all_float()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        bool cudf::strings::all_float
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns
      <code>
       true
      </code>
      if all strings contain characters that are valid for conversion to floats.
     </p>
     <p>
      This function will return
      <code>
       true
      </code>
      if all string elements has at least one character in [-+0-9eE.].
     </p>
     <p>
      Any null entry or empty string will cause this function to return
      <code>
       false
      </code>
      .
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       true if all string are valid
      </dd>
     </dl>
    </div>
   </div>
   <a id="a744918490d90e43a0623da01dd314a13">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a744918490d90e43a0623da01dd314a13">
      ◆
     </a>
    </span>
    all_integer()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        bool cudf::strings::all_integer
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns
      <code>
       true
      </code>
      if all strings contain characters that are valid for conversion to integers.
     </p>
     <p>
      This function will return
      <code>
       true
      </code>
      if all string elements has at least one character in [-+0-9].
     </p>
     <p>
      Any null entry or empty string will cause this function to return
      <code>
       false
      </code>
      .
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       true if all string are valid
      </dd>
     </dl>
    </div>
   </div>
   <a id="a3e39b32c1d4bf35bfd3ca535710a8509">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a3e39b32c1d4bf35bfd3ca535710a8509">
      ◆
     </a>
    </span>
    capitalize()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::capitalize
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of capitalized strings.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <p>
      Example:
     </p>
     <div class="fragment">
      <div class="line">
       input_string_tbl = [
       <span class="stringliteral">
        "tesT1"
       </span>
       ,
       <span class="stringliteral">
        "a Test"
       </span>
       ,
       <span class="stringliteral">
        "Another Test"
       </span>
       ];
      </div>
      <div class="line">
      </div>
      <div class="line">
       capt_string_tbl = [
       <span class="stringliteral">
        "Test1"
       </span>
       ,
       <span class="stringliteral">
        "A test"
       </span>
       ,
       <span class="stringliteral">
        "Another test"
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          strings
         </td>
         <td>
          String column.
         </td>
        </tr>
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       Column of strings capitalized from the input column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a5936f03cb3d47800537a9609525b81a5">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a5936f03cb3d47800537a9609525b81a5">
      ◆
     </a>
    </span>
    code_points()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::code_points
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Creates a numeric column with code point values (integers) for each character of each string.
     </p>
     <p>
      A code point is the integer value representation of a character. For example, the code point value for the character 'A' in UTF-8 is 65.
     </p>
     <p>
      The size of the output column will be the total number of characters in the strings column.
     </p>
     <p>
      Any null string is ignored. No null entries will appear in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New INT32 column with code point integer values for each character.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a4fd98e6c74474f5686abe7df409e7d0e">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a4fd98e6c74474f5686abe7df409e7d0e">
      ◆
     </a>
    </span>
    concatenate()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::concatenate
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1table__view.html">
         table_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings_columns
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         separator
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         narep
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("", false)
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Row-wise concatenates the given list of strings columns and returns a single strings column result.
     </p>
     <p>
      Each new string is created by concatenating the strings from the same row delimited by the separator provided.
     </p>
     <p>
      Any row with a null entry will result in the corresponding output row to be null entry unless a narep string is specified to be used in its place.
     </p>
     <p>
      The number of strings in the columns provided must be the same.
     </p>
     <div class="fragment">
      <div class="line">
       s1 = [
       <span class="stringliteral">
        'aa'
       </span>
       ,
       <span class="keyword">
        null
       </span>
       ,
       <span class="stringliteral">
        ''
       </span>
       ,
       <span class="stringliteral">
        'aa'
       </span>
       ]
      </div>
      <div class="line">
       s2 = [
       <span class="stringliteral">
        ''
       </span>
       ,
       <span class="stringliteral">
        'bb'
       </span>
       ,
       <span class="stringliteral">
        'bb'
       </span>
       ,
       <span class="keyword">
        null
       </span>
       ]
      </div>
      <div class="line">
       r1 =
       <a class="code" href="namespacecudf_1_1strings.html#a4fd98e6c74474f5686abe7df409e7d0e">
        concatenate
       </a>
       ([s1,s2])
      </div>
      <div class="line">
       r1 is [
       <span class="stringliteral">
        'aa'
       </span>
       ,
       <span class="keyword">
        null
       </span>
       ,
       <span class="stringliteral">
        'bb'
       </span>
       ,
       <span class="keyword">
        null
       </span>
       ]
      </div>
      <div class="line">
       r2 =
       <a class="code" href="namespacecudf_1_1strings.html#a4fd98e6c74474f5686abe7df409e7d0e">
        concatenate
       </a>
       ([s1,s2],
       <span class="charliteral">
        ':'
       </span>
       ,
       <span class="charliteral">
        '_'
       </span>
       )
      </div>
      <div class="line">
       r2 is ['aa:', '_:bb', ':bb', 'aa:_']
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if input columns are not all strings columns.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if separator is not valid.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings_columns
         </td>
         <td>
          List of string columns to concatenate.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          separator
         </td>
         <td>
          String that should inserted between each string from each row. Default is an empty string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          narep
         </td>
         <td>
          String that should be used in place of any null strings found in any column. Default of invalid-scalar means any null entry in any column will produces a null result for that row.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column with concatenated results.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a6761e18983d2a3279525264407273f18">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a6761e18983d2a3279525264407273f18">
      ◆
     </a>
    </span>
    contains()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::contains
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         target
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of boolean values for each string where true indicates the target string was found within that string in the provided column.
     </p>
     <p>
      If the
      <code>
       target
      </code>
      is not found for a string, false is returned for that entry in the output column. If
      <code>
       target
      </code>
      is an empty string, true is returned for all non-null entries in the output column.
     </p>
     <p>
      Any null string entries return corresponding null entries in the output columns.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          target
         </td>
         <td>
          UTF-8 encoded string to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New BOOL8 column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a8925af03b35ed4c4f83e9e8af356ccca">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a8925af03b35ed4c4f83e9e8af356ccca">
      ◆
     </a>
    </span>
    contains_re()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::contains_re
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a boolean column identifying rows which match the given regex pattern.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "abc"
       </span>
       ,
       <span class="stringliteral">
        "123"
       </span>
       ,
       <span class="stringliteral">
        "def456"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a6761e18983d2a3279525264407273f18">
        contains
       </a>
       (s,
       <span class="stringliteral">
        "\\d+"
       </span>
       )
      </div>
      <div class="line">
       r is now [false, true, true]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          Regex pattern to match to each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of boolean results for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a2b94f191051e2e9d0c2d151741da1411">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a2b94f191051e2e9d0c2d151741da1411">
      ◆
     </a>
    </span>
    contiguous_rsplit_record()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html">
         contiguous_split_record_result
        </a>
        cudf::strings::contiguous_rsplit_record
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         maxsplit
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Splits each element of the input column from the end to a column of tokens storing the resulting columns in a single contiguous block of memory.
     </p>
     <p>
      This function splits each element in the input column to a column of tokens. The number of columns in the output vector will be the same as the number of elements in the input column. The column length will coincide with the number of tokens; the resulting columns wrapped in the returned object may have different sizes.
     </p>
     <p>
      Splitting a null string element will result in an empty output column.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          cudf:logic_error
         </td>
         <td>
          if
          <code>
           delimiter
          </code>
          is invalid.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          A column of string elements to be splitted.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          UTF-8 encoded string indentifying the split points in each string. Default of empty string indicates split on whitespace.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          maxsplit
         </td>
         <td>
          Maximum number of splits to perform. Default of -1 indicates all possible splits on each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html" title="The result(s) of a contiguous_(r)split_record">
        contiguous_split_record_result
       </a>
       New vector of strings
       <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">
        column_view
       </a>
       objects (each
       <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">
        column_view
       </a>
       element of the vector holds splits from a string element of the input column).
      </dd>
     </dl>
    </div>
   </div>
   <a id="aa495a3dc10581c01f3b24713826cc280">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#aa495a3dc10581c01f3b24713826cc280">
      ◆
     </a>
    </span>
    contiguous_split_record()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html">
         contiguous_split_record_result
        </a>
        cudf::strings::contiguous_split_record
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         maxsplit
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Splits each element of the input column to a column of tokens storing the resulting columns in a single contiguous block of memory.
     </p>
     <p>
      This function splits each element in the input column to a column of tokens. The number of columns in the output vector will be the same as the number of elements in the input column. The column length will coincide with the number of tokens; the resulting columns wrapped in the returned object may have different sizes.
     </p>
     <p>
      Splitting a null string element will result in an empty output column.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          cudf:logic_error
         </td>
         <td>
          if
          <code>
           delimiter
          </code>
          is invalid.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          A column of string elements to be splitted.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          UTF-8 encoded string indentifying the split points in each string. Default of empty string indicates split on whitespace.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          maxsplit
         </td>
         <td>
          Maximum number of splits to perform. Default of -1 indicates all possible splits on each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       <a class="el" href="structcudf_1_1strings_1_1contiguous__split__record__result.html" title="The result(s) of a contiguous_(r)split_record">
        contiguous_split_record_result
       </a>
       New vector of strings
       <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">
        column_view
       </a>
       objects (each
       <a class="el" href="classcudf_1_1column__view.html" title="A non-owning, immutable view of device data as a column of elements, some of which may be null as ind...">
        column_view
       </a>
       element of the vector holds splits from a string element of the input column).
      </dd>
     </dl>
    </div>
   </div>
   <a id="a404c6362b7373210227c9c6e71eb2f8c">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a404c6362b7373210227c9c6e71eb2f8c">
      ◆
     </a>
    </span>
    count_bytes()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::count_bytes
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a numeric column containing the length of each string in bytes.
     </p>
     <p>
      The output column will have the same number of rows as the specified strings column. Each row value will be the number of bytes in the corresponding string.
     </p>
     <p>
      Any null string will result in a null entry for that row in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New INT32 column with the number of bytes for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ad48a7f33405d2f44b678bf07e96feaa9">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ad48a7f33405d2f44b678bf07e96feaa9">
      ◆
     </a>
    </span>
    count_characters()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::count_characters
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns an integer numeric column containing the length of each string in characters.
     </p>
     <p>
      The output column will have the same number of rows as the specified strings column. Each row value will be the number of characters in the corresponding string.
     </p>
     <p>
      Any null string will result in a null entry for that row in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New INT32 column with lengths for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a6e79229088d2c0384f91e51817bb431e">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a6e79229088d2c0384f91e51817bb431e">
      ◆
     </a>
    </span>
    count_re()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::count_re
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns the number of times the given regex pattern matches in each string.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "abc"
       </span>
       ,
       <span class="stringliteral">
        "123"
       </span>
       ,
       <span class="stringliteral">
        "def45"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a6761e18983d2a3279525264407273f18">
        contains
       </a>
       (s,
       <span class="stringliteral">
        "\\d"
       </span>
       )
      </div>
      <div class="line">
       r is now [0, 3, 2]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          Regex pattern to match within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New INT32 column with counts for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a1543a5ccc995db83c1ba9ea5ecd8831b">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a1543a5ccc995db83c1ba9ea5ecd8831b">
      ◆
     </a>
    </span>
    create_offsets()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::pair&lt; rmm::device_vector&lt; char &gt;, rmm::device_vector&lt; size_type &gt; &gt; cudf::strings::create_offsets
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="types_8hpp.html#a27a677c66bef483a40f3d65c02b09e0f">
         cudaStream_t
        </a>
       </td>
       <td class="paramname">
        <em>
         stream
        </em>
        =
        <code>
         0
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Create output per Arrow strings format.
     </p>
     <p>
      The return pair is the vector of chars and the vector of offsets.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stream
         </td>
         <td>
          CUDA stream to use kernels in this method.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       Pair containing a vector of chars and a vector of offsets.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a30ad0531aeb055967492897851ec5828">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a30ad0531aeb055967492897851ec5828">
      ◆
     </a>
    </span>
    ends_with()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::ends_with
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         target
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of boolean values for each string where true indicates the target string was found at the end of that string in the provided column.
     </p>
     <p>
      If
      <code>
       target
      </code>
      is not found at the end of a string, false is set for that row entry in the output column. If
      <code>
       target
      </code>
      is an empty string, true is returned for all non-null entries in the output column.
     </p>
     <p>
      Any null string entries return corresponding null entries in the output columns.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          target
         </td>
         <td>
          UTF-8 encoded string to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New BOOL8 column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a8c5b1014dcd65e3ebbd00a57c26a5ce6">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a8c5b1014dcd65e3ebbd00a57c26a5ce6">
      ◆
     </a>
    </span>
    extract()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1experimental_1_1table.html">
         experimental::table
        </a>
        &gt; cudf::strings::extract
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a vector of strings columns for each matching group specified in the given regular expression pattern.
     </p>
     <p>
      All the strings for the first group will go in the first output column; the second group go in the second column and so on. Null entries are added if the string does match.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "a1"
       </span>
       ,
       <span class="stringliteral">
        "b2"
       </span>
       ,
       <span class="stringliteral">
        "c3"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a8c5b1014dcd65e3ebbd00a57c26a5ce6">
        extract
       </a>
       (s,
       <span class="stringliteral">
        "([ab])(\\d)"
       </span>
       )
      </div>
      <div class="line">
       r is now [["a","b",null],
      </div>
      <div class="line">
       ["1","2",null]]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          The regular expression pattern with group indicators.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       Columns of strings extracted from the input column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a8897022e900a9eb090cbd09652e75658">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a8897022e900a9eb090cbd09652e75658">
      ◆
     </a>
    </span>
    find()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::find
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         target
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         start
        </em>
        =
        <code>
         0
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         stop
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of character position values where the target string is first found in each string of the provided column.
     </p>
     <p>
      If
      <code>
       target
      </code>
      is not found, -1 is returned for that row entry in the output column.
     </p>
     <p>
      The target string is searched within each string in the character position range [start,stop). If the stop parameter is -1, then the end of each string becomes the final position to include in the search.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if start position is greater than stop position.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          target
         </td>
         <td>
          UTF-8 encoded string to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          start
         </td>
         <td>
          First character position to include in the search.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stop
         </td>
         <td>
          Last position (exclusive) to include in the search. Default of -1 will search to the end of the string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New integer column with character position values.
      </dd>
     </dl>
    </div>
   </div>
   <a id="aa14e7275a271183be10919c1042516e7">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#aa14e7275a271183be10919c1042516e7">
      ◆
     </a>
    </span>
    find_multiple()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::find_multiple
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         targets
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column with character position values where each of the target strings are found in each string.
     </p>
     <p>
      The size of the output column is targets.size() * strings.size(). output[i] contains the position of target[i % targets.size()] in string[i/targets.size()]
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "abc"
       </span>
       ,
       <span class="stringliteral">
        "def"
       </span>
       ]
      </div>
      <div class="line">
       t = [
       <span class="stringliteral">
        "a"
       </span>
       ,
       <span class="stringliteral">
        "c"
       </span>
       ,
       <span class="stringliteral">
        "e"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#aa14e7275a271183be10919c1042516e7">
        find_multiple
       </a>
       (s,t)
      </div>
      <div class="line">
       r is now [ 0, 2,-1,
       <span class="comment">
        // for "abc": "a" at pos 0, "c" at pos 2, "e" not found
       </span>
      </div>
      <div class="line">
       -1,-1, 1 ]
       <span class="comment">
        // for "def": "a" and "b" not found, "e" at  pos 1
       </span>
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          targets is empty or contains nulls
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          targets
         </td>
         <td>
          Strings to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New integer column with character position values.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a29cc2e88078299ddac5ceb379a5c367d">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a29cc2e88078299ddac5ceb379a5c367d">
      ◆
     </a>
    </span>
    findall_re()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1experimental_1_1table.html">
         experimental::table
        </a>
        &gt; cudf::strings::findall_re
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a table of strings columns for each matching occurrence of the regex pattern within each string.
     </p>
     <p>
      The number of output columns is determined by the string with the most matches.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          Regex pattern to match within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New table of strings columns.
      </dd>
     </dl>
    </div>
   </div>
   <a id="af51463805e485ceee75ab1cab6a53f18">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#af51463805e485ceee75ab1cab6a53f18">
      ◆
     </a>
    </span>
    from_booleans()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::from_booleans
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         booleans
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         true_string
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("true")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         false_string
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("false")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new strings column converting the boolean values from the provided column into strings.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if the input column is not BOOL8 type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          booleans
         </td>
         <td>
          Boolean column to convert.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          true_string
         </td>
         <td>
          String to use for true in the output column.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          false_string
         </td>
         <td>
          String to use for false in the output column.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="adf9aa5ef3ae6d635ecd8b386e703f189">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#adf9aa5ef3ae6d635ecd8b386e703f189">
      ◆
     </a>
    </span>
    from_floats()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::from_floats
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         floats
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new strings column converting the float values from the provided column into strings.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <p>
      For each float, a string is created in base-10 decimal. Negative numbers will include a '-' prefix. Numbers producing more than 10 significant digits will produce a string that includes scientific notation (e.g. "-1.78e+15").
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if floats column is not float type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          floats
         </td>
         <td>
          Numeric column to convert.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column with floats as strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="af82b9b754e250e72d813b4a317c1a87d">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#af82b9b754e250e72d813b4a317c1a87d">
      ◆
     </a>
    </span>
    from_integers()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::from_integers
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         integers
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new strings column converting the integer values from the provided column into strings.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <p>
      For each integer, a string is created in base-10 decimal. Negative numbers will include a '-' prefix.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if integers column is not integral type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          integers
         </td>
         <td>
          Numeric column to convert.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column with integers as strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="af0b5b7984fdc62ee46929dbecdfa55aa">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#af0b5b7984fdc62ee46929dbecdfa55aa">
      ◆
     </a>
    </span>
    from_timestamps()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::from_timestamps
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         timestamps
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         format
        </em>
        =
        <code>
         "%Y-%m-%dT%H:%M:%SZ"
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new strings column converting a timestamp column into strings using the provided format pattern.
     </p>
     <p>
      The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z,%Z"
     </p>
     <table class="markdownTable">
      <tr class="markdownTableHead">
       <th class="markdownTableHeadCenter">
        Specifier
       </th>
       <th class="markdownTableHeadNone">
        Description
       </th>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %d
       </td>
       <td class="markdownTableBodyNone">
        Day of the month: 01-31
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %m
       </td>
       <td class="markdownTableBodyNone">
        Month of the year: 01-12
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %y
       </td>
       <td class="markdownTableBodyNone">
        Year without century: 00-99
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %Y
       </td>
       <td class="markdownTableBodyNone">
        Year with century: 0001-9999
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %H
       </td>
       <td class="markdownTableBodyNone">
        24-hour of the day: 00-23
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %I
       </td>
       <td class="markdownTableBodyNone">
        12-hour of the day: 01-12
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %M
       </td>
       <td class="markdownTableBodyNone">
        Minute of the hour: 00-59
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %S
       </td>
       <td class="markdownTableBodyNone">
        Second of the minute: 00-59
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %f
       </td>
       <td class="markdownTableBodyNone">
        6-digit microsecond: 000000-999999
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %z
       </td>
       <td class="markdownTableBodyNone">
        Always outputs "+0000"
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %Z
       </td>
       <td class="markdownTableBodyNone">
        Always outputs "UTC"
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %j
       </td>
       <td class="markdownTableBodyNone">
        Day of the year: 001-366
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %p
       </td>
       <td class="markdownTableBodyNone">
        Only 'AM' or 'PM'
       </td>
      </tr>
     </table>
     <p>
      No checking is done for invalid formats or invalid timestamp values. Negative timestamp values are not currently supported. All timestamps values are formatted to UTC.
     </p>
     <p>
      Any null input entry will result in a corresponding null entry in the output column.
     </p>
     <p>
      The time units of the input column do not influence the number of digits written by the "%f" specifier. The "%f" supports a precision value to write out numeric digits for the subsecond value. Specify the precision with a single integer value (1-9) between the "%" and the "f" as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds. If the precision is higher than the units, then zeroes are padded to the right of the subsecond value. If the precision is lower than the units, the subsecond value may be truncated.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if
          <code>
           timestamps
          </code>
          column parameter is not a timestamp type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          timestamps
         </td>
         <td>
          Timestamp values to convert.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          format
         </td>
         <td>
          The string specifying output format. Default format is "%Y-%m-%dT%H:%M:%SZ".
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column with formatted timestamps.
      </dd>
     </dl>
    </div>
   </div>
   <a id="abb12a54db56fb4e7d5cdc417ef914945">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#abb12a54db56fb4e7d5cdc417ef914945">
      ◆
     </a>
    </span>
    hex_to_integers()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::hex_to_integers
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1data__type.html">
         data_type
        </a>
       </td>
       <td class="paramname">
        <em>
         output_type
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new integer numeric column parsing hexadecimal values from the provided strings column.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <p>
      Only characters [0-9] and [A-F] are recognized. When any other character is encountered, the parsing ends for that string. No interpretation is made on the sign of the integer.
     </p>
     <p>
      Overflow of the resulting integer type is not checked. Each string is converted using an int64 type and then cast to the target integer type before storing it into the output column. If the resulting integer type is too small to hold the value, the stored value will be undefined.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if output_type is not integral type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          output_type
         </td>
         <td>
          Type of integer numeric column to return.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column with integers converted from strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="af2504d06552234f412049d370f2aef68">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#af2504d06552234f412049d370f2aef68">
      ◆
     </a>
    </span>
    integers_to_ipv4()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::integers_to_ipv4
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         integers
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Converts integers into IPv4 addresses as strings.
     </p>
     <p>
      The IPv4 format is 1-3 character digits [0-9] between 3 dots (e.g. 123.45.67.890). Each section can have a value between [0-255].
     </p>
     <p>
      Each input integer is dissected into four integers by dividing the input into 8-bit sections. These sub-integers are then converted into [0-9] characters and placed between '.' characters.
     </p>
     <p>
      No checking is done on the input integer value. Only the lower 32-bits are used.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if the input column is not INT64 type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          integers
         </td>
         <td>
          Integer (INT64) column to convert.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a27b917bcbd11873c8b63d14dbb1900b4">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a27b917bcbd11873c8b63d14dbb1900b4">
      ◆
     </a>
    </span>
    ipv4_to_integers()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::ipv4_to_integers
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Converts IPv4 addresses into integers.
     </p>
     <p>
      The IPv4 format is 1-3 character digits [0-9] between 3 dots (e.g. 123.45.67.890). Each section can have a value between [0-255].
     </p>
     <p>
      The four sets of digits are converted to integers and placed in 8-bit fields inside the resulting integer.
     </p>
     <div class="fragment">
      <div class="line">
       i0.i1.i2.i3 -&gt; (i0 &lt;&lt; 24) | (i1 &lt;&lt; 16) | (i2 &lt;&lt; 8) | (i3)
      </div>
     </div>
     <!-- fragment -->
     <p>
      No checking is done on the format. If a string is not in IPv4 format, the resulting integer is undefined.
     </p>
     <p>
      The resulting 32-bit integer is placed in an int64_t to avoid setting the sign-bit in a int32_t type. This could be changed if cudf supported a UINT32 type in the future.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New INT64 column converted from strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a4be4ba0a0ae6fd1b935c154c79391f54">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a4be4ba0a0ae6fd1b935c154c79391f54">
      ◆
     </a>
    </span>
    is_float()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::is_float
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a boolean column identifying strings in which all characters are valid for conversion to floats.
     </p>
     <p>
      The output row entry will be set to
      <code>
       true
      </code>
      if the corresponding string element has at least one character in [-+0-9eE.].
     </p>
     <div class="fragment">
      <div class="line">
       Example:
      </div>
      <div class="line">
       s = [
       <span class="stringliteral">
        '123'
       </span>
       ,
       <span class="stringliteral">
        '-456'
       </span>
       ,
       <span class="stringliteral">
        ''
       </span>
       ,
       <span class="charliteral">
        'A'
       </span>
       ,
       <span class="stringliteral">
        '+7'
       </span>
       ,
       <span class="stringliteral">
        '8.9'
       </span>
       <span class="stringliteral">
        '3.7e+5'
       </span>
       ]
      </div>
      <div class="line">
       b = s.is_float(s)
      </div>
      <div class="line">
       b is [
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Any null row results in a null entry for that row in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of boolean results for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a061db2a9c22ec802896de4f7daa83c05">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a061db2a9c22ec802896de4f7daa83c05">
      ◆
     </a>
    </span>
    is_integer()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::is_integer
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a boolean column identifying strings in which all characters are valid for conversion to integers.
     </p>
     <p>
      The output row entry will be set to
      <code>
       true
      </code>
      if the corresponding string element has at least one character in [-+0-9].
     </p>
     <div class="fragment">
      <div class="line">
       Example:
      </div>
      <div class="line">
       s = [
       <span class="stringliteral">
        '123'
       </span>
       ,
       <span class="stringliteral">
        '-456'
       </span>
       ,
       <span class="stringliteral">
        ''
       </span>
       ,
       <span class="charliteral">
        'A'
       </span>
       ,
       <span class="stringliteral">
        '+7'
       </span>
       ]
      </div>
      <div class="line">
       b = s.is_integer(s)
      </div>
      <div class="line">
       b is [
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ,
       <span class="keyword">
        false
       </span>
       ,
       <span class="keyword">
        true
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Any null row results in a null entry for that row in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of boolean results for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ab6a77478fadde8b86e5a165283db03d3">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ab6a77478fadde8b86e5a165283db03d3">
      ◆
     </a>
    </span>
    join_strings()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::join_strings
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         separator
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         narep
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("", false)
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Concatenates all strings in the column into one new string delimited by an optional separator string.
     </p>
     <p>
      This returns a column with one string. Any null entries are ignored unless the narep parameter specifies a replacement string.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        'aa'
       </span>
       ,
       <span class="keyword">
        null
       </span>
       ,
       <span class="stringliteral">
        ''
       </span>
       ,
       <span class="stringliteral">
        'zz'
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#ab6a77478fadde8b86e5a165283db03d3">
        join_strings
       </a>
       (s,
       <span class="charliteral">
        ':'
       </span>
       ,
       <span class="charliteral">
        '_'
       </span>
       )
      </div>
      <div class="line">
       r is ['aa:_::zz']
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if separator is not valid.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          separator
         </td>
         <td>
          String that should inserted between each string. Default is an empty string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          narep
         </td>
         <td>
          String that should represent any null strings found. Default of invalid-scalar will ignore any null entries.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column containing one string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="af1ae53e101b1a37652d05f18860d8fc2">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#af1ae53e101b1a37652d05f18860d8fc2">
      ◆
     </a>
    </span>
    matches_re()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::matches_re
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a boolean column identifying rows which matching the given regex pattern but only at the beginning the string.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "abc"
       </span>
       ,
       <span class="stringliteral">
        "123"
       </span>
       ,
       <span class="stringliteral">
        "def456"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a6761e18983d2a3279525264407273f18">
        contains
       </a>
       (s,
       <span class="stringliteral">
        "\\d+"
       </span>
       )
      </div>
      <div class="line">
       r is now [false, true, false]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          Regex pattern to match to each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of boolean results for each string.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a4f1989aea0aa5e69c1b8559811877570">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a4f1989aea0aa5e69c1b8559811877570">
      ◆
     </a>
    </span>
    pad()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::pad
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         width
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52">
         pad_side
        </a>
       </td>
       <td class="paramname">
        <em>
         side
        </em>
        =
        <code>
         <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a21507b40c80068eda19865706fdc2403">
          cudf::strings::pad_side::RIGHT
         </a>
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         fill_char
        </em>
        =
        <code>
         " "
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Add padding to each string using a provided character.
     </p>
     <p>
      If the string is already width or more characters, no padding is performed. No strings are truncated.
     </p>
     <p>
      Null string entries result in null entries in the output column.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        'aa'
       </span>
       ,
       <span class="stringliteral">
        'bbb'
       </span>
       ,
       <span class="stringliteral">
        'cccc'
       </span>
       ,
       <span class="stringliteral">
        'ddddd'
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a4f1989aea0aa5e69c1b8559811877570">
        pad
       </a>
       (s,4)
      </div>
      <div class="line">
       r is now ['aa  ','bbb ','cccc','ddddd']
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          width
         </td>
         <td>
          The minimum number of characters for each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          side
         </td>
         <td>
          Where to place the padding characters. Default is pad right (left justify).
         </td>
        </tr>
        <tr>
         <td class="paramname">
          fill_char
         </td>
         <td>
          Single UTF-8 character to use for padding. Default is the space character.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column with padded strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a3129796eee80274dee431b993862ef89">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a3129796eee80274dee431b993862ef89">
      ◆
     </a>
    </span>
    partition()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1experimental_1_1table.html">
         experimental::table
        </a>
        &gt; cudf::strings::partition
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a set of 3 columns by splitting each string using the specified delimiter.
     </p>
     <p>
      The number of rows in the output columns will be the same as the input column. The first column will contain the first tokens of each string as a result of the split. The second column will contain the delimiter. The third column will contain the remaining characters of each string after the delimiter.
     </p>
     <p>
      Any null string entries return corresponding null output columns.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "ab_cd"
       </span>
       ,
       <span class="stringliteral">
        "def_g_h"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a024af33f3d9718f6990e0ef4581bf77a">
        rpartition
       </a>
       (s,
       <span class="stringliteral">
        "_"
       </span>
       )
      </div>
      <div class="line">
       r[0] is ["ab","def"]
      </div>
      <div class="line">
       r[1] is ["_","_"]
      </div>
      <div class="line">
       r[2] is ["cd","g_h"]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          UTF-8 encoded string indentifying where to split each string. Default of empty string indicates split on whitespace.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New table of strings columns.
      </dd>
     </dl>
    </div>
   </div>
   <a id="af21802cd4e0d683a803469d83ef73076">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#af21802cd4e0d683a803469d83ef73076">
      ◆
     </a>
    </span>
    print()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        void cudf::strings::print
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         start
        </em>
        =
        <code>
         0
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         end
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         max_width
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        const char *
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         "\n"
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Prints the strings to stdout.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          start
         </td>
         <td>
          Index of first string to print.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          end
         </td>
         <td>
          Index of last string to print. Specify -1 for all strings.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          max_width
         </td>
         <td>
          Maximum number of characters to print per string. Specify -1 to print all characters.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          The chars to print between each string. Default is new-line character.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
    </div>
   </div>
   <a id="a452d1ce407f311d8b22d226db9a5b1b7">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a452d1ce407f311d8b22d226db9a5b1b7">
      ◆
     </a>
    </span>
    replace()
    <span class="overload">
     [1/2]
    </span>
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         target
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         repl
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        int32_t
       </td>
       <td class="paramname">
        <em>
         maxrepl
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Replaces target string within each string with the specified replacement string.
     </p>
     <p>
      This function searches each string in the column for the target string. If found, the target string is replaced by the repl string within the input string. If not found, the output entry is just a copy of the corresponding input string.
     </p>
     <p>
      Specifing an empty string for repl will essentially remove the target string if found in each string.
     </p>
     <p>
      Null string entries will return null output string entries.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "hello"
       </span>
       ,
       <span class="stringliteral">
        "goodbye"
       </span>
       ]
      </div>
      <div class="line">
       r1 =
       <a class="code" href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
        replace
       </a>
       (s,
       <span class="stringliteral">
        "o"
       </span>
       ,
       <span class="stringliteral">
        "OOO"
       </span>
       )
      </div>
      <div class="line">
       r1 is now ["hellOOO","gOOOOOOdbye"]
      </div>
      <div class="line">
       r2 =
       <a class="code" href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
        replace
       </a>
       (s,"oo","")
      </div>
      <div class="line">
       r2 is now ["hello","gdbye"]
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if target is an empty string.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          target
         </td>
         <td>
          String to search for within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repl
         </td>
         <td>
          Replacement string if target is found.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          maxrepl
         </td>
         <td>
          Maximum times to replace if target appears multiple times in the input string. Default of -1 specifies replace all occurrences of target in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ae6afeee7c45704c3ae7e7aba8935b6b3">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ae6afeee7c45704c3ae7e7aba8935b6b3">
      ◆
     </a>
    </span>
    replace()
    <span class="overload">
     [2/2]
    </span>
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         targets
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         repls
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Replaces substrings matching a list of targets with the corresponding replacement strings.
     </p>
     <p>
      For each string in strings, the list of targets is searched within that string. If a target string is found, it is replaced by the corresponding entry in the repls column. All occurrences found in each string are replaced.
     </p>
     <p>
      This does not use regex to match targets in the string.
     </p>
     <p>
      Null string entries will return null output string entries.
     </p>
     <p>
      The repls argument can optionally contain a single string. In this case, all matching target substrings will be replaced by that single string.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "hello"
       </span>
       ,
       <span class="stringliteral">
        "goodbye"
       </span>
       ]
      </div>
      <div class="line">
       tgts = [
       <span class="stringliteral">
        "e"
       </span>
       ,
       <span class="stringliteral">
        "o"
       </span>
       ]
      </div>
      <div class="line">
       repls = [
       <span class="stringliteral">
        "EE"
       </span>
       ,
       <span class="stringliteral">
        "OO"
       </span>
       ]
      </div>
      <div class="line">
       r1 =
       <a class="code" href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
        replace
       </a>
       (s,tgts,repls)
      </div>
      <div class="line">
       r1 is now [
       <span class="stringliteral">
        "hEEllO"
       </span>
       ,
       <span class="stringliteral">
        "gOOOOdbyEE"
       </span>
       ]
      </div>
      <div class="line">
       tgts = [
       <span class="stringliteral">
        "e"
       </span>
       ,
       <span class="stringliteral">
        "oo"
       </span>
       ]
      </div>
      <div class="line">
       repls = [
       <span class="stringliteral">
        "33"
       </span>
       ,
       <span class="stringliteral">
        ""
       </span>
       ]
      </div>
      <div class="line">
       r2 =
       <a class="code" href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
        replace
       </a>
       (s,tgts,repls)
      </div>
      <div class="line">
       r2 is now [
       <span class="stringliteral">
        "h33llo"
       </span>
       ,
       <span class="stringliteral">
        "gdby33"
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if targets and repls are different sizes except if repls is a single string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if targets or repls contain null entries.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          targets
         </td>
         <td>
          Strings to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repls
         </td>
         <td>
          Corresponding replacement strings for target strings.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="acf8d376612ac5b0d7f524806b0d4b65b">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#acf8d376612ac5b0d7f524806b0d4b65b">
      ◆
     </a>
    </span>
    replace_nulls()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace_nulls
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         repl
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Replaces any null string entries with the given string.
     </p>
     <p>
      This returns a strings column with no null entries.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "hello"
       </span>
       ,
       <span class="keyword">
        nullptr
       </span>
       ,
       <span class="stringliteral">
        "goodbye"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#acf8d376612ac5b0d7f524806b0d4b65b">
        replace_nulls
       </a>
       (s,
       <span class="stringliteral">
        "**"
       </span>
       )
      </div>
      <div class="line">
       r is now ["hello", "**", "goodbye"]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repl
         </td>
         <td>
          Replacement string for null entries. Default is empty string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a4340ab9c096dd15df8d9d570b24cc4a6">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a4340ab9c096dd15df8d9d570b24cc4a6">
      ◆
     </a>
    </span>
    replace_re()
    <span class="overload">
     [1/2]
    </span>
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace_re
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         repl
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         maxrepl
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      For each string, replaces any character sequence matching the given pattern with the provided replacement string.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          The regular expression pattern to search within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repl
         </td>
         <td>
          The string used to replace the matched sequence in each string. Default is an empty string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          maxrepl
         </td>
         <td>
          The maximum number of times to replace the matched pattern within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="aae51810f464e8dd637d4f297ca49caae">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#aae51810f464e8dd637d4f297ca49caae">
      ◆
     </a>
    </span>
    replace_re()
    <span class="overload">
     [2/2]
    </span>
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace_re
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::vector&lt; std::string &gt; const &amp;
       </td>
       <td class="paramname">
        <em>
         patterns
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         repls
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      For each string, replaces any character sequence matching the given patterns with the corresponding string in the repls column.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          The regular expression patterns to search within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repls
         </td>
         <td>
          The strings used for replacement.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a18d7f0468ef567600563b0493e573dd1">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a18d7f0468ef567600563b0493e573dd1">
      ◆
     </a>
    </span>
    replace_slice()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace_slice
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         repl
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         start
        </em>
        =
        <code>
         0
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         stop
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      This function replaces each string in the column with the provided repl string within the [start,stop) character position range.
     </p>
     <p>
      Null string entries will return null output string entries.
     </p>
     <p>
      Position values are 0-based meaning position 0 is the first character of each string.
     </p>
     <p>
      This function can be used to insert a string into specific position by specifying the same position value for start and stop. The repl string can be appended to each string by specifying -1 for both start and stop.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "abcdefghij"
       </span>
       ,
       <span class="stringliteral">
        "0123456789"
       </span>
       ]
      </div>
      <div class="line">
       r = s.replace_slice(s,2,5,
       <span class="stringliteral">
        "z"
       </span>
       )
      </div>
      <div class="line">
       r is now [
       <span class="stringliteral">
        "abzfghij"
       </span>
       ,
       <span class="stringliteral">
        "01z56789"
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if start is greater than stop.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repl
         </td>
         <td>
          Replacement string for specified positions found. Default is empty string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          start
         </td>
         <td>
          Start position where repl will be added. Default is 0, first character position.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stop
         </td>
         <td>
          End position (exclusive) to use for replacement. Default of -1 specifies the end of each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a248c4ad6bc61163e98e214bb0d07f755">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a248c4ad6bc61163e98e214bb0d07f755">
      ◆
     </a>
    </span>
    replace_with_backrefs()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::replace_with_backrefs
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         pattern
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         repl
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      For each string, replaces any character sequence matching the given pattern using the repl template for back-references.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          pattern
         </td>
         <td>
          The regular expression patterns to search within each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          repl
         </td>
         <td>
          The replacement template for creating the output string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ac216eaea55fe9d42b44aae9c0387d329">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ac216eaea55fe9d42b44aae9c0387d329">
      ◆
     </a>
    </span>
    rfind()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::rfind
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         target
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         start
        </em>
        =
        <code>
         0
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         stop
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of character position values where the target string is first found searching from the end of each string.
     </p>
     <p>
      If
      <code>
       target
      </code>
      is not found, -1 is returned for that entry.
     </p>
     <p>
      The target string is searched within each string in the character position range [start,stop). If the stop parameter is -1, then the end of each string becomes the final position to include in the search.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if start position is greater than stop position.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          target
         </td>
         <td>
          UTF-8 encoded string to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          start
         </td>
         <td>
          First position to include in the search.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stop
         </td>
         <td>
          Last position (exclusive) to include in the search. Default of -1 will search starting at the end of the string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New integer column with character position values.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a024af33f3d9718f6990e0ef4581bf77a">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a024af33f3d9718f6990e0ef4581bf77a">
      ◆
     </a>
    </span>
    rpartition()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1experimental_1_1table.html">
         experimental::table
        </a>
        &gt; cudf::strings::rpartition
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a set of 3 columns by splitting each string using the specified delimiter starting from the end of each string.
     </p>
     <p>
      The number of rows in the output columns will be the same as the input column. The first column will contain the characters of each string before the last delimiter found. The second column will contain the delimiter. The third column will contain the remaining characters of each string after the delimiter.
     </p>
     <p>
      Any null string entries return corresponding null output columns.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "ab_cd"
       </span>
       ,
       <span class="stringliteral">
        "def_g_h"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a024af33f3d9718f6990e0ef4581bf77a">
        rpartition
       </a>
       (s,
       <span class="stringliteral">
        "_"
       </span>
       )
      </div>
      <div class="line">
       r[0] is ["ab","def_g"]
      </div>
      <div class="line">
       r[1] is ["_","_"]
      </div>
      <div class="line">
       r[2] is ["cd","h"]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          UTF-8 encoded string indentifying where to split each string. Default of empty string indicates split on whitespace.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings columns.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a57a8e41a67727b9953f01b939dba70f7">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a57a8e41a67727b9953f01b939dba70f7">
      ◆
     </a>
    </span>
    rsplit()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1experimental_1_1table.html">
         experimental::table
        </a>
        &gt; cudf::strings::rsplit
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         maxsplit
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a list of columns by splitting each string using the specified delimiter starting from the end of each string.
     </p>
     <p>
      The number of rows in the output columns will be the same as the input column. The first column will contain the first tokens encountered in each string as a result of the split. Subsequent columns contain the next token strings. Null entries are added for a row where split results have been exhausted. The total number of columns will equal the maximum number of splits encountered on any string in the input column.
     </p>
     <p>
      Any null string entries return corresponding null output columns.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          UTF-8 encoded string indentifying the split points in each string. Default of empty string indicates split on whitespace.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          maxsplit
         </td>
         <td>
          Maximum number of splits to perform. Default of -1 indicates all possible splits on each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings columns.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a7c2d10a08ed8bfd9174936afe8236d5b">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a7c2d10a08ed8bfd9174936afe8236d5b">
      ◆
     </a>
    </span>
    slice_strings()
    <span class="overload">
     [1/2]
    </span>
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::slice_strings
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         starts
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1column__view.html">
         column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         stops
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new strings column that contains substrings of the strings in the provided column using unique ranges for each string.
     </p>
     <p>
      The character positions to retrieve in each string are [start,stop). If a start position is outside a string's length, an empty string is returned for that entry. If a stop position is past the end of a string's length, the end of the string is used for stop position for that string. Any stop position value set to -1 will indicate to use the end of the string as the stop position for that string.
     </p>
     <p>
      Null string entries will return null output string entries.
     </p>
     <p>
      The starts and stops column must both be the same integer type and must be the same size as the strings column.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "hello"
       </span>
       ,
       <span class="stringliteral">
        "goodbye"
       </span>
       ]
      </div>
      <div class="line">
       starts = [ 1, 2 ]
      </div>
      <div class="line">
       stops = [ 5, 4 ]
      </div>
      <div class="line">
       r = substring_from(s,starts,stops)
      </div>
      <div class="line">
       r is now [
       <span class="stringliteral">
        "ello"
       </span>
       ,
       <span class="stringliteral">
        "od"
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if starts or stops is a different size than the strings column.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if starts and stops are not same integer type.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if starts or stops contains nulls.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          starts
         </td>
         <td>
          First character positions to begin the substring.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stops
         </td>
         <td>
          Last character (exclusive) positions to end the substring.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column with sorted elements of this instance.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a1852eb5dc4ff8373934038c720bcbf97">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a1852eb5dc4ff8373934038c720bcbf97">
      ◆
     </a>
    </span>
    slice_strings()
    <span class="overload">
     [2/2]
    </span>
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::slice_strings
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1numeric__scalar.html">
         numeric_scalar
        </a>
        &lt; size_type &gt; const &amp;
       </td>
       <td class="paramname">
        <em>
         start
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1numeric__scalar.html">
          numeric_scalar
         </a>
         &lt; size_type &gt;(0, false)
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1numeric__scalar.html">
         numeric_scalar
        </a>
        &lt; size_type &gt; const &amp;
       </td>
       <td class="paramname">
        <em>
         stop
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1numeric__scalar.html">
          numeric_scalar
         </a>
         &lt; size_type &gt;(0, false)
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1numeric__scalar.html">
         numeric_scalar
        </a>
        &lt; size_type &gt; const &amp;
       </td>
       <td class="paramname">
        <em>
         step
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1numeric__scalar.html">
          numeric_scalar
         </a>
         &lt; size_type &gt;(1)
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new strings column that contains substrings of the strings in the provided column.
     </p>
     <p>
      The character positions to retrieve in each string are [start,stop). If the start position is outside a string's length, an empty string is returned for that entry. If the stop position is past the end of a string's length, the end of the string is used for stop position for that string.
     </p>
     <p>
      Null string entries will return null output string entries.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "hello"
       </span>
       ,
       <span class="stringliteral">
        "goodbye"
       </span>
       ]
      </div>
      <div class="line">
       r = substring(s,2,6)
      </div>
      <div class="line">
       r is now ["llo","odby"]
      </div>
      <div class="line">
       r2 = substring(s,2,5,2)
      </div>
      <div class="line">
       r2 is now ["lo","ob"]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          start
         </td>
         <td>
          First character position to begin the substring.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stop
         </td>
         <td>
          Last character position (exclusive) to end the substring.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          step
         </td>
         <td>
          Distance between input characters retrieved.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column with sorted elements of this instance.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a3f6d9db5eb39e7ccc69accfaed9b903e">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a3f6d9db5eb39e7ccc69accfaed9b903e">
      ◆
     </a>
    </span>
    split()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1experimental_1_1table.html">
         experimental::table
        </a>
        &gt; cudf::strings::split
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         delimiter
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         maxsplit
        </em>
        =
        <code>
         -1
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a list of columns by splitting each string using the specified delimiter.
     </p>
     <p>
      The number of rows in the output columns will be the same as the input column. The first column will contain the first tokens of each string as a result of the split. Subsequent columns contain the next token strings. Null entries are added for a row where split results have been exhausted. The total number of columns will equal the maximum number of splits encountered on any string in the input column.
     </p>
     <p>
      Any null string entries return corresponding null output columns.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          delimiter
         </td>
         <td>
          UTF-8 encoded string indentifying the split points in each string. Default of empty string indicates split on whitespace.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          maxsplit
         </td>
         <td>
          Maximum number of splits to perform. Default of -1 indicates all possible splits on each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New table of strings columns.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a2ce720bbd79edf6247dbb0c804a613d8">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a2ce720bbd79edf6247dbb0c804a613d8">
      ◆
     </a>
    </span>
    starts_with()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::starts_with
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         target
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of boolean values for each string where true indicates the target string was found at the beginning of that string in the provided column.
     </p>
     <p>
      If
      <code>
       target
      </code>
      is not found at the beginning of a string, false is set for that row entry in the output column. If
      <code>
       target
      </code>
      is an empty string, true is returned for all non-null entries in the output column.
     </p>
     <p>
      Any null string entries return corresponding null entries in the output columns.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          target
         </td>
         <td>
          UTF-8 encoded string to search for in each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New BOOL8 column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="afeeda8580beff9f9f486fbc540e8e2b4">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#afeeda8580beff9f9f486fbc540e8e2b4">
      ◆
     </a>
    </span>
    strip()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::strip
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        strip_type
       </td>
       <td class="paramname">
        <em>
         stype
        </em>
        =
        <code>
         <a class="el" href="namespacecudf_1_1strings.html#ace598ecf9030296eeebfef46251d7d52a6328e5e3186c227a021ef2ff77e40197">
          strip_type::BOTH
         </a>
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         to_strip
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Removes the specified characters from the beginning or end (or both) of each string.
     </p>
     <p>
      The to_strip parameter can contain one or more characters. All characters in
      <code>
       to_strip
      </code>
      are removed from the input strings.
     </p>
     <p>
      If
      <code>
       to_strip
      </code>
      is the empty string, whitespace characters are removed. Whitespace is considered the space character plus control characters like tab and line feed.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        " aaa "
       </span>
       ,
       <span class="stringliteral">
        "_bbbb "
       </span>
       ,
       <span class="stringliteral">
        "__cccc  "
       </span>
       ,
       <span class="stringliteral">
        "ddd"
       </span>
       ,
       <span class="stringliteral">
        " ee _ff gg_"
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#afeeda8580beff9f9f486fbc540e8e2b4">
        strip
       </a>
       (s,both,
       <span class="stringliteral">
        " _"
       </span>
       )
      </div>
      <div class="line">
       r is now ["aaa", "bbbb", "cccc", "ddd", "ee _ff gg"]
      </div>
     </div>
     <!-- fragment -->
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if
          <code>
           to_strip
          </code>
          is invalid.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings column for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          stype
         </td>
         <td>
          Indicates characters are to be stripped from the beginning, end, or both of each string. Default is both.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          to_strip
         </td>
         <td>
          UTF-8 encoded characters to strip from each string. Default is empty string which indicates strip whitespace characters.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ae2a602f729fda3c72af8e1b9f9d59490">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ae2a602f729fda3c72af8e1b9f9d59490">
      ◆
     </a>
    </span>
    swapcase()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::swapcase
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a column of strings converting lower case characters to upper case and vice versa.
     </p>
     <p>
      Only upper or lower case alphabetical characters are converted. All other characters are copied. Case conversion may result in strings that are longer or shorter than the original string in bytes.
     </p>
     <p>
      Any null entries create null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of strings with characters converted.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a3cf6aa64c4c6457f858e0caed366315b">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a3cf6aa64c4c6457f858e0caed366315b">
      ◆
     </a>
    </span>
    title()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::title
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Modifies first character after spaces to uppercase and lower-cases the rest.
     </p>
     <p>
      Returns a column of strings where, for each string row in the input, the first character after spaces is modified to upper-case, while all the remaining characters in a word are modified to lower-case.
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <p>
      Example:
     </p>
     <div class="fragment">
      <div class="line">
       input_string_tbl = [
       <span class="stringliteral">
        "   tesT1"
       </span>
       ,
       <span class="stringliteral">
        "a Test"
       </span>
       ,
       <span class="stringliteral">
        " Another test "
       </span>
       ];
      </div>
      <div class="line">
      </div>
      <div class="line">
       titled_string_tbl = [
       <span class="stringliteral">
        "   Test1"
       </span>
       ,
       <span class="stringliteral">
        "A Test"
       </span>
       ,
       <span class="stringliteral">
        " Another Test "
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          strings
         </td>
         <td>
          String column.
         </td>
        </tr>
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       Column of title strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a48824af0efa0b6a27a873479efc1e224">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a48824af0efa0b6a27a873479efc1e224">
      ◆
     </a>
    </span>
    to_booleans()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::to_booleans
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1string__scalar.html">
         string_scalar
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         true_string
        </em>
        =
        <code>
         <a class="el" href="classcudf_1_1string__scalar.html">
          string_scalar
         </a>
         ("true")
        </code>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new BOOL8 column by parsing boolean values from the strings in the provided strings column.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          true_string
         </td>
         <td>
          String to expect for true. Non-matching strings are false.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New BOOL8 column converted from strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ab616b3d651ce28bea4ae3ac8f9c9c92a">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ab616b3d651ce28bea4ae3ac8f9c9c92a">
      ◆
     </a>
    </span>
    to_floats()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::to_floats
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1data__type.html">
         data_type
        </a>
       </td>
       <td class="paramname">
        <em>
         output_type
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new numeric column by parsing float values from each string in the provided strings column.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <p>
      Only characters [0-9] plus a prefix '-' and '+' and decimal '.' are recognized. Additionally, scientific notation is also supported (e.g. "-1.78e+5").
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if output_type is not float type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          output_type
         </td>
         <td>
          Type of float numeric column to return.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column with floats converted from strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ab5c7bb70d5d915636847e0d1831eba3b">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ab5c7bb70d5d915636847e0d1831eba3b">
      ◆
     </a>
    </span>
    to_integers()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::to_integers
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1data__type.html">
         data_type
        </a>
       </td>
       <td class="paramname">
        <em>
         output_type
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new integer numeric column parsing integer values from the provided strings column.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <p>
      Only characters [0-9] plus a prefix '-' and '+' are recognized. When any other character is encountered, the parsing ends for that string and the current digits are converted into an integer.
     </p>
     <p>
      Overflow of the resulting integer type is not checked. Each string is converted using an int64 type and then cast to the target integer type before storing it into the output column. If the resulting integer type is too small to hold the value, the stored value will be undefined.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if output_type is not integral type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          output_type
         </td>
         <td>
          Type of integer numeric column to return.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column with integers converted from strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a6022f64064a7ccc1a10f734c8abb7a71">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a6022f64064a7ccc1a10f734c8abb7a71">
      ◆
     </a>
    </span>
    to_lower()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::to_lower
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Converts a column of strings to lower case.
     </p>
     <p>
      Only upper case alphabetical characters are converted. All other characters are copied. Case conversion may result in strings that are longer or shorter than the original string in bytes.
     </p>
     <p>
      Any null entries create null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of strings with characters converted.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a9c8dd7fe42bcd7e0f615e730dfe0593a">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a9c8dd7fe42bcd7e0f615e730dfe0593a">
      ◆
     </a>
    </span>
    to_timestamps()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::to_timestamps
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1data__type.html">
         data_type
        </a>
       </td>
       <td class="paramname">
        <em>
         timestamp_type
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::string const &amp;
       </td>
       <td class="paramname">
        <em>
         format
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Returns a new timestamp column converting a strings column into timestamps using the provided format pattern.
     </p>
     <p>
      The format pattern can include the following specifiers: "%Y,%y,%m,%d,%H,%I,%p,%M,%S,%f,%z"
     </p>
     <table class="markdownTable">
      <tr class="markdownTableHead">
       <th class="markdownTableHeadCenter">
        Specifier
       </th>
       <th class="markdownTableHeadNone">
        Description
       </th>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %d
       </td>
       <td class="markdownTableBodyNone">
        Day of the month: 01-31
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %m
       </td>
       <td class="markdownTableBodyNone">
        Month of the year: 01-12
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %y
       </td>
       <td class="markdownTableBodyNone">
        Year without century: 00-99
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %Y
       </td>
       <td class="markdownTableBodyNone">
        Year with century: 0001-9999
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %H
       </td>
       <td class="markdownTableBodyNone">
        24-hour of the day: 00-23
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %I
       </td>
       <td class="markdownTableBodyNone">
        12-hour of the day: 01-12
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %M
       </td>
       <td class="markdownTableBodyNone">
        Minute of the hour: 00-59
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %S
       </td>
       <td class="markdownTableBodyNone">
        Second of the minute: 00-59
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %f
       </td>
       <td class="markdownTableBodyNone">
        6-digit microsecond: 000000-999999
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %z
       </td>
       <td class="markdownTableBodyNone">
        UTC offset with format ±HHMM Example +0500
       </td>
      </tr>
      <tr class="markdownTableRowOdd">
       <td class="markdownTableBodyCenter">
        %j
       </td>
       <td class="markdownTableBodyNone">
        Day of the year: 001-366
       </td>
      </tr>
      <tr class="markdownTableRowEven">
       <td class="markdownTableBodyCenter">
        %p
       </td>
       <td class="markdownTableBodyNone">
        Only 'AM', 'PM' or 'am', 'pm' are recognized
       </td>
      </tr>
     </table>
     <p>
      Other specifiers are not currently supported.
     </p>
     <p>
      Invalid formats are not checked. If the string contains unexpected or insufficient characters, that output row entry's timestamp value is undefined. Negative timestamp values are not currently supported. These would have dates formatted before 1970-01-01.
     </p>
     <p>
      Any null string entry will result in a corresponding null row in the output column.
     </p>
     <p>
      The resulting time units are specified by the
      <code>
       timestamp_type
      </code>
      parameter. The time units are independent of the number of digits parsed by the "%f" specifier. The "%f" supports a precision value to read the numeric digits. Specify the precision with a single integer value (1-9) as follows: use "%3f" for milliseconds, "%6f" for microseconds and "%9f" for nanoseconds.
     </p>
     <dl class="exception">
      <dt>
       Exceptions
      </dt>
      <dd>
       <table class="exception">
        <tr>
         <td class="paramname">
          <a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">
           cudf::logic_error
          </a>
         </td>
         <td>
          if timestamp_type is not a timestamp type.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          timestamp_type
         </td>
         <td>
          The timestamp type used for creating the output column.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          format
         </td>
         <td>
          String specifying the timestamp format in strings.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New datetime column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="ae842becdab49326d2c47fc563bab3795">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#ae842becdab49326d2c47fc563bab3795">
      ◆
     </a>
    </span>
    to_upper()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::to_upper
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Converts a column of strings to upper case.
     </p>
     <p>
      Only lower case alphabetical characters are converted. All other characters are copied. Case conversion may result in strings that are longer or shorter than the original string in bytes.
     </p>
     <p>
      Any null entries create null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of strings with characters converted.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a50d5f0b7b88e886b137e23370b7a8045">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a50d5f0b7b88e886b137e23370b7a8045">
      ◆
     </a>
    </span>
    translate()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::translate
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        std::vector&lt; std::pair&lt; char_utf8, char_utf8 &gt;&gt; const &amp;
       </td>
       <td class="paramname">
        <em>
         chars_table
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Translates individual characters within each string.
     </p>
     <p>
      This can also be used to remove a character by specifying 0 for the corresponding table entry.
     </p>
     <p>
      Null string entries result in null entries in the output column.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        "aa"
       </span>
       ,
       <span class="stringliteral">
        "bbb"
       </span>
       ,
       <span class="stringliteral">
        "cccc"
       </span>
       ,
       <span class="stringliteral">
        "abcd"
       </span>
       ]
      </div>
      <div class="line">
       t = [[
       <span class="charliteral">
        'a'
       </span>
       ,
       <span class="charliteral">
        'A'
       </span>
       ],[
       <span class="charliteral">
        'b'
       </span>
       ,
       <span class="stringliteral">
        ''
       </span>
       ],[
       <span class="charliteral">
        'd'
       </span>
       :
       <span class="charliteral">
        'Q'
       </span>
       ]]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a50d5f0b7b88e886b137e23370b7a8045">
        translate
       </a>
       (s,t)
      </div>
      <div class="line">
       r is now [
       <span class="stringliteral">
        "AA"
       </span>
       ,
       <span class="stringliteral">
        ""
       </span>
       ,
       <span class="stringliteral">
        "cccc"
       </span>
       ,
       <span class="stringliteral">
        "AcQ"
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          chars_table
         </td>
         <td>
          Table of UTF-8 character mappings.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column with padded strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a02d12fd316da740b8975b19ff1757add">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a02d12fd316da740b8975b19ff1757add">
      ◆
     </a>
    </span>
    url_decode()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::url_decode
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Encodes each string using URL encoding.
     </p>
     <p>
      Converts all character sequences starting with '' into character code-points interpreting the 2 following characters as hex values to create the code-point. For example, the sequence '%20' is converted into byte (0x20) which is a single space character. Another example converts 'C3A9' into 2 sequential bytes (0xc3 and 0xa9 respectively). Overall, 3 characters are converted into one char byte whenever a '' character is encountered in the string.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="adb3b94151cb452ee3b2daf3f8dbccb54">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#adb3b94151cb452ee3b2daf3f8dbccb54">
      ◆
     </a>
    </span>
    url_encode()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::url_encode
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Decodes each string using URL encoding.
     </p>
     <p>
      Converts mostly non-ascii characters and control characters into UTF-8 hex code-points prefixed with ''. For example, the space character must be converted to characters '%20' where the '20' indicates the hex value for space in UTF-8. Likewise, multi-byte characters are converted to multiple hex charactes. For example, the é character is converted to characters 'C3A9' where 'C3A9' is the UTF-8 bytes 0xC3A9 for this character.
     </p>
     <p>
      Any null entries will result in corresponding null entries in the output column.
     </p>
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New strings column.
      </dd>
     </dl>
    </div>
   </div>
   <a id="afe8a9627c637f2ad8068de95bae147c7">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#afe8a9627c637f2ad8068de95bae147c7">
      ◆
     </a>
    </span>
    wrap()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::wrap
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         width
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Wraps strings onto multiple lines shorter than
      <code>
       width
      </code>
      by replacing appropriate white space with new-line characters (ASCII 0x0A).
     </p>
     <p>
      For each string row in the input column longer than
      <code>
       width
      </code>
      , the corresponding output string row will have newline characters inserted so that each line is no more than
      <code>
       width characters
      </code>
      . Attempts to use existing white space locations to split the strings, but may split non-white-space sequences if necessary.
      <br/>
     </p>
     <p>
      Any null string entries return corresponding null output column entries.
     </p>
     <p>
      Example 1:
     </p>
     <div class="fragment">
      <div class="line">
       width = 3
      </div>
      <div class="line">
       input_string_tbl = [
       <span class="stringliteral">
        "12345"
       </span>
       ,
       <span class="stringliteral">
        "thesé"
       </span>
       ,
       <span class="keyword">
        nullptr
       </span>
       ,
       <span class="stringliteral">
        "ARE THE"
       </span>
       ,
       <span class="stringliteral">
        "tést strings"
       </span>
       ,
       <span class="stringliteral">
        ""
       </span>
       ];
      </div>
      <div class="line">
      </div>
      <div class="line">
       wrapped_string_tbl =
       <a class="code" href="namespacecudf_1_1strings.html#afe8a9627c637f2ad8068de95bae147c7">
        wrap
       </a>
       (input_string_tbl, width)
      </div>
      <div class="line">
       wrapped_string_tbl = [
       <span class="stringliteral">
        "12345"
       </span>
       ,
       <span class="stringliteral">
        "thesé"
       </span>
       ,
       <span class="keyword">
        nullptr
       </span>
       ,
       <span class="stringliteral">
        "ARE\nTHE"
       </span>
       ,
       <span class="stringliteral">
        "tést\nstrings"
       </span>
       ,
       <span class="stringliteral">
        ""
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <p>
      Example 2:
     </p>
     <div class="fragment">
      <div class="line">
       width = 12;
      </div>
      <div class="line">
       input_string_tbl = [
       <span class="stringliteral">
        "the quick brown fox jumped over the lazy brown dog"
       </span>
       ,
       <span class="stringliteral">
        "hello, world"
       </span>
       ]
      </div>
      <div class="line">
      </div>
      <div class="line">
       wrapped_string_tbl =
       <a class="code" href="namespacecudf_1_1strings.html#afe8a9627c637f2ad8068de95bae147c7">
        wrap
       </a>
       (input_string_tbl, width)
      </div>
      <div class="line">
       wrapped_string_tbl = [
       <span class="stringliteral">
        "the quick\nbrown fox\njumped over\nthe lazy\nbrown dog"
       </span>
       ,
       <span class="stringliteral">
        "hello, world"
       </span>
       ]
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          strings
         </td>
         <td>
          String column.
         </td>
        </tr>
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          width
         </td>
         <td>
          Maximum chararacter width of a line within each string.
         </td>
        </tr>
        <tr>
         <td class="paramdir">
          [in]
         </td>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       Column of wrapped strings.
      </dd>
     </dl>
    </div>
   </div>
   <a id="a4d265b414cf6c921ff7ceabc99aeef57">
   </a>
   <h2 class="memtitle">
    <span class="permalink">
     <a href="#a4d265b414cf6c921ff7ceabc99aeef57">
      ◆
     </a>
    </span>
    zfill()
   </h2>
   <div class="memitem">
    <div class="memproto">
     <table class="memname">
      <tr>
       <td class="memname">
        std::unique_ptr&lt;
        <a class="el" href="classcudf_1_1column.html">
         column
        </a>
        &gt; cudf::strings::zfill
       </td>
       <td>
        (
       </td>
       <td class="paramtype">
        <a class="el" href="classcudf_1_1strings__column__view.html">
         strings_column_view
        </a>
        const &amp;
       </td>
       <td class="paramname">
        <em>
         strings
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        size_type
       </td>
       <td class="paramname">
        <em>
         width
        </em>
        ,
       </td>
      </tr>
      <tr>
       <td class="paramkey">
       </td>
       <td>
       </td>
       <td class="paramtype">
        rmm::mr::device_memory_resource *
       </td>
       <td class="paramname">
        <em>
         mr
        </em>
        =
        <code>
         rmm::mr::get_default_resource()
        </code>
       </td>
      </tr>
      <tr>
       <td>
       </td>
       <td>
        )
       </td>
       <td>
       </td>
       <td>
       </td>
      </tr>
     </table>
    </div>
    <div class="memdoc">
     <p>
      Add '0' as padding to the left of each string.
     </p>
     <p>
      If the string is already width or more characters, no padding is performed. No strings are truncated.
     </p>
     <p>
      This equivalent to ‘pad(width,left,'0’)` but is more optimized for this special case.
     </p>
     <p>
      Null string entries result in null entries in the output column.
     </p>
     <div class="fragment">
      <div class="line">
       s = [
       <span class="stringliteral">
        '1234'
       </span>
       ,
       <span class="stringliteral">
        '-9876'
       </span>
       ,
       <span class="stringliteral">
        '+0.34'
       </span>
       ,
       <span class="stringliteral">
        '-342567'
       </span>
       ]
      </div>
      <div class="line">
       r =
       <a class="code" href="namespacecudf_1_1strings.html#a4d265b414cf6c921ff7ceabc99aeef57">
        zfill
       </a>
       (s,6)
      </div>
      <div class="line">
       r is now ['001234','0-9876','0+0.34','-342567']
      </div>
     </div>
     <!-- fragment -->
     <dl class="params">
      <dt>
       Parameters
      </dt>
      <dd>
       <table class="params">
        <tr>
         <td class="paramname">
          strings
         </td>
         <td>
          Strings instance for this operation.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          width
         </td>
         <td>
          The minimum number of characters for each string.
         </td>
        </tr>
        <tr>
         <td class="paramname">
          mr
         </td>
         <td>
          Resource for allocating device memory.
         </td>
        </tr>
       </table>
      </dd>
     </dl>
     <dl class="section return">
      <dt>
       Returns
      </dt>
      <dd>
       New column of strings.
      </dd>
     </dl>
    </div>
   </div>
  </div>
  <!-- contents -->
  <div class="ttc" id="anamespacecudf_1_1strings_html_a4fd98e6c74474f5686abe7df409e7d0e">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a4fd98e6c74474f5686abe7df409e7d0e">
     cudf::strings::concatenate
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; concatenate(table_view const &amp;strings_columns, string_scalar const &amp;separator, string_scalar const &amp;narep, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Row-wise concatenates the given list of strings columns and returns a single strings column result.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    combine.cu:229
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a4d265b414cf6c921ff7ceabc99aeef57">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a4d265b414cf6c921ff7ceabc99aeef57">
     cudf::strings::zfill
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; zfill(strings_column_view const &amp;strings, size_type width, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Add '0' as padding to the left of each string.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    padding.cu:205
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a4f1989aea0aa5e69c1b8559811877570">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a4f1989aea0aa5e69c1b8559811877570">
     cudf::strings::pad
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; pad(strings_column_view const &amp;strings, size_type width, pad_side side, std::string const &amp;fill_char, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Add padding to each string using a provided character.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    padding.cu:196
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a50d5f0b7b88e886b137e23370b7a8045">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a50d5f0b7b88e886b137e23370b7a8045">
     cudf::strings::translate
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; translate(strings_column_view const &amp;strings, std::vector&lt; std::pair&lt; uint32_t, uint32_t &gt;&gt; const &amp;chars_table, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Translates individual characters within each string.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    translate.cu:127
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_acf8d376612ac5b0d7f524806b0d4b65b">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#acf8d376612ac5b0d7f524806b0d4b65b">
     cudf::strings::replace_nulls
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; replace_nulls(strings_column_view const &amp;strings, string_scalar const &amp;repl, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Replaces any null string entries with the given string.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    strings/replace/replace.cu:407
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_aa14e7275a271183be10919c1042516e7">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#aa14e7275a271183be10919c1042516e7">
     cudf::strings::find_multiple
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; find_multiple(strings_column_view const &amp;strings, strings_column_view const &amp;targets, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Returns a column with character position values where each of the target strings are found in each st...
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    find_multiple.cu:76
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_afe8a9627c637f2ad8068de95bae147c7">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#afe8a9627c637f2ad8068de95bae147c7">
     cudf::strings::wrap
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; wrap(strings_column_view const &amp;strings, size_type width, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Wraps strings onto multiple lines shorter than width by replacing appropriate white space with new-li...
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    wrap.cu:143
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_afeeda8580beff9f9f486fbc540e8e2b4">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#afeeda8580beff9f9f486fbc540e8e2b4">
     cudf::strings::strip
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; strip(strings_column_view const &amp;strings, strip_type stype, string_scalar const &amp;to_strip, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Removes the specified characters from the beginning or end (or both) of each string.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    strip.cu:163
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a6761e18983d2a3279525264407273f18">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a6761e18983d2a3279525264407273f18">
     cudf::strings::contains
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; contains(strings_column_view const &amp;strings, string_scalar const &amp;target, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Returns a column of boolean values for each string where true indicates the target string was found w...
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    find.cu:261
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a452d1ce407f311d8b22d226db9a5b1b7">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a452d1ce407f311d8b22d226db9a5b1b7">
     cudf::strings::replace
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; replace(strings_column_view const &amp;strings, string_scalar const &amp;target, string_scalar const &amp;repl, int32_t maxrepl, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Replaces target string within each string with the specified replacement string.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    strings/replace/replace.cu:379
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a024af33f3d9718f6990e0ef4581bf77a">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a024af33f3d9718f6990e0ef4581bf77a">
     cudf::strings::rpartition
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; experimental::table &gt; rpartition(strings_column_view const &amp;strings, string_scalar const &amp;delimiter, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Returns a set of 3 columns by splitting each string using the specified delimiter starting from the e...
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    partition.cu:242
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_a8c5b1014dcd65e3ebbd00a57c26a5ce6">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#a8c5b1014dcd65e3ebbd00a57c26a5ce6">
     cudf::strings::extract
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; experimental::table &gt; extract(strings_column_view const &amp;strings, std::string const &amp;pattern, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Returns a vector of strings columns for each matching group specified in the given regular expression...
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    extract.cu:129
   </div>
  </div>
  <div class="ttc" id="anamespacecudf_1_1strings_html_ab6a77478fadde8b86e5a165283db03d3">
   <div class="ttname">
    <a href="namespacecudf_1_1strings.html#ab6a77478fadde8b86e5a165283db03d3">
     cudf::strings::join_strings
    </a>
   </div>
   <div class="ttdeci">
    std::unique_ptr&lt; column &gt; join_strings(strings_column_view const &amp;strings, string_scalar const &amp;separator, string_scalar const &amp;narep, rmm::mr::device_memory_resource *mr)
   </div>
   <div class="ttdoc">
    Concatenates all strings in the column into one new string delimited by an optional separator string.
   </div>
   <div class="ttdef">
    <b>
     Definition:
    </b>
    combine.cu:238
   </div>
  </div>
  <!-- start footer part -->
  <hr class="footer"/>
  <address class="footer">
   <small>
    Generated by
    <a href="http://www.doxygen.org/index.html">
     <img alt="doxygen" class="footer" src="doxygen.png"/>
    </a>
    1.8.16
   </small>
  </address>
  <script defer id="rapids-selector-js" src="/assets/js/custom.js">
  </script>
 </body>
</html>
