<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.18" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcudf: Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcuml/nightly">libcuml</a><a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">libnvstrings</a><a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">nvstrings</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (0.14)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcudf/nightly/namespacecudf.html">nightly (0.14)</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">stable (0.13)</a><a class="rapids-selector__menu-item" href="/api/libcudf/legacy/namespacecudf.html">legacy (0.12)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">Types<div class="ingroups"><a class="el" href="group__utility__apis.html">Utilities</a></div></div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecudf_1_1experimental"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecudf_1_1experimental.html">cudf::experimental</a></td></tr>
<tr class="memdesc:namespacecudf_1_1experimental"><td class="mdescLeft"> </td><td class="mdescRight">In-development features. <br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1order__info.html">cudf::order_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Indicates how a collection of values has been ordered.  <a href="structcudf_1_1order__info.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classcudf_1_1data__type.html">cudf::data_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Indicator for the logical data type of an element in a column.  <a href="classcudf_1_1data__type.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__relationally__comparable__impl.html">cudf::is_relationally_comparable_impl&lt; L, R, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__relationally__comparable__impl_3_01L_00_01R_00_01void__t_3_01less__comparable_e55590d6a511f5004b91a7c1dc07c638.html">cudf::is_relationally_comparable_impl&lt; L, R, void_t&lt; less_comparable&lt; L, R &gt;, greater_comparable&lt; L, R &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__equality__comparable__impl.html">cudf::is_equality_comparable_impl&lt; L, R, typename &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__equality__comparable__impl_3_01L_00_01R_00_01void__t_3_01equality__comparable_3_01L_00_01R_01_4_01_4_01_4.html">cudf::is_equality_comparable_impl&lt; L, R, void_t&lt; equality_comparable&lt; L, R &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__numeric__impl.html">cudf::is_numeric_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__boolean__impl.html">cudf::is_boolean_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__timestamp__impl.html">cudf::is_timestamp_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__fixed__width__impl.html">cudf::is_fixed_width_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__compound__impl.html">cudf::is_compound_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__simple__impl.html">cudf::is_simple_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcudf_1_1is__nested__impl.html">cudf::is_nested_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0aff16b2db009d92300befaca11827e9"><td align="right" class="memItemLeft" valign="top"><a id="ga0aff16b2db009d92300befaca11827e9"></a>
using </td><td class="memItemRight" valign="bottom"><b>cudf::size_type</b> = int32_t</td></tr>
<tr class="separator:ga0aff16b2db009d92300befaca11827e9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1d17001baf070a639c3a5e8ed8c46d34"><td align="right" class="memItemLeft" valign="top"><a id="ga1d17001baf070a639c3a5e8ed8c46d34"></a>
using </td><td class="memItemRight" valign="bottom"><b>cudf::bitmask_type</b> = uint32_t</td></tr>
<tr class="separator:ga1d17001baf070a639c3a5e8ed8c46d34"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9b06145972e36cd6b4d72ad20dd10ac1"><td align="right" class="memItemLeft" valign="top"><a id="ga9b06145972e36cd6b4d72ad20dd10ac1"></a>
using </td><td class="memItemRight" valign="bottom"><b>cudf::valid_type</b> = uint8_t</td></tr>
<tr class="separator:ga9b06145972e36cd6b4d72ad20dd10ac1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga9130d674f5ef432c1405fadd304a8c26"><td class="memTemplParams" colspan="2"><a id="ga9130d674f5ef432c1405fadd304a8c26"></a>
template&lt;typename... &gt; </td></tr>
<tr class="memitem:ga9130d674f5ef432c1405fadd304a8c26"><td align="right" class="memTemplItemLeft" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>cudf::void_t</b> = void</td></tr>
<tr class="separator:ga9130d674f5ef432c1405fadd304a8c26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga6cc1c1fe68e5031f9865b4d9114a2491"><td class="memTemplParams" colspan="2"><a id="ga6cc1c1fe68e5031f9865b4d9114a2491"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga6cc1c1fe68e5031f9865b4d9114a2491"><td align="right" class="memTemplItemLeft" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>cudf::less_comparable</b> = decltype(std::declval&lt; L &gt;()&lt; std::declval&lt; R &gt;())</td></tr>
<tr class="separator:ga6cc1c1fe68e5031f9865b4d9114a2491"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga19a5866cc4b46bbff21bf863130d2f81"><td class="memTemplParams" colspan="2"><a id="ga19a5866cc4b46bbff21bf863130d2f81"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga19a5866cc4b46bbff21bf863130d2f81"><td align="right" class="memTemplItemLeft" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>cudf::greater_comparable</b> = decltype(std::declval&lt; L &gt;() &gt; std::declval&lt; R &gt;())</td></tr>
<tr class="separator:ga19a5866cc4b46bbff21bf863130d2f81"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga33f2db79a6c26d5d69a3c05cd057cee0"><td class="memTemplParams" colspan="2"><a id="ga33f2db79a6c26d5d69a3c05cd057cee0"></a>
template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga33f2db79a6c26d5d69a3c05cd057cee0"><td align="right" class="memTemplItemLeft" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>cudf::equality_comparable</b> = decltype(std::declval&lt; L &gt;()==std::declval&lt; R &gt;())</td></tr>
<tr class="separator:ga33f2db79a6c26d5d69a3c05cd057cee0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad526c171443c20535cc6cb3a6085af0b"><td class="memTemplParams" colspan="2"><a id="gad526c171443c20535cc6cb3a6085af0b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad526c171443c20535cc6cb3a6085af0b"><td align="right" class="memTemplItemLeft" valign="top">using </td><td class="memTemplItemRight" valign="bottom"><b>cudf::is_timestamp_t</b> = simt::std::disjunction&lt; std::is_same&lt; <a class="el" href="group__timestamp__classes.html#gac82c6b399fba68b7cc0fbfdfcf17ff41">cudf::timestamp_D</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga3cc116df95ee68f4ed4689cf36a1f792">cudf::timestamp_s</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga1e65b98c47669295653e4fe59b66fe34">cudf::timestamp_ms</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga0455750f053fbc9234bd7f1478a8b8a2">cudf::timestamp_us</a>, T &gt;, std::is_same&lt; <a class="el" href="group__timestamp__classes.html#ga8090bb1d4eb05e199337b8e98fcdddbf">cudf::timestamp_ns</a>, T &gt; &gt;</td></tr>
<tr class="separator:gad526c171443c20535cc6cb3a6085af0b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga750f02016b046079f7062d334890b4fc"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> : bool { <a class="el" href="group__utility__types.html#gga750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32">cudf::order::ASCENDING</a>, 
<a class="el" href="group__utility__types.html#gga750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53">cudf::order::DESCENDING</a>
 }</td></tr>
<tr class="memdesc:ga750f02016b046079f7062d334890b4fc"><td class="mdescLeft"> </td><td class="mdescRight">Indicates the order in which elements should be sorted.  <a href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">More...</a><br/></td></tr>
<tr class="separator:ga750f02016b046079f7062d334890b4fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga1b8cda4afb95a7c42c4679b4fae61009"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">cudf::null_policy</a> : bool { <a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8">cudf::null_policy::EXCLUDE</a>, 
<a class="el" href="group__utility__types.html#gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8">cudf::null_policy::INCLUDE</a>
 }</td></tr>
<tr class="memdesc:ga1b8cda4afb95a7c42c4679b4fae61009"><td class="mdescLeft"> </td><td class="mdescRight">Enum to specify whether to include nulls or exclude nulls.  <a href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">More...</a><br/></td></tr>
<tr class="separator:ga1b8cda4afb95a7c42c4679b4fae61009"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga74641d3dfd6d96d0939b492ecf9b9cc8"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">cudf::nan_policy</a> : bool { <a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4">cudf::nan_policy::NAN_IS_NULL</a>, 
<a class="el" href="group__utility__types.html#gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77">cudf::nan_policy::NAN_IS_VALID</a>
 }</td></tr>
<tr class="memdesc:ga74641d3dfd6d96d0939b492ecf9b9cc8"><td class="mdescLeft"> </td><td class="mdescRight">Enum to treat NaN floating point value as null or non-null element.  <a href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">More...</a><br/></td></tr>
<tr class="separator:ga74641d3dfd6d96d0939b492ecf9b9cc8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga08a672308cd0f61562410d106b377771"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">cudf::null_equality</a> : bool { <a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44">cudf::null_equality::EQUAL</a>, 
<a class="el" href="group__utility__types.html#gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac">cudf::null_equality::UNEQUAL</a>
 }</td></tr>
<tr class="separator:ga08a672308cd0f61562410d106b377771"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga058e6d6e8a21583ce0e85ee73e5abb31"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> : bool { <a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb">cudf::null_order::AFTER</a>, 
<a class="el" href="group__utility__types.html#gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07">cudf::null_order::BEFORE</a>
 }</td></tr>
<tr class="memdesc:ga058e6d6e8a21583ce0e85ee73e5abb31"><td class="mdescLeft"> </td><td class="mdescRight">Indicates how null values compare against all other values.  <a href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">More...</a><br/></td></tr>
<tr class="separator:ga058e6d6e8a21583ce0e85ee73e5abb31"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gab283c517931abd4152ffa62fec62425d"><td align="right" class="memItemLeft" valign="top"><a id="gab283c517931abd4152ffa62fec62425d"></a>enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gab283c517931abd4152ffa62fec62425d">cudf::sorted</a> : bool { <b>NO</b>, 
<b>YES</b>
 }</td></tr>
<tr class="memdesc:gab283c517931abd4152ffa62fec62425d"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether a collection of values is known to be sorted. <br/></td></tr>
<tr class="separator:gab283c517931abd4152ffa62fec62425d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga4daf20c000ab374d76f4d56f0ddb7b26"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">cudf::mask_state</a> : int32_t { <a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80">cudf::mask_state::UNALLOCATED</a>, 
<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26add652546039b18970b8dcf2cff824268">cudf::mask_state::UNINITIALIZED</a>, 
<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26a00a0fd1f61b5bd5c53628de693967e08">cudf::mask_state::ALL_VALID</a>, 
<a class="el" href="group__utility__types.html#gga4daf20c000ab374d76f4d56f0ddb7b26ab8a690c8c67b400079b43eb5a2146753">cudf::mask_state::ALL_NULL</a>
 }</td></tr>
<tr class="memdesc:ga4daf20c000ab374d76f4d56f0ddb7b26"><td class="mdescLeft"> </td><td class="mdescRight">Controls the allocation/initialization of a null mask.  <a href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">More...</a><br/></td></tr>
<tr class="separator:ga4daf20c000ab374d76f4d56f0ddb7b26"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga7f32c8210bb99fa8f28b23fd359e2e8b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga7f32c8210bb99fa8f28b23fd359e2e8b">cudf::experimental::interpolation</a> : int32_t { <br/>
  <a class="el" href="group__utility__types.html#gga7f32c8210bb99fa8f28b23fd359e2e8baaac544aacc3615aada24897a215f5046">cudf::experimental::interpolation::LINEAR</a>, 
<a class="el" href="group__utility__types.html#gga7f32c8210bb99fa8f28b23fd359e2e8baa7c48ba367e019d004bfb0239b85f2b3">cudf::experimental::interpolation::LOWER</a>, 
<a class="el" href="group__utility__types.html#gga7f32c8210bb99fa8f28b23fd359e2e8ba5bc0a7ce2c77ccd49169277e9289e5d1">cudf::experimental::interpolation::HIGHER</a>, 
<a class="el" href="group__utility__types.html#gga7f32c8210bb99fa8f28b23fd359e2e8baafa8fd4b90a3f8123b4bd30446518a7e">cudf::experimental::interpolation::MIDPOINT</a>, 
<br/>
  <a class="el" href="group__utility__types.html#gga7f32c8210bb99fa8f28b23fd359e2e8baad135772d7cf93dd0ccf9d2474b34e6a">cudf::experimental::interpolation::NEAREST</a>
<br/>
 }</td></tr>
<tr class="memdesc:ga7f32c8210bb99fa8f28b23fd359e2e8b"><td class="mdescLeft"> </td><td class="mdescRight">Interpolation method to use when the desired quantile lies between two data points i and j.  <a href="group__utility__types.html#ga7f32c8210bb99fa8f28b23fd359e2e8b">More...</a><br/></td></tr>
<tr class="separator:ga7f32c8210bb99fa8f28b23fd359e2e8b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacd4cd7157c4379954b5772936f89c59b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gacd4cd7157c4379954b5772936f89c59b">cudf::type_id</a> { <br/>
  <a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59bab2c14e467fcbf9a215ccc679f35bb027">cudf::EMPTY</a> = 0, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba71f4b0467efae61c1e3ac5910178940f">cudf::INT8</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba7dafa1ea3755308998ff8c972342c099">cudf::INT16</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae">cudf::INT32</a>, 
<br/>
  <a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59bab9c234f82eec5cb83e3ea67aac9c1166">cudf::INT64</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba37225001c5ad4b3d1aa808620debfe7a">cudf::FLOAT32</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59baf24707a0d5537fd50bca87cd18a9a0e5">cudf::FLOAT64</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba9100ee556e5cf9b6dada6c7c506fa138">cudf::BOOL8</a>, 
<br/>
  <a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba8a653791c2c90530cd2452ef46a01ab2">cudf::TIMESTAMP_DAYS</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba75e3c065f03583dc3b94ec069c4fe34d">cudf::TIMESTAMP_SECONDS</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba5cb4e0f1d7d608d8801707a376e43b64">cudf::TIMESTAMP_MILLISECONDS</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59bab892ce722f86206a6496700f2c4a3abf">cudf::TIMESTAMP_MICROSECONDS</a>, 
<br/>
  <a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba9864c6a53387a840e7c6ed2672fed2c9">cudf::TIMESTAMP_NANOSECONDS</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba6c8d7b96f965a120e818925f750fc499">cudf::DICTIONARY32</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59bae008ab0db4e9b28f33e1e3c9c3daf444">cudf::STRING</a>, 
<a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59bae483076112011f632916ad85a059d6c3">cudf::LIST</a>, 
<br/>
  <a class="el" href="group__utility__types.html#ggacd4cd7157c4379954b5772936f89c59ba0f6b1e874ab643a0f237082cb35acad5">cudf::NUM_TYPE_IDS</a>
<br/>
 }</td></tr>
<tr class="memdesc:gacd4cd7157c4379954b5772936f89c59b"><td class="mdescLeft"> </td><td class="mdescRight">Identifies a column's logical element type.  <a href="group__utility__types.html#gacd4cd7157c4379954b5772936f89c59b">More...</a><br/></td></tr>
<tr class="separator:gacd4cd7157c4379954b5772936f89c59b"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaa5bd500e54a0760773f941986e8e056b"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaa5bd500e54a0760773f941986e8e056b">cudf::operator==</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;lhs, <a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp;rhs)</td></tr>
<tr class="memdesc:gaa5bd500e54a0760773f941986e8e056b"><td class="mdescLeft"> </td><td class="mdescRight">Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality.  <a href="group__utility__types.html#gaa5bd500e54a0760773f941986e8e056b">More...</a><br/></td></tr>
<tr class="separator:gaa5bd500e54a0760773f941986e8e056b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga51b0daf2c01663d51cb3b87ad8ce93c0"><td align="right" class="memItemLeft" valign="top">std::size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga51b0daf2c01663d51cb3b87ad8ce93c0">cudf::size_of</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> t)</td></tr>
<tr class="memdesc:ga51b0daf2c01663d51cb3b87ad8ce93c0"><td class="mdescLeft"> </td><td class="mdescRight">Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> <a href="group__utility__types.html#ga51b0daf2c01663d51cb3b87ad8ce93c0">More...</a><br/></td></tr>
<tr class="separator:ga51b0daf2c01663d51cb3b87ad8ce93c0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaef9b08b206b1340c5ac3893d17943309"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:gaef9b08b206b1340c5ac3893d17943309"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaef9b08b206b1340c5ac3893d17943309">cudf::is_relationally_comparable</a> ()</td></tr>
<tr class="memdesc:gaef9b08b206b1340c5ac3893d17943309"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared.  <a href="group__utility__types.html#gaef9b08b206b1340c5ac3893d17943309">More...</a><br/></td></tr>
<tr class="separator:gaef9b08b206b1340c5ac3893d17943309"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga82f7470f89e1e2b53077246712787120"><td class="memTemplParams" colspan="2">template&lt;typename L , typename R &gt; </td></tr>
<tr class="memitem:ga82f7470f89e1e2b53077246712787120"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga82f7470f89e1e2b53077246712787120">cudf::is_equality_comparable</a> ()</td></tr>
<tr class="memdesc:ga82f7470f89e1e2b53077246712787120"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether objects of types <code>L</code> and <code>R</code> can be compared for equality.  <a href="group__utility__types.html#ga82f7470f89e1e2b53077246712787120">More...</a><br/></td></tr>
<tr class="separator:ga82f7470f89e1e2b53077246712787120"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga736c39af324b57534639bd3d8af357e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga736c39af324b57534639bd3d8af357e4"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga736c39af324b57534639bd3d8af357e4">cudf::is_numeric</a> ()</td></tr>
<tr class="memdesc:ga736c39af324b57534639bd3d8af357e4"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether the type <code>T</code> is a numeric type.  <a href="group__utility__types.html#ga736c39af324b57534639bd3d8af357e4">More...</a><br/></td></tr>
<tr class="separator:ga736c39af324b57534639bd3d8af357e4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gac193df7b5be153a88978c2e6564bf4f2"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gac193df7b5be153a88978c2e6564bf4f2">cudf::is_numeric</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gac193df7b5be153a88978c2e6564bf4f2"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="group__utility__types.html#gac193df7b5be153a88978c2e6564bf4f2">More...</a><br/></td></tr>
<tr class="separator:gac193df7b5be153a88978c2e6564bf4f2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1b9dd3a6ee95fa52224a53869cd164e"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaa1b9dd3a6ee95fa52224a53869cd164e">cudf::is_boolean</a> ()</td></tr>
<tr class="memdesc:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether <code>T</code> is a Boolean type.  <a href="group__utility__types.html#gaa1b9dd3a6ee95fa52224a53869cd164e">More...</a><br/></td></tr>
<tr class="separator:gaa1b9dd3a6ee95fa52224a53869cd164e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga96675e30be80f4236360466adcf9a70c"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga96675e30be80f4236360466adcf9a70c">cudf::is_boolean</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga96675e30be80f4236360466adcf9a70c"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether <code>type</code> is a Boolean <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="group__utility__types.html#ga96675e30be80f4236360466adcf9a70c">More...</a><br/></td></tr>
<tr class="separator:ga96675e30be80f4236360466adcf9a70c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga90ebb90931abfed637396889b7829173"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga90ebb90931abfed637396889b7829173"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga90ebb90931abfed637396889b7829173">cudf::is_timestamp</a> ()</td></tr>
<tr class="memdesc:ga90ebb90931abfed637396889b7829173"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether the type <code>T</code> is a timestamp type.  <a href="group__utility__types.html#ga90ebb90931abfed637396889b7829173">More...</a><br/></td></tr>
<tr class="separator:ga90ebb90931abfed637396889b7829173"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga96f7b448c30ecbce54e8c1243ccc8c4d"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga96f7b448c30ecbce54e8c1243ccc8c4d">cudf::is_timestamp</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga96f7b448c30ecbce54e8c1243ccc8c4d"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether <code>type</code> is a timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>.  <a href="group__utility__types.html#ga96f7b448c30ecbce54e8c1243ccc8c4d">More...</a><br/></td></tr>
<tr class="separator:ga96f7b448c30ecbce54e8c1243ccc8c4d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaaa937abead085ea9420b15c6473f08a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaa937abead085ea9420b15c6473f08a7"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gaaa937abead085ea9420b15c6473f08a7">cudf::is_fixed_width</a> ()</td></tr>
<tr class="memdesc:gaaa937abead085ea9420b15c6473f08a7"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether elements of type <code>T</code> are fixed-width.  <a href="group__utility__types.html#gaaa937abead085ea9420b15c6473f08a7">More...</a><br/></td></tr>
<tr class="separator:gaaa937abead085ea9420b15c6473f08a7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga347d883100d3f7c725ad64c649f59c11"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga347d883100d3f7c725ad64c649f59c11">cudf::is_fixed_width</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga347d883100d3f7c725ad64c649f59c11"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether elements of <code>type</code> are fixed-width.  <a href="group__utility__types.html#ga347d883100d3f7c725ad64c649f59c11">More...</a><br/></td></tr>
<tr class="separator:ga347d883100d3f7c725ad64c649f59c11"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga14e1cea4200d1d92d7f38d596333d28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga14e1cea4200d1d92d7f38d596333d28a"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga14e1cea4200d1d92d7f38d596333d28a">cudf::is_compound</a> ()</td></tr>
<tr class="memdesc:ga14e1cea4200d1d92d7f38d596333d28a"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether the type <code>T</code> is a compound type.  <a href="group__utility__types.html#ga14e1cea4200d1d92d7f38d596333d28a">More...</a><br/></td></tr>
<tr class="separator:ga14e1cea4200d1d92d7f38d596333d28a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad7f296c6fe2b6ae35ac59e41cbf1487d"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gad7f296c6fe2b6ae35ac59e41cbf1487d">cudf::is_compound</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether elements of <code>type</code> are compound.  <a href="group__utility__types.html#gad7f296c6fe2b6ae35ac59e41cbf1487d">More...</a><br/></td></tr>
<tr class="separator:gad7f296c6fe2b6ae35ac59e41cbf1487d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad15f075ce6421723e214c0d153fe695f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad15f075ce6421723e214c0d153fe695f"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gad15f075ce6421723e214c0d153fe695f">cudf::is_simple</a> ()</td></tr>
<tr class="memdesc:gad15f075ce6421723e214c0d153fe695f"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether the type <code>T</code> is a simple type.  <a href="group__utility__types.html#gad15f075ce6421723e214c0d153fe695f">More...</a><br/></td></tr>
<tr class="separator:gad15f075ce6421723e214c0d153fe695f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae6e62b8bc2981be767ae3f6843877956"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gae6e62b8bc2981be767ae3f6843877956">cudf::is_simple</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:gae6e62b8bc2981be767ae3f6843877956"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether elements of <code>type</code> are simple.  <a href="group__utility__types.html#gae6e62b8bc2981be767ae3f6843877956">More...</a><br/></td></tr>
<tr class="separator:gae6e62b8bc2981be767ae3f6843877956"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacaa242e2e068ab62bdaae071ed748357"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gacaa242e2e068ab62bdaae071ed748357"><td align="right" class="memTemplItemLeft" valign="top">constexpr bool </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__utility__types.html#gacaa242e2e068ab62bdaae071ed748357">cudf::is_nested</a> ()</td></tr>
<tr class="memdesc:gacaa242e2e068ab62bdaae071ed748357"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether <code>T</code> is a nested type.  <a href="group__utility__types.html#gacaa242e2e068ab62bdaae071ed748357">More...</a><br/></td></tr>
<tr class="separator:gacaa242e2e068ab62bdaae071ed748357"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga78ef9ab51afae8235ee8b18f82cc8107"><td align="right" class="memItemLeft" valign="top">constexpr bool </td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__types.html#ga78ef9ab51afae8235ee8b18f82cc8107">cudf::is_nested</a> (<a class="el" href="classcudf_1_1data__type.html">data_type</a> type)</td></tr>
<tr class="memdesc:ga78ef9ab51afae8235ee8b18f82cc8107"><td class="mdescLeft"> </td><td class="mdescRight">Indicates whether <code>type</code> is a nested type.  <a href="group__utility__types.html#ga78ef9ab51afae8235ee8b18f82cc8107">More...</a><br/></td></tr>
<tr class="separator:ga78ef9ab51afae8235ee8b18f82cc8107"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7f32c8210bb99fa8f28b23fd359e2e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f32c8210bb99fa8f28b23fd359e2e8b">◆ </a></span>interpolation</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga7f32c8210bb99fa8f28b23fd359e2e8b">cudf::experimental::interpolation</a> : int32_t</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Interpolation method to use when the desired quantile lies between two data points i and j. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7f32c8210bb99fa8f28b23fd359e2e8baaac544aacc3615aada24897a215f5046"></a>LINEAR </td><td class="fielddoc"><p>Linear interpolation between i and j. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7f32c8210bb99fa8f28b23fd359e2e8baa7c48ba367e019d004bfb0239b85f2b3"></a>LOWER </td><td class="fielddoc"><p>Lower data point (i) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7f32c8210bb99fa8f28b23fd359e2e8ba5bc0a7ce2c77ccd49169277e9289e5d1"></a>HIGHER </td><td class="fielddoc"><p>Higher data point (j) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7f32c8210bb99fa8f28b23fd359e2e8baafa8fd4b90a3f8123b4bd30446518a7e"></a>MIDPOINT </td><td class="fielddoc"><p>(i + j)/2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7f32c8210bb99fa8f28b23fd359e2e8baad135772d7cf93dd0ccf9d2474b34e6a"></a>NEAREST </td><td class="fielddoc"><p>i or j, whichever is nearest </p>
</td></tr>
</table>
</div>
</div>
<a id="ga4daf20c000ab374d76f4d56f0ddb7b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4daf20c000ab374d76f4d56f0ddb7b26">◆ </a></span>mask_state</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga4daf20c000ab374d76f4d56f0ddb7b26">cudf::mask_state</a> : int32_t</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Controls the allocation/initialization of a null mask. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4daf20c000ab374d76f4d56f0ddb7b26a628732521c22dcf8a24bf1a0326bde80"></a>UNALLOCATED </td><td class="fielddoc"><p>Null mask not allocated, (all elements are valid) </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4daf20c000ab374d76f4d56f0ddb7b26add652546039b18970b8dcf2cff824268"></a>UNINITIALIZED </td><td class="fielddoc"><p>Null mask allocated, but not initialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4daf20c000ab374d76f4d56f0ddb7b26a00a0fd1f61b5bd5c53628de693967e08"></a>ALL_VALID </td><td class="fielddoc"><p>Null mask allocated, initialized to all elements valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4daf20c000ab374d76f4d56f0ddb7b26ab8a690c8c67b400079b43eb5a2146753"></a>ALL_NULL </td><td class="fielddoc"><p>Null mask allocated, initialized to all elements NULL. </p>
</td></tr>
</table>
</div>
</div>
<a id="ga74641d3dfd6d96d0939b492ecf9b9cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74641d3dfd6d96d0939b492ecf9b9cc8">◆ </a></span>nan_policy</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga74641d3dfd6d96d0939b492ecf9b9cc8">cudf::nan_policy</a> : bool</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Enum to treat NaN floating point value as null or non-null element. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga74641d3dfd6d96d0939b492ecf9b9cc8aeed6bbfa0697c54960c7e0baa97313f4"></a>NAN_IS_NULL </td><td class="fielddoc"><p>treat nans as null elements </p>
</td></tr>
<tr><td class="fieldname"><a id="gga74641d3dfd6d96d0939b492ecf9b9cc8a27adbe26caa2eb99976344933c281a77"></a>NAN_IS_VALID </td><td class="fielddoc"><p>treat nans as valid elements (non-null) </p>
</td></tr>
</table>
</div>
</div>
<a id="ga08a672308cd0f61562410d106b377771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08a672308cd0f61562410d106b377771">◆ </a></span>null_equality</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga08a672308cd0f61562410d106b377771">cudf::null_equality</a> : bool</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga08a672308cd0f61562410d106b377771a969f331a87d8c958473c32b4d0e61a44"></a>EQUAL </td><td class="fielddoc"><p>nulls compare equal </p>
</td></tr>
<tr><td class="fieldname"><a id="gga08a672308cd0f61562410d106b377771ac0df9e531f39895029236b71d0d1c0ac"></a>UNEQUAL </td><td class="fielddoc"><p>nulls compare unequal </p>
</td></tr>
</table>
</div>
</div>
<a id="ga058e6d6e8a21583ce0e85ee73e5abb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058e6d6e8a21583ce0e85ee73e5abb31">◆ </a></span>null_order</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga058e6d6e8a21583ce0e85ee73e5abb31">cudf::null_order</a> : bool</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates how null values compare against all other values. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga058e6d6e8a21583ce0e85ee73e5abb31ac130fda0cb93540bf1574912e78964fb"></a>AFTER </td><td class="fielddoc"><p>NULL values ordered <em>after</em> all other values. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga058e6d6e8a21583ce0e85ee73e5abb31a3525317285c6126ce3b62a8df8c00b07"></a>BEFORE </td><td class="fielddoc"><p>NULL values ordered <em>before</em> all other values. </p>
</td></tr>
</table>
</div>
</div>
<a id="ga1b8cda4afb95a7c42c4679b4fae61009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b8cda4afb95a7c42c4679b4fae61009">◆ </a></span>null_policy</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga1b8cda4afb95a7c42c4679b4fae61009">cudf::null_policy</a> : bool</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Enum to specify whether to include nulls or exclude nulls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1b8cda4afb95a7c42c4679b4fae61009a4f34e973c167c2296f66c7986cb558f8"></a>EXCLUDE </td><td class="fielddoc"><p>exclude null elements </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1b8cda4afb95a7c42c4679b4fae61009a04ff6a9583ba9957ebe1128d0f988ad8"></a>INCLUDE </td><td class="fielddoc"><p>include null elements </p>
</td></tr>
</table>
</div>
</div>
<a id="ga750f02016b046079f7062d334890b4fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga750f02016b046079f7062d334890b4fc">◆ </a></span>order</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#ga750f02016b046079f7062d334890b4fc">cudf::order</a> : bool</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates the order in which elements should be sorted. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga750f02016b046079f7062d334890b4fca83ec681a20197326c163ea3b39ef7c32"></a>ASCENDING </td><td class="fielddoc"><p>Elements ordered from small to large. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga750f02016b046079f7062d334890b4fcacff818f0ae4cef845577e39283886a53"></a>DESCENDING </td><td class="fielddoc"><p>Elements ordered from large to small. </p>
</td></tr>
</table>
</div>
</div>
<a id="gacd4cd7157c4379954b5772936f89c59b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd4cd7157c4379954b5772936f89c59b">◆ </a></span>type_id</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="group__utility__types.html#gacd4cd7157c4379954b5772936f89c59b">cudf::type_id</a></td>
</tr>
</table>
</div><div class="memdoc">
<p>Identifies a column's logical element type. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59bab2c14e467fcbf9a215ccc679f35bb027"></a>EMPTY </td><td class="fielddoc"><p>Always null with no underlying data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba71f4b0467efae61c1e3ac5910178940f"></a>INT8 </td><td class="fielddoc"><p>1 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba7dafa1ea3755308998ff8c972342c099"></a>INT16 </td><td class="fielddoc"><p>2 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba723129325728a81a880ac3df63c567ae"></a>INT32 </td><td class="fielddoc"><p>4 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59bab9c234f82eec5cb83e3ea67aac9c1166"></a>INT64 </td><td class="fielddoc"><p>8 byte signed integer </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba37225001c5ad4b3d1aa808620debfe7a"></a>FLOAT32 </td><td class="fielddoc"><p>4 byte floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59baf24707a0d5537fd50bca87cd18a9a0e5"></a>FLOAT64 </td><td class="fielddoc"><p>8 byte floating point </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba9100ee556e5cf9b6dada6c7c506fa138"></a>BOOL8 </td><td class="fielddoc"><p>Boolean using one byte per value, 0 == false, else true. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba8a653791c2c90530cd2452ef46a01ab2"></a>TIMESTAMP_DAYS </td><td class="fielddoc"><p>days since Unix Epoch in int32 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba75e3c065f03583dc3b94ec069c4fe34d"></a>TIMESTAMP_SECONDS </td><td class="fielddoc"><p>duration of seconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba5cb4e0f1d7d608d8801707a376e43b64"></a>TIMESTAMP_MILLISECONDS </td><td class="fielddoc"><p>duration of milliseconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59bab892ce722f86206a6496700f2c4a3abf"></a>TIMESTAMP_MICROSECONDS </td><td class="fielddoc"><p>duration of microseconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba9864c6a53387a840e7c6ed2672fed2c9"></a>TIMESTAMP_NANOSECONDS </td><td class="fielddoc"><p>duration of nanoseconds since Unix Epoch in int64 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba6c8d7b96f965a120e818925f750fc499"></a>DICTIONARY32 </td><td class="fielddoc"><p>Dictionary type using int32 indices. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59bae008ab0db4e9b28f33e1e3c9c3daf444"></a>STRING </td><td class="fielddoc"><p>String elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59bae483076112011f632916ad85a059d6c3"></a>LIST </td><td class="fielddoc"><p>List elements. </p>
</td></tr>
<tr><td class="fieldname"><a id="ggacd4cd7157c4379954b5772936f89c59ba0f6b1e874ab643a0f237082cb35acad5"></a>NUM_TYPE_IDS </td><td class="fielddoc"><p>Total number of type ids. </p>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaa1b9dd3a6ee95fa52224a53869cd164e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa1b9dd3a6ee95fa52224a53869cd164e">◆ </a></span>is_boolean() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_boolean </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether <code>T</code> is a Boolean type. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is Boolean </dd>
<dd>
false <code>type</code> is not Boolean </dd></dl>
</div>
</div>
<a id="ga96675e30be80f4236360466adcf9a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96675e30be80f4236360466adcf9a70c">◆ </a></span>is_boolean() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_boolean </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether <code>type</code> is a Boolean <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a Boolean </dd>
<dd>
false <code>type</code> is not a Boolean </dd></dl>
</div>
</div>
<a id="ga14e1cea4200d1d92d7f38d596333d28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14e1cea4200d1d92d7f38d596333d28a">◆ </a></span>is_compound() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_compound </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the type <code>T</code> is a compound type. </p>
<p><code>column</code>s with "compound" elements are logically a single column of elements, but may be concretely implemented with two or more <code>column</code>s. For example, a <code>STRING</code> column could contain a <code>column</code> of offsets and a child <code>column</code> of characters.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The type to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a "compound" type </dd>
<dd>
false <code>T</code> corresponds to a "simple" type </dd></dl>
</div>
</div>
<a id="gad7f296c6fe2b6ae35ac59e41cbf1487d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad7f296c6fe2b6ae35ac59e41cbf1487d">◆ </a></span>is_compound() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_compound </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether elements of <code>type</code> are compound. </p>
<p><code>column</code>s with "compound" elements are logically a single column of elements, but may be concretely implemented with two or more <code>column</code>s. For example, a <code>STRING</code> column could contain a <code>column</code> of offsets and a child <code>column</code> of characters.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a compound type </dd>
<dd>
false <code>type</code> is a simple type </dd></dl>
</div>
</div>
<a id="ga82f7470f89e1e2b53077246712787120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82f7470f89e1e2b53077246712787120">◆ </a></span>is_equality_comparable()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_equality_comparable </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether objects of types <code>L</code> and <code>R</code> can be compared for equality. </p>
<p>Given two objects <code>L l</code>, and <code>R r</code>, returns true if <code>l == r</code> is a well-formed expression.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">L</td><td>Type of the first object </td></tr>
<tr><td class="paramname">R</td><td>Type of the second object </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Objects of types <code>L</code> and <code>R</code> can be compared for equality </dd>
<dd>
false Objects of types <code>L</code> and <code>R</code> cannot be compared </dd></dl>
</div>
</div>
<a id="gaaa937abead085ea9420b15c6473f08a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa937abead085ea9420b15c6473f08a7">◆ </a></span>is_fixed_width() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_fixed_width </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether elements of type <code>T</code> are fixed-width. </p>
<p>Elements of a fixed-width type all have the same size in bytes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The C++ type to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a fixed-width element type </dd>
<dd>
false <code>T</code> corresponds to a variable-width element type </dd></dl>
</div>
</div>
<a id="ga347d883100d3f7c725ad64c649f59c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga347d883100d3f7c725ad64c649f59c11">◆ </a></span>is_fixed_width() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_fixed_width </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether elements of <code>type</code> are fixed-width. </p>
<p>Elements of a fixed-width type all have the same size in bytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is fixed-width </dd>
<dd>
false <code>type</code> is variable-width </dd></dl>
</div>
</div>
<a id="gacaa242e2e068ab62bdaae071ed748357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacaa242e2e068ab62bdaae071ed748357">◆ </a></span>is_nested() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_nested </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether <code>T</code> is a nested type. </p>
<p>"Nested" types are distinct from compound types in that they can have an arbitrarily deep list of descendants of the same type. Strings are not a nested type, but lists are.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">T</td><td>The type to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true T is a nested type </dd>
<dd>
false T is not a nested type </dd></dl>
</div>
</div>
<a id="ga78ef9ab51afae8235ee8b18f82cc8107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78ef9ab51afae8235ee8b18f82cc8107">◆ </a></span>is_nested() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_nested </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether <code>type</code> is a nested type. </p>
<p>"Nested" types are distinct from compound types in that they can have an arbitrarily deep list of descendants of the same type. Strings are not a nested type, but lists are.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a nested type </dd>
<dd>
false <code>type</code> is not a nested type </dd></dl>
</div>
</div>
<a id="ga736c39af324b57534639bd3d8af357e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736c39af324b57534639bd3d8af357e4">◆ </a></span>is_numeric() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_numeric </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the type <code>T</code> is a numeric type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The type to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> is numeric </dd>
<dd>
false <code>T</code> is not numeric </dd></dl>
</div>
</div>
<a id="gac193df7b5be153a88978c2e6564bf4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac193df7b5be153a88978c2e6564bf4f2">◆ </a></span>is_numeric() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_numeric </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether <code>type</code> is a numeric <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<p>"Numeric" types are fundamental integral/floating point types such as <code>INT*</code> or <code>FLOAT*</code>. Types that wrap a numeric type are not considered numeric, e.g., <code>TIMESTAMP</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is numeric </dd>
<dd>
false <code>type</code> is not numeric </dd></dl>
</div>
</div>
<a id="gaef9b08b206b1340c5ac3893d17943309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef9b08b206b1340c5ac3893d17943309">◆ </a></span>is_relationally_comparable()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename L , typename R &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_relationally_comparable </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether objects of types <code>L</code> and <code>R</code> can be relationally compared. </p>
<p>Given two objects <code>L l</code>, and <code>R r</code>, returns true if <code>l &lt; r</code> and <code>l &gt; r</code> are well-formed expressions.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">L</td><td>Type of the first object </td></tr>
<tr><td class="paramname">R</td><td>Type of the second object </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true Objects of types <code>L</code> and <code>R</code> can be relationally be compared </dd>
<dd>
false Objects of types <code>L</code> and <code>R</code> cannot be compared </dd></dl>
</div>
</div>
<a id="gad15f075ce6421723e214c0d153fe695f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15f075ce6421723e214c0d153fe695f">◆ </a></span>is_simple() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_simple </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the type <code>T</code> is a simple type. </p>
<p>"Simple" element types are implemented with only a single column, i.e., <code>num_children() == 0</code> for columns of "simple" elements</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The type to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> corresponds to a simple type </dd>
<dd>
false <code>T</code> corresponds to a compound type </dd></dl>
</div>
</div>
<a id="gae6e62b8bc2981be767ae3f6843877956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6e62b8bc2981be767ae3f6843877956">◆ </a></span>is_simple() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_simple </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether elements of <code>type</code> are simple. </p>
<p>"Simple" element types are implemented with only a single column, i.e., <code>num_children() == 0</code> for columns of "simple" elements</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a simple type </dd>
<dd>
false <code>type</code> is a compound type </dd></dl>
</div>
</div>
<a id="ga90ebb90931abfed637396889b7829173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90ebb90931abfed637396889b7829173">◆ </a></span>is_timestamp() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_timestamp </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the type <code>T</code> is a timestamp type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The type to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>T</code> is a timestamp </dd>
<dd>
false <code>T</code> is not a timestamp </dd></dl>
</div>
</div>
<a id="ga96f7b448c30ecbce54e8c1243ccc8c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96f7b448c30ecbce54e8c1243ccc8c4d">◆ </a></span>is_timestamp() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">constexpr bool cudf::is_timestamp </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>type</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Indicates whether <code>type</code> is a timestamp <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>. </p>
<p>"Timestamp" types are int32_t or int64_t durations since the unix epoch.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">type</td><td>The <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to verify </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>type</code> is a timestamp </dd>
<dd>
false <code>type</code> is not a timestamp </dd></dl>
</div>
</div>
<a id="gaa5bd500e54a0760773f941986e8e056b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5bd500e54a0760773f941986e8e056b">◆ </a></span>operator==()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool cudf::operator== </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp; </td>
<td class="paramname"><em>lhs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> const &amp; </td>
<td class="paramname"><em>rhs</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Compares two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> objects for equality. </p>
<p>// TODO Define exactly what it means for two <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code>s to be equal. e.g., are two timestamps with different resolutions equal? How about decimals with different scale/precision?</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">lhs</td><td>The first <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to compare </td></tr>
<tr><td class="paramname">rhs</td><td>The second <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> to compare </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true <code>lhs</code> is equal to <code>rhs</code> </dd>
<dd>
false <code>lhs</code> is not equal to <code>rhs</code> </dd></dl>
</div>
</div>
<a id="ga51b0daf2c01663d51cb3b87ad8ce93c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51b0daf2c01663d51cb3b87ad8ce93c0">◆ </a></span>size_of()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">std::size_t cudf::size_of </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcudf_1_1data__type.html">data_type</a> </td>
<td class="paramname"><em>t</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the size in bytes of elements of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> </p>
<dl class="section note"><dt>Note</dt><dd>Only fixed-width types are supported</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcudf_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cudf::logic_error</a></td><td>if <code>is_fixed_width(element_type) == false</code></td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size in bytes of an element of the specified <code><a class="el" href="classcudf_1_1data__type.html" title="Indicator for the logical data type of an element in a column.">data_type</a></code> </dd></dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.18
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
