<!DOCTYPE html>
<html class="writer-html5" lang="en"><head>
<meta charset="utf-8">
<meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator">
<meta content="width=device-width, initial-scale=1.0" name="viewport">
<title>GeoPandas Compatibility &mdash; cuspatial 21.08.00 documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css">
<link href="_static/pygments.css" rel="stylesheet" type="text/css">
<link href="_static/pygments.css" rel="stylesheet" type="text/css">
<link href="_static/css/theme.css" rel="stylesheet" type="text/css">
<link href="_static/params.css" rel="stylesheet" type="text/css">
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index">
<link href="search.html" rel="search" title="Search">
<link href="index.html" rel="prev" title="Welcome to cuSpatial&rsquo;s documentation!">
<link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search"><div id="rapids-jtd-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cuspatial</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (21.08)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cuspatial/nightly/api.html">nightly (21.08)</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">stable (21.06)</a><a class="rapids-selector__menu-item" href="/api/cuspatial/legacy/api.html">legacy (0.19)</a></div></div></div>


<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text">
<input name="check_keywords" type="hidden" value="yes">
<input name="area" type="hidden" value="default">
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">GeoPandas Compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="#spatial-indexing">Spatial Indexing</a></li>
<li class="toctree-l1"><a class="reference internal" href="#gis">GIS</a></li>
<li class="toctree-l1"><a class="reference internal" href="#trajectory">Trajectory</a></li>
<li class="toctree-l1"><a class="reference internal" href="#io">IO</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">cuspatial</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> &raquo;</li>
<li>GeoPandas Compatibility</li>
<li class="wy-breadcrumbs-aside">
<a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
</li>
</ul>
<hr>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="geopandas-compatibility">
<h1>GeoPandas Compatibility<a class="headerlink" href="#geopandas-compatibility" title="Permalink to this headline">&para;</a></h1>
<p>We support any geometry format supported by <cite>GeoPandas</cite>. Load geometry information from a <cite>GeoPandas.GeoSeries</cite> or <cite>GeoPandas.GeoDataFrame</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gpdf</span> <span class="o">=</span> <span class="n">geopandas</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="s1">'arbitrary.txt'</span><span class="p">)</span>
<span class="go">    cugpdf = cuspatial.from_geopandas(gpdf)</span>
</pre></div>
</div>
<p>or</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cugpdf</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">gpdf</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="cuspatial.GeoDataFrame">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">GeoDataFrame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">geopandas.geodataframe.GeoDataFrame</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoDataFrame" title="Permalink to this definition">&para;</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">cudf.core.dataframe.DataFrame</span></code></p>
<p>A GPU GeoDataFrame object.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cuspatial.GeoDataFrame.to_geopandas" title="cuspatial.GeoDataFrame.to_geopandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_geopandas</span></code></a>([nullable])</p></td>
<td><p>Returns a new GeoPandas GeoDataFrame object from the coordinates in the cuspatial GeoDataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cuspatial.GeoDataFrame.to_pandas" title="cuspatial.GeoDataFrame.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>([nullable])</p></td>
<td><p>Calls <cite>self.to_geopandas</cite>, converting GeoSeries columns into GeoPandas columns and cudf.Series columns into pandas.Series columns, and returning a pandas.DataFrame.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 52%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>groupby</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.GeoDataFrame.to_geopandas">
<span class="sig-name descname"><span class="pre">to_geopandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nullable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoDataFrame.to_geopandas" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns a new GeoPandas GeoDataFrame object from the coordinates in
the cuspatial GeoDataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nullable: matches the cudf `to_pandas` signature, not yet supported.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.GeoDataFrame.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nullable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoDataFrame.to_pandas" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calls <cite>self.to_geopandas</cite>, converting GeoSeries columns into GeoPandas
columns and cudf.Series columns into pandas.Series columns, and
returning a pandas.DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>nullable: matches the cudf `to_pandas` signature, not yet supported.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="cuspatial.GeoSeries">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">GeoSeries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">geopandas.geoseries.GeoSeries</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">cudf.core.index.Index</span><span class="p"><span class="pre">,</span> </span><span class="pre">pandas.core.indexes.base.Index</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nan_as_null</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoSeries" title="Permalink to this definition">&para;</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">cudf.core.series.Series</span></code></p>
<p>cuspatial.GeoSeries enables GPU-backed storage and computation of
shapely-like objects. Our goal is to give feature parity with GeoPandas.
At this time, only from_geopandas and to_geopandas are directly supported.
cuspatial GIS, indexing, and trajectory functions depend on the arrays
stored in the <cite>GeoArrowBuffers</cite> object, accessible with the <cite>points</cite>,
<cite>multipoints</cite>, <cite>lines</cite>, and <cite>polygons</cite> accessors.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cuseries</span><span class="o">.</span><span class="n">points</span>
<span class="go">    xy:</span>
<span class="go">    0   -1.0</span>
<span class="go">    1    0.0</span>
<span class="go">    dtype: float64</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cuspatial.GeoSeries.lines" title="cuspatial.GeoSeries.lines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lines</span></code></a></dt><dd><p>Access the <cite>LineArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd>
<dt><a class="reference internal" href="#cuspatial.GeoSeries.multipoints" title="cuspatial.GeoSeries.multipoints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multipoints</span></code></a></dt><dd><p>Access the <cite>MultiPointArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd>
<dt><a class="reference internal" href="#cuspatial.GeoSeries.points" title="cuspatial.GeoSeries.points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></a></dt><dd><p>Access the <cite>PointsArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd>
<dt><a class="reference internal" href="#cuspatial.GeoSeries.polygons" title="cuspatial.GeoSeries.polygons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polygons</span></code></a></dt><dd><p>Access the <cite>PolygonArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cuspatial.GeoSeries.to_geopandas" title="cuspatial.GeoSeries.to_geopandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_geopandas</span></code></a>([nullable])</p></td>
<td><p>Returns a new GeoPandas GeoSeries object from the coordinates in the cuspatial GeoSeries.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cuspatial.GeoSeries.to_pandas" title="cuspatial.GeoSeries.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>()</p></td>
<td><p>Treats to_pandas and to_geopandas as the same call, which improves compatibility with pandas.</p></td>
</tr>
</tbody>
</table>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoSeries.lines">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">lines</span></span><a class="headerlink" href="#cuspatial.GeoSeries.lines" title="Permalink to this definition">&para;</a></dt>
<dd><p>Access the <cite>LineArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoSeries.multipoints">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">multipoints</span></span><a class="headerlink" href="#cuspatial.GeoSeries.multipoints" title="Permalink to this definition">&para;</a></dt>
<dd><p>Access the <cite>MultiPointArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoSeries.points">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#cuspatial.GeoSeries.points" title="Permalink to this definition">&para;</a></dt>
<dd><p>Access the <cite>PointsArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoSeries.polygons">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">polygons</span></span><a class="headerlink" href="#cuspatial.GeoSeries.polygons" title="Permalink to this definition">&para;</a></dt>
<dd><p>Access the <cite>PolygonArray</cite> of the underlying <cite>GeoArrowBuffers</cite>.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.GeoSeries.to_geopandas">
<span class="sig-name descname"><span class="pre">to_geopandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nullable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoSeries.to_geopandas" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns a new GeoPandas GeoSeries object from the coordinates in
the cuspatial GeoSeries.</p>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.GeoSeries.to_pandas">
<span class="sig-name descname"><span class="pre">to_pandas</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoSeries.to_pandas" title="Permalink to this definition">&para;</a></dt>
<dd><p>Treats to_pandas and to_geopandas as the same call, which improves
compatibility with pandas.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="cuspatial.geometry.geocolumn.GeoColumn">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cuspatial.geometry.geocolumn.</span></span><span class="sig-name descname"><span class="pre">GeoColumn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><a class="reference internal" href="#cuspatial.GeoArrowBuffers" title="cuspatial.geometry.geoarrowbuffers.GeoArrowBuffers"><span class="pre">cuspatial.geometry.geoarrowbuffers.GeoArrowBuffers</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">meta</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">cuspatial.geometry.geocolumn.GeoMeta</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shuffle_order</span></span><span class="p"><span class="pre">:</span></span> <span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">cudf.core.index.Index</span><span class="p"><span class="pre">]</span></span></span> <span class="o"><span class="pre">=</span></span> <span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.geometry.geocolumn.GeoColumn" title="Permalink to this definition">&para;</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">cudf.core.column.numerical.NumericalColumn</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">A GeoArrowBuffers object</span></dt><dd></dd>
<dt><strong>meta</strong><span class="classifier">A GeoMeta object (optional)</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The GeoColumn class subclasses <cite>NumericalColumn</cite>. Combined with
<cite>_copy_type_metadata</cite>, this assures support for existing cudf algorithms.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cuspatial.geometry.geocolumn.GeoColumn.iloc" title="cuspatial.geometry.geocolumn.GeoColumn.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>Return the i-th row of the GeoSeries.</p>
</dd>
<dt><strong>lines</strong></dt><dd></dd>
<dt><a class="reference internal" href="#cuspatial.geometry.geocolumn.GeoColumn.loc" title="cuspatial.geometry.geocolumn.GeoColumn.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt><dd><p>Not currently supported.</p>
</dd>
<dt><strong>multipoints</strong></dt><dd></dd>
<dt><strong>points</strong></dt><dd></dd>
<dt><strong>polygons</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cuspatial.geometry.geocolumn.GeoColumn.copy" title="cuspatial.geometry.geocolumn.GeoColumn.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([deep])</p></td>
<td><p>Create a copy of all of the GPU-backed data structures in this GeoColumn.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 52%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>to_host</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.geometry.geocolumn.GeoColumn.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.geometry.geocolumn.GeoColumn.copy" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create a copy of all of the GPU-backed data structures in this
GeoColumn.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.geometry.geocolumn.GeoColumn.iloc">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">iloc</span></span><a class="headerlink" href="#cuspatial.geometry.geocolumn.GeoColumn.iloc" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return the i-th row of the GeoSeries.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.geometry.geocolumn.GeoColumn.loc">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">loc</span></span><a class="headerlink" href="#cuspatial.geometry.geocolumn.GeoColumn.loc" title="Permalink to this definition">&para;</a></dt>
<dd><p>Not currently supported.</p>
</dd></dl>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="cuspatial.GeoArrowBuffers">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">GeoArrowBuffers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">data:</span> <span class="pre">Union[dict,</span> <span class="pre">cuspatial.geometry.geoarrowbuffers.T],</span> <span class="pre">data_locale:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;module</span> <span class="pre">'cudf'</span> <span class="pre">from</span> <span class="pre">'/opt/conda/envs/rapids/lib/python3.7/site-packages/cudf/__init__.py'&gt;</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoArrowBuffers" title="Permalink to this definition">&para;</a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.9)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>A GPU GeoArrowBuffers object.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">A dict or a GeoArrowBuffers object.</span></dt><dd></dd>
<dt><strong>The GeoArrow format specifies a tabular data format for geometry</strong></dt><dd></dd>
<dt><strong>information. Supported types include `Point`, `MultiPoint`, `LineString`,</strong></dt><dd></dd>
<dt><strong>`MultiLineString`, `Polygon`, and `MultiPolygon`.  In order to store</strong></dt><dd></dd>
<dt><strong>these coordinate types in a strictly tabular fashion, columns are</strong></dt><dd></dd>
<dt><strong>created for Points, MultiPoints, LineStrings, and Polygons.</strong></dt><dd></dd>
<dt><strong>MultiLines and MultiPolygons are stored in the same data structure</strong></dt><dd></dd>
<dt><strong>as LineStrings and Polygons. GeoArrowBuffers are constructed from a dict</strong></dt><dd></dd>
<dt><strong>of host buffers with accepted keys:</strong></dt><dd></dd>
<dt><strong>* points_xy</strong></dt><dd></dd>
<dt><strong>* points_z</strong></dt><dd></dd>
<dt><strong>* multipoints_xy</strong></dt><dd></dd>
<dt><strong>* multipoints_z</strong></dt><dd></dd>
<dt><strong>* multipoints_offsets</strong></dt><dd></dd>
<dt><strong>* lines_xy</strong></dt><dd></dd>
<dt><strong>* lines_z</strong></dt><dd></dd>
<dt><strong>* lines_offsets</strong></dt><dd></dd>
<dt><strong>* mlines</strong></dt><dd></dd>
<dt><strong>* polygons_xy</strong></dt><dd></dd>
<dt><strong>* polygons_z</strong></dt><dd></dd>
<dt><strong>* polygons_polygons</strong></dt><dd></dd>
<dt><strong>* polygons_rings</strong></dt><dd></dd>
<dt><strong>* mpolygons</strong></dt><dd></dd>
<dt><strong>There are no correlations in length between any of the above columns.</strong></dt><dd></dd>
<dt><strong>Accepted host buffer object types include python list and any type that</strong></dt><dd></dd>
<dt><strong>implements numpy&rsquo;s `__array__interface__` protocol.</strong></dt><dd></dd>
<dt><strong>GeoArrow Format</strong></dt><dd></dd>
<dt><strong>GeoArrow format packs complex geometry types into 14 single-column Arrow</strong></dt><dd></dd>
<dt><strong>tables. This description is included for better understanding GeoArrow</strong></dt><dd></dd>
<dt><strong>format. Interacting with the GeoArrowBuffers is only required if you want</strong></dt><dd></dd>
<dt><strong>to convert cudf data to GeoPandas objects without starting from GeoPandas.</strong></dt><dd></dd>
<dt><strong>The points geometry is the simplest: N points are stored in a length 2*N</strong></dt><dd></dd>
<dt><strong>buffer with interleaved x,y coordinates. An optional z buffer of length N</strong></dt><dd></dd>
<dt><strong>can be used.</strong></dt><dd></dd>
<dt><strong>The multipoints geometry is the second simplest - identical to points,</strong></dt><dd></dd>
<dt><strong>with the addition of a multipoints_offsets buffer. The offsets buffer</strong></dt><dd></dd>
<dt><strong>stores N+1 indexes. The first multipoint is specified by 0, which is always</strong></dt><dd></dd>
<dt><strong>stored in offsets[0], and offsets[1], which is the length in points of</strong></dt><dd></dd>
<dt><strong>the first multipoint geometry. Subsequent multipoints are the prefix-sum of</strong></dt><dd></dd>
<dt><strong>the lengths of previous multipoints.</strong></dt><dd></dd>
<dt><strong>Consider::</strong></dt><dd><dl class="simple">
<dt>buffers = GeoArrowBuffers({</dt><dd><dl class="simple">
<dt>&ldquo;multipoints_xy&rdquo;:</dt><dd><p>[0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2, 2, 0, 2, 1, 2, 2],</p>
</dd>
<dt>&ldquo;multipoints_offsets&rdquo;:</dt><dd><p>[0, 6, 12, 18]</p>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</dd>
<dt><strong>which encodes the following GeoPandas Series::</strong></dt><dd><dl class="simple">
<dt>series = geopandas.Series([</dt><dd><p>MultiPoint((0, 0), (0, 1), (0, 2)),
MultiPoint((1, 0), (1, 1), (1, 2)),
MultiPoint((2, 0), (2, 1), (2, 2)),</p>
</dd>
</dl>
<p>])</p>
</dd>
<dt><strong>LineString geometry is more complicated than multipoints because the</strong></dt><dd></dd>
<dt><strong>format allows for the use of LineStrings and MultiLineStrings in the same</strong></dt><dd></dd>
<dt><strong>buffer, via the mlines key::</strong></dt><dd><dl class="simple">
<dt>buffers = GeoArrowBuffers({</dt><dd><dl class="simple">
<dt>&ldquo;lines_xy&rdquo;:</dt><dd><dl class="simple">
<dt>[0, 0, 0, 1, 0, 2, 1, 0, 1, 1, 1, 2, 2, 0, 2, 1, 2, 2, 3, 0,</dt><dd><p>3, 1, 3, 2, 4, 0, 4, 1, 4, 2],</p>
</dd>
</dl>
</dd>
<dt>&ldquo;lines_offsets&rdquo;:</dt><dd><p>[0, 6, 12, 18, 24, 30],</p>
</dd>
<dt>&ldquo;mlines&rdquo;:</dt><dd><p>[1, 3]</p>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</dd>
<dt><strong>Which encodes a GeoPandas Series::</strong></dt><dd><dl>
<dt>series = geopandas.Series([</dt><dd><p>LineString((0, 0), (0, 1), (0, 2)),
MultiLineString([(1, 0), (1, 1), (1, 2)],</p>
<blockquote>
<div><p>[(2, 0), (2, 1), (2, 2)],</p>
</div></blockquote>
<p>)
LineString((3, 0), (3, 1), (3, 2)),
LineString((4, 0), (4, 1), (4, 2)),</p>
</dd>
</dl>
<p>])</p>
</dd>
<dt><strong>Polygon geometry includes `mpolygons` for MultiPolygons similar to the</strong></dt><dd></dd>
<dt><strong>LineString geometry. Polygons are encoded using the same format as</strong></dt><dd></dd>
<dt><strong>Shapefiles, with left-wound external rings and right-wound internal rings.</strong></dt><dd></dd>
<dt><strong>An exact example of `GeoArrowBuffers` to `geopandas.Series` is left to the</strong></dt><dd></dd>
<dt><strong>reader as an exercise. Convert any GeoPandas `Series` or `DataFrame` with</strong></dt><dd></dd>
<dt><strong>`cuspatial.from_geopandas(geopandas_object)`.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Legacy cuspatial algorithms depend on separated x and y columns. Access
them with the <cite>.x</cite> and <cite>.y</cite> properties.</p>
<p class="rubric">Examples</p>
<p>GeoArrowBuffers accept a dict as argument. Valid keys are in the bullet
list above. Valid values are any datatype that implements numpy&rsquo;s
<cite>__array_interface__</cite>. Any or all of the four basic geometry types is
supported as argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">buffers</span> <span class="o">=</span> <span class="n">GeoArrowBuffers</span><span class="p">({</span>
    <span class="s2">"points_xy"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">"multipoints_xy"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">"multipoints_offsets"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">]</span>
    <span class="s2">"lines_xy"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
         <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">"lines_offsets"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">30</span><span class="p">],</span>
    <span class="s2">"mlines"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="s2">"polygons_xy"</span><span class="p">:</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
         <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">"polygons_polygons"</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">"polygons_rings"</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
    <span class="s2">"mpolygons"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="p">})</span>
</pre></div>
</div>
<p>or another GeoArrowBuffers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">buffers2</span> <span class="o">=</span> <span class="n">GeoArrowBuffers</span><span class="p">(</span><span class="n">buffers</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cuspatial.GeoArrowBuffers.lines" title="cuspatial.GeoArrowBuffers.lines"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lines</span></code></a></dt><dd><p>Contains the coordinates column, an offsets column, and a mlines column.</p>
</dd>
<dt><a class="reference internal" href="#cuspatial.GeoArrowBuffers.multipoints" title="cuspatial.GeoArrowBuffers.multipoints"><code class="xref py py-obj docutils literal notranslate"><span class="pre">multipoints</span></code></a></dt><dd><p>Similar to the Points column with the addition of an offsets column.</p>
</dd>
<dt><a class="reference internal" href="#cuspatial.GeoArrowBuffers.points" title="cuspatial.GeoArrowBuffers.points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">points</span></code></a></dt><dd><p>A simple numeric column.</p>
</dd>
<dt><a class="reference internal" href="#cuspatial.GeoArrowBuffers.polygons" title="cuspatial.GeoArrowBuffers.polygons"><code class="xref py py-obj docutils literal notranslate"><span class="pre">polygons</span></code></a></dt><dd><p>Contains the coordinates column, a rings column specifying the beginning and end of every polygon, a polygons column specifying the beginning, or exterior, ring of each polygon and the end ring.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cuspatial.GeoArrowBuffers.copy" title="cuspatial.GeoArrowBuffers.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([deep])</p></td>
<td><p>Create a copy of all of the GPU-backed data structures in this GeoArrowBuffers.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 52%">
<col style="width: 48%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>to_host</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.GeoArrowBuffers.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">deep</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.GeoArrowBuffers.copy" title="Permalink to this definition">&para;</a></dt>
<dd><p>Create a copy of all of the GPU-backed data structures in this
GeoArrowBuffers.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoArrowBuffers.lines">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">lines</span></span><a class="headerlink" href="#cuspatial.GeoArrowBuffers.lines" title="Permalink to this definition">&para;</a></dt>
<dd><p>Contains the coordinates column, an offsets column, and a
mlines column. The mlines column  is optional. The mlines column stores
the indices of the offsets that indicate the beginning and end of each
MultiLineString segment. The absence of an <cite>mlines</cite> column indicates
there are no <cite>MultiLineStrings</cite> in the data source, only <a href="#id1"><span class="problematic" id="id2">`</span></a>LineString`s.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoArrowBuffers.multipoints">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">multipoints</span></span><a class="headerlink" href="#cuspatial.GeoArrowBuffers.multipoints" title="Permalink to this definition">&para;</a></dt>
<dd><p>Similar to the Points column with the addition of an offsets column.
The offsets column stores the comparable sizes and coordinates of each
MultiPoint in the GeoArrowBuffers.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoArrowBuffers.points">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">points</span></span><a class="headerlink" href="#cuspatial.GeoArrowBuffers.points" title="Permalink to this definition">&para;</a></dt>
<dd><p>A simple numeric column. x and y coordinates are interleaved such that
even coordinates are x axis and odd coordinates are y axis.</p>
</dd></dl>
<dl class="py property">
<dt class="sig sig-object py" id="cuspatial.GeoArrowBuffers.polygons">
<em class="property"><span class="pre">property</span> </em><span class="sig-name descname"><span class="pre">polygons</span></span><a class="headerlink" href="#cuspatial.GeoArrowBuffers.polygons" title="Permalink to this definition">&para;</a></dt>
<dd><p>Contains the coordinates column, a rings column specifying
the beginning and end of every polygon, a polygons column specifying
the beginning, or exterior, ring of each polygon and the end ring.
All rings after the first ring are interior rings.  Finally a
mpolygons column stores the offsets of the polygons that should be
grouped into MultiPolygons.</p>
</dd></dl>
</dd></dl>
</section>
<section id="spatial-indexing">
<h1>Spatial Indexing<a class="headerlink" href="#spatial-indexing" title="Permalink to this headline">&para;</a></h1>
<p>Spatial indexing functions provide blisteringly-fast on-GPU point-in-polygon
operations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.quadtree_point_in_polygon">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">quadtree_point_in_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_quad_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadtree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.quadtree_point_in_polygon" title="Permalink to this definition">&para;</a></dt>
<dd><p>Test whether the specified points are inside any of the specified
polygons.</p>
<p>Uses the table of (polygon, quadrant) pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code> to ensure only the points
in the same quadrant as each polygon are tested for intersection.</p>
<p>This pre-filtering can dramatically reduce number of points tested per
polygon, enabling faster intersection-testing at the expense of extra
memory allocated to store the quadtree and sorted point_indices.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_quad_pairs: cudf.DataFrame</strong></dt><dd><p>Table of (polygon, quadrant) index pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code>.</p>
</dd>
<dt><strong>quadtree</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for a given area-of-interest bounding box.</p>
</dd>
<dt><strong>point_indices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Sorted point indices returned by <code class="docutils literal notranslate"><span class="pre">cuspatial.quadtree_on_points</span></code></p>
</dd>
<dt><strong>points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>x-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>y-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>poly_offsets</strong><span class="classifier">cudf.Series</span></dt><dd><p>Begin index of the first ring in each polygon.</p>
</dd>
<dt><strong>ring_offsets</strong><span class="classifier">cudf.Series</span></dt><dd><p>Begin index of the first point in each ring.</p>
</dd>
<dt><strong>poly_points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polygon point x-coodinates.</p>
</dd>
<dt><strong>poly_points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polygon point y-coodinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Indices for each intersecting point and polygon pair.</p>
<dl class="simple">
<dt>polygon_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each polygon with which a point intersected.</p>
</dd>
<dt>point_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each point that intersects with a polygon.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.quadtree_point_to_nearest_polyline">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">quadtree_point_to_nearest_polyline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_quad_pairs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadtree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point_indices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">points_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.quadtree_point_to_nearest_polyline" title="Permalink to this definition">&para;</a></dt>
<dd><p>Finds the nearest polyline to each point in a quadrant, and computes
the distances between each point and polyline.</p>
<p>Uses the table of (polyline, quadrant) pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code> to ensure distances are
computed only for the points in the same quadrant as each polyline.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_quad_pairs: cudf.DataFrame</strong></dt><dd><p>Table of (polyline, quadrant) index pairs returned by
<code class="docutils literal notranslate"><span class="pre">cuspatial.join_quadtree_and_bounding_boxes</span></code>.</p>
</dd>
<dt><strong>quadtree</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for a given area-of-interest bounding box.</p>
</dd>
<dt><strong>point_indices</strong><span class="classifier">cudf.Series</span></dt><dd><p>Sorted point indices returned by <code class="docutils literal notranslate"><span class="pre">cuspatial.quadtree_on_points</span></code></p>
</dd>
<dt><strong>points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>x-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>y-coordinates of points used to construct the quadtree.</p>
</dd>
<dt><strong>poly_offsets</strong><span class="classifier">cudf.Series</span></dt><dd><p>Begin index of the first point in each polyline.</p>
</dd>
<dt><strong>poly_points_x</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polyline point x-coodinates.</p>
</dd>
<dt><strong>poly_points_y</strong><span class="classifier">cudf.Series</span></dt><dd><p>Polyline point y-coodinates.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Indices for each point and its nearest polyline, and the distance
between the two.</p>
<dl class="simple">
<dt>point_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each point that intersects with a polyline.</p>
</dd>
<dt>polyline_index<span class="classifier">cudf.Series</span></dt><dd><p>Indices of each polyline with which a point intersected.</p>
</dd>
<dt>distance<span class="classifier">cudf.Series</span></dt><dd><p>Distances between each point and its nearest polyline.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.point_in_polygon">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">point_in_polygon</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">test_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_points_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_ring_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_points_y</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.point_in_polygon" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute from a set of points and a set of polygons which points fall
within which polygons. Note that <cite>polygons_(x,y)</cite> must be specified as
closed polygons: the first and last coordinate of each polygon must be
the same.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>test_points_x</strong></dt><dd><p>x-coordinate of test points</p>
</dd>
<dt><strong>test_points_y</strong></dt><dd><p>y-coordinate of test points</p>
</dd>
<dt><strong>poly_offsets</strong></dt><dd><p>beginning index of the first ring in each polygon</p>
</dd>
<dt><strong>poly_ring_offsets</strong></dt><dd><p>beginning index of the first point in each ring</p>
</dd>
<dt><strong>poly_points_x</strong></dt><dd><p>x closed-coordinate of polygon points</p>
</dd>
<dt><strong>poly_points_y</strong></dt><dd><p>y closed-coordinate of polygon points</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A DataFrame of boolean values indicating whether each point falls
within each polygon.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Test whether 3 points fall within either of two polygons</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">point_in_polygon</span><span class="p">(</span>
<span class="go">    [0, -8, 6.0],                             # test_points_x</span>
<span class="go">    [0, -8, 6.0],                             # test_points_y</span>
<span class="go">    cudf.Series([0, 1], index=['nyc', 'hudson river']), # poly_offsets</span>
<span class="go">    [0, 3],                                   # ring_offsets</span>
<span class="go">    [-10, 5, 5, -10, 0, 10, 10, 0],           # poly_points_x</span>
<span class="go">    [-10, -10, 5, 5, 0, 0, 10, 10],           # poly_points_y</span>
<span class="go">)</span>
<span class="go"># The result of point_in_polygon is a DataFrame of Boolean</span>
<span class="go"># values indicating whether each point (rows) falls within</span>
<span class="go"># each polygon (columns).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">            nyc            hudson river</span>
<span class="go">0          True          True</span>
<span class="go">1          True         False</span>
<span class="go">2         False          True</span>
<span class="go"># Point 0: (0, 0) falls in both polygons</span>
<span class="go"># Point 1: (-8, -8) falls in the first polygon</span>
<span class="go"># Point 2: (6.0, 6.0) falls in the second polygon</span>
</pre></div>
</div>
<p>note
input Series x and y will not be index aligned, but computed as
sequential arrays.</p>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.polygon_bounding_boxes">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">polygon_bounding_boxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ring_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.polygon_bounding_boxes" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the minimum bounding-boxes for a set of polygons.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_offsets</strong></dt><dd><p>Begin indices of the first ring in each polygon (i.e. prefix-sum)</p>
</dd>
<dt><strong>ring_offsets</strong></dt><dd><p>Begin indices of the first point in each ring (i.e. prefix-sum)</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>Polygon point x-coordinates</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>Polygon point y-coordinates</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>minimum bounding boxes for each polygon</p>
<dl class="simple">
<dt>x_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum x-coordinate of each bounding box</p>
</dd>
<dt>y_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum y-coordinate of each bounding box</p>
</dd>
<dt>x_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum x-coordinate of each bounding box</p>
</dd>
<dt>y_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum y-coordinate of each bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.polyline_bounding_boxes">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">polyline_bounding_boxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">poly_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expansion_radius</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.polyline_bounding_boxes" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the minimum bounding-boxes for a set of polylines.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>poly_offsets</strong></dt><dd><p>Begin indices of the first ring in each polyline (i.e. prefix-sum)</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>Polyline point x-coordinates</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>Polyline point y-coordinates</p>
</dd>
<dt><strong>expansion_radius</strong></dt><dd><p>radius of each polyline point</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>minimum bounding boxes for each polyline</p>
<dl class="simple">
<dt>x_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum x-coordinate of each bounding box</p>
</dd>
<dt>y_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum y-coordinate of each bounding box</p>
</dd>
<dt>x_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum x-coordinate of each bounding box</p>
</dd>
<dt>y_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum y-coordinate of each bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.quadtree_on_points">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">quadtree_on_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.quadtree_on_points" title="Permalink to this definition">&para;</a></dt>
<dd><dl class="simple">
<dt>Construct a quadtree from a set of points for a given area-of-interest</dt><dd><p>bounding box.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xs</strong></dt><dd><p>Column of x-coordinates for each point</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>Column of y-coordinates for each point</p>
</dd>
<dt><strong>x_min</strong></dt><dd><p>The lower-left x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>x_max</strong></dt><dd><p>The upper-right x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>y_min</strong></dt><dd><p>The lower-left y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>y_max</strong></dt><dd><p>The upper-right y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>scale</strong></dt><dd><p>Scale to apply to each point&rsquo;s distance from <code class="docutils literal notranslate"><span class="pre">(x_min,</span> <span class="pre">y_min)</span></code></p>
</dd>
<dt><strong>max_depth</strong></dt><dd><p>Maximum quadtree depth</p>
</dd>
<dt><strong>min_size</strong></dt><dd><p>Minimum number of points for a non-leaf quadtree node</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">tuple (cudf.Series, cudf.DataFrame)</span></dt><dd><dl>
<dt>keys_to_points<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>A column of sorted keys to original point indices</p>
</dd>
<dt>quadtree<span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for the set of input points</p>
<dl>
<dt>key<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>An int32 column of quadrant keys</p>
</dd>
<dt>level<span class="classifier">cudf.Series(dtype=np.int8)</span></dt><dd><p>An int8 column of quadtree levels</p>
</dd>
<dt>is_quad<span class="classifier">cudf.Series(dtype=np.bool_)</span></dt><dd><p>A boolean column indicating whether the node is a quad or leaf</p>
</dd>
<dt>length<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>If this is a non-leaf quadrant (i.e. <code class="docutils literal notranslate"><span class="pre">is_quad</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>),
this column&rsquo;s value is the number of children in the non-leaf
quadrant.</p>
<p>Otherwise this column&rsquo;s value is the number of points
contained in the leaf quadrant.</p>
</dd>
<dt>offset<span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>If this is a non-leaf quadrant (i.e. <code class="docutils literal notranslate"><span class="pre">is_quad</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>),
this column&rsquo;s value is the position of the non-leaf quadrant&rsquo;s
first child.</p>
<p>Otherwise this column&rsquo;s value is the position of the leaf
quadrant&rsquo;s first point.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_x</span></code> and <code class="docutils literal notranslate"><span class="pre">max_x</span></code> if <code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&gt;</span> <span class="pre">max_x</span></code></p></li>
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_y</span></code> and <code class="docutils literal notranslate"><span class="pre">max_y</span></code> if <code class="docutils literal notranslate"><span class="pre">min_y</span> <span class="pre">&gt;</span> <span class="pre">max_y</span></code></p></li>
</ul>
<p class="rubric">Examples</p>
<p>An example of selecting the <code class="docutils literal notranslate"><span class="pre">min_size</span></code> and <code class="docutils literal notranslate"><span class="pre">scale</span></code> based on input:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
<span class="go">        "x": cudf.Series(np.random.normal(size=120)) * 500,</span>
<span class="go">        "y": cudf.Series(np.random.normal(size=120)) * 500,</span>
<span class="go">    })</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">max_depth</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_size</span> <span class="o">=</span> <span class="mi">50</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="s2">"x"</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
<span class="go">                                  points["y"].min(),</span>
<span class="go">                                  points["x"].max(),</span>
<span class="go">                                  points["y"].max())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_x</span> <span class="o">-</span> <span class="n">min_x</span><span class="p">,</span> <span class="n">max_y</span> <span class="o">-</span> <span class="n">min_y</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">max_depth</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span>
<span class="go">        "min_size:   " + str(min_size) + "\n"</span>
<span class="go">        "num_points: " + str(len(points)) + "\n"</span>
<span class="go">        "min_x:      " + str(min_x) + "\n"</span>
<span class="go">        "max_x:      " + str(max_x) + "\n"</span>
<span class="go">        "min_y:      " + str(min_y) + "\n"</span>
<span class="go">        "max_y:      " + str(max_y) + "\n"</span>
<span class="go">        "scale:      " + str(scale) + "\n"</span>
<span class="go">    )</span>
<span class="go">min_size:   50</span>
<span class="go">num_points: 120</span>
<span class="go">min_x:      -1577.4949079170394</span>
<span class="go">max_x:      1435.877311993804</span>
<span class="go">min_y:      -1412.7015761122134</span>
<span class="go">max_y:      1492.572387431971</span>
<span class="go">scale:      301.0</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">key_to_point</span><span class="p">,</span> <span class="n">quadtree</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">quadtree_on_points</span><span class="p">(</span>
<span class="go">        points["x"],</span>
<span class="go">        points["y"],</span>
<span class="go">        min_x,</span>
<span class="go">        max_x,</span>
<span class="go">        min_y,</span>
<span class="go">        max_y,</span>
<span class="go">        scale, max_depth, min_size</span>
<span class="go">    )</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">quadtree</span><span class="p">)</span>
<span class="go">    key  level  is_quad  length  offset</span>
<span class="go">0     0      0    False      15       0</span>
<span class="go">1     1      0    False      27      15</span>
<span class="go">2     2      0    False      12      42</span>
<span class="go">3     3      0     True       4       8</span>
<span class="go">4     4      0    False       5     106</span>
<span class="go">5     6      0    False       6     111</span>
<span class="go">6     9      0    False       2     117</span>
<span class="go">7    12      0    False       1     119</span>
<span class="go">8    12      1    False      22      54</span>
<span class="go">9    13      1    False      18      76</span>
<span class="go">10   14      1    False       9      94</span>
<span class="go">11   15      1    False       3     103</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">key_to_point</span><span class="p">)</span>
<span class="go">0       63</span>
<span class="go">1       20</span>
<span class="go">2       33</span>
<span class="go">3       66</span>
<span class="go">4       19</span>
<span class="go">    ...</span>
<span class="go">115    113</span>
<span class="go">116      3</span>
<span class="go">117     78</span>
<span class="go">118     98</span>
<span class="go">119     24</span>
<span class="go">Length: 120, dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.join_quadtree_and_bounding_boxes">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">join_quadtree_and_bounding_boxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">quadtree</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">poly_bounding_boxes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_min</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_max</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.join_quadtree_and_bounding_boxes" title="Permalink to this definition">&para;</a></dt>
<dd><p>Search a quadtree for polygon or polyline bounding box intersections.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>quadtree</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A complete quadtree for a given area-of-interest bounding box.</p>
</dd>
<dt><strong>poly_bounding_boxes</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Minimum bounding boxes for a set of polygons or polylines</p>
</dd>
<dt><strong>x_min</strong></dt><dd><p>The lower-left x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>x_max</strong></dt><dd><p>The upper-right x-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>min_y</strong></dt><dd><p>The lower-left y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>max_y</strong></dt><dd><p>The upper-right y-coordinate of the area of interest bounding box</p>
</dd>
<dt><strong>scale</strong></dt><dd><p>Scale to apply to each point&rsquo;s distance from <code class="docutils literal notranslate"><span class="pre">(x_min,</span> <span class="pre">y_min)</span></code></p>
</dd>
<dt><strong>max_depth</strong></dt><dd><p>Maximum quadtree depth at which to stop testing for intersections</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Indices for each intersecting bounding box and leaf quadrant.</p>
<dl class="simple">
<dt>poly_offset<span class="classifier">cudf.Series</span></dt><dd><p>Indices for each poly bbox that intersects with the quadtree.</p>
</dd>
<dt>quad_offset<span class="classifier">cudf.Series</span></dt><dd><p>Indices for each leaf quadrant intersecting with a poly bbox.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_x</span></code> and <code class="docutils literal notranslate"><span class="pre">max_x</span></code> if <code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&gt;</span> <span class="pre">max_x</span></code></p></li>
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_y</span></code> and <code class="docutils literal notranslate"><span class="pre">max_y</span></code> if <code class="docutils literal notranslate"><span class="pre">min_y</span> <span class="pre">&gt;</span> <span class="pre">max_y</span></code></p></li>
</ul>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.points_in_spatial_window">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">points_in_spatial_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">min_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.points_in_spatial_window" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return only the subset of coordinates that fall within a
rectangular window.</p>
<p>A point <cite>(x, y)</cite> is inside the query window if and only if
<code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">max_x</span> <span class="pre">AND</span> <span class="pre">min_y</span> <span class="pre">&lt;</span> <span class="pre">y</span> <span class="pre">&lt;</span> <span class="pre">max_y</span></code></p>
<p>The window is specified by minimum and maximum x and y
coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>min_x</strong></dt><dd><p>lower x-coordinate of the query window</p>
</dd>
<dt><strong>max_x</strong></dt><dd><p>upper x-coordinate of the query window</p>
</dd>
<dt><strong>min_y</strong></dt><dd><p>lower y-coordinate of the query window</p>
</dd>
<dt><strong>max_y</strong></dt><dd><p>upper y-coordinate of the query window</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates that may fall within the window</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates that may fall within the window</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>subset of <cite>(x, y)</cite> pairs above that fall within the window</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_x</span></code> and <code class="docutils literal notranslate"><span class="pre">max_x</span></code> if <code class="docutils literal notranslate"><span class="pre">min_x</span> <span class="pre">&gt;</span> <span class="pre">max_x</span></code></p></li>
<li><p>Swaps <code class="docutils literal notranslate"><span class="pre">min_y</span></code> and <code class="docutils literal notranslate"><span class="pre">max_y</span></code> if <code class="docutils literal notranslate"><span class="pre">min_y</span> <span class="pre">&gt;</span> <span class="pre">max_y</span></code></p></li>
</ul>
</dd></dl>
</section>
<section id="gis">
<h1>GIS<a class="headerlink" href="#gis" title="Permalink to this headline">&para;</a></h1>
<p>Two GIS functions make it easier to compute distances with geographic coordinates.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.haversine_distance">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">haversine_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">p1_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p1_lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2_lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.haversine_distance" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the haversine distances between an arbitrary list of lon/lat
pairs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>p1_lon</strong></dt><dd><p>longitude of first set of coords</p>
</dd>
<dt><strong>p1_lat</strong></dt><dd><p>latitude of first set of coords</p>
</dd>
<dt><strong>p2_lon</strong></dt><dd><p>longitude of second set of coords</p>
</dd>
<dt><strong>p2_lat</strong></dt><dd><p>latitude of second set of coords</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.Series</span></dt><dd><p>The distance between all pairs of lon/lat coordinates</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.lonlat_to_cartesian">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">lonlat_to_cartesian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">origin_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin_lat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_lon</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_lat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.lonlat_to_cartesian" title="Permalink to this definition">&para;</a></dt>
<dd><p>Convert lon/lat to <code class="docutils literal notranslate"><span class="pre">x,y</span></code> coordinates with respect to an origin lon/lat
point. Results are scaled relative to the size of the Earth in kilometers.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>origin_lon</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">number</span></code></span></dt><dd><p>longitude offset  (this is subtracted from each input before
converting to x,y)</p>
</dd>
<dt><strong>origin_lat</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">number</span></code></span></dt><dd><p>latitude offset (this is subtracted from each input before
converting to x,y)</p>
</dd>
<dt><strong>input_lon</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>longitude coordinates to convert to x</p>
</dd>
<dt><strong>input_lat</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code></span></dt><dd><p>latitude coordinates to convert to y</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>x<span class="classifier">cudf.Series</span></dt><dd><p>x-coordinate of the input relative to the size of the Earth in
kilometers.</p>
</dd>
<dt>y<span class="classifier">cudf.Series</span></dt><dd><p>y-coordinate of the input relative to the size of the Earth in
kilometers.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</section>
<section id="trajectory">
<h1>Trajectory<a class="headerlink" href="#trajectory" title="Permalink to this headline">&para;</a></h1>
<p>Trajectory functions make it easy to identify and group trajectories from point data.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.derive_trajectories">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">derive_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">object_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.derive_trajectories" title="Permalink to this definition">&para;</a></dt>
<dd><p>Derive trajectories from object ids, points, and timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>object_ids</strong></dt><dd><p>column of object (e.g., vehicle) ids</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates (in kilometers)</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates (in kilometers)</p>
</dd>
<dt><strong>timestamps</strong></dt><dd><p>column of timestamps in any resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">tuple (objects, traj_offsets)</span></dt><dd><dl class="simple">
<dt>objects<span class="classifier">cudf.DataFrame</span></dt><dd><p>object_ids, xs, ys, and timestamps sorted by
<code class="docutils literal notranslate"><span class="pre">(object_id,</span> <span class="pre">timestamp)</span></code>, used by <code class="docutils literal notranslate"><span class="pre">trajectory_bounding_boxes</span></code>
and <code class="docutils literal notranslate"><span class="pre">trajectory_distances_and_speeds</span></code></p>
</dd>
<dt>traj_offsets<span class="classifier">cudf.Series</span></dt><dd><p>offsets of discovered trajectories</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute sorted objects and discovered trajectories</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objects</span><span class="p">,</span> <span class="n">traj_offsets</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">derive_trajectories</span><span class="p">(</span>
<span class="go">        [0, 1, 2, 3],  # object_id</span>
<span class="go">        [0, 0, 1, 1],  # x</span>
<span class="go">        [0, 0, 1, 1],  # y</span>
<span class="go">        [0, 10, 0, 10] # timestamp</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">traj_offsets</span><span class="p">)</span>
<span class="go">    0  0</span>
<span class="go">    1  2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
<span class="go">       object_id       x       y  timestamp</span>
<span class="go">    0          0       1       0          0</span>
<span class="go">    1          0       0       0         10</span>
<span class="go">    2          1       3       1          0</span>
<span class="go">    3          1       2       1         10</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.trajectory_distances_and_speeds">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">trajectory_distances_and_speeds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamps</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.trajectory_distances_and_speeds" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the distance traveled and speed of sets of trajectories</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trajectories</strong></dt><dd><p>number of trajectories (unique object ids)</p>
</dd>
<dt><strong>object_ids</strong></dt><dd><p>column of object (e.g., vehicle) ids</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates (in kilometers)</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates (in kilometers)</p>
</dd>
<dt><strong>timestamps</strong></dt><dd><p>column of timestamps in any resolution</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>meters<span class="classifier">cudf.Series</span></dt><dd><p>trajectory distance (in kilometers)</p>
</dd>
<dt>speed<span class="classifier">cudf.Series</span></dt><dd><p>trajectory speed (in meters/second)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the distances and speeds of derived trajectories</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objects</span><span class="p">,</span> <span class="n">traj_offsets</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">derive_trajectories</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dists_and_speeds</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">trajectory_distances_and_speeds</span><span class="p">(</span>
<span class="go">        len(traj_offsets)</span>
<span class="go">        objects['object_id'],</span>
<span class="go">        objects['x'],</span>
<span class="go">        objects['y'],</span>
<span class="go">        objects['timestamp']</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dists_and_speeds</span><span class="p">)</span>
<span class="go">                   distance          speed</span>
<span class="go">    trajectory_id</span>
<span class="go">    0                1000.0  100000.000000</span>
<span class="go">    1                1000.0  111111.109375</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.directed_hausdorff_distance">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">directed_hausdorff_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">space_offsets</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.directed_hausdorff_distance" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the directed Hausdorff distances between all pairs of
spaces.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates</p>
</dd>
<dt><strong>space_offsets</strong></dt><dd><p>beginning index of each space, plus the last space&rsquo;s end offset.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The pairwise directed distance matrix with one row and one
column per input space; the value at row i, column j represents the
hausdorff distance from space i to space j.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The directed Hausdorff distance from one space to another is the greatest
of all the distances between any point in the first space to the closest
point in the second.</p>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Hausdorff_distance">Wikipedia</a></p>
<p>Consider a pair of lines on a grid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>     <span class="p">:</span>
     <span class="n">x</span>
<span class="o">-----</span><span class="n">xyy</span><span class="o">---</span>
     <span class="p">:</span>
     <span class="p">:</span>
</pre></div>
</div>
<p>x<sub>0</sub> = (0, 0), x<sub>1</sub> = (0, 1)</p>
<p>y<sub>0</sub> = (1, 0), y<sub>1</sub> = (2, 0)</p>
<p>x<sub>0</sub> is the closest point in <code class="docutils literal notranslate"><span class="pre">x</span></code> to <code class="docutils literal notranslate"><span class="pre">y</span></code>. The distance from
x<sub>0</sub> to the farthest point in <code class="docutils literal notranslate"><span class="pre">y</span></code> is 2.</p>
<p>y<sub>0</sub> is the closest point in <code class="docutils literal notranslate"><span class="pre">y</span></code> to <code class="docutils literal notranslate"><span class="pre">x</span></code>. The distance from
y<sub>0</sub> to the farthest point in <code class="docutils literal notranslate"><span class="pre">x</span></code> is 1.414.</p>
<p>Compute the directed hausdorff distances between a set of spaces</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">directed_hausdorff_distance</span><span class="p">(</span>
<span class="go">        [0, 1, 0, 0], # xs</span>
<span class="go">        [0, 0, 1, 2], # ys</span>
<span class="go">        [0, 2, 4],    # space_offsets</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
<span class="go">         0         1</span>
<span class="go">    0  0.0  1.414214</span>
<span class="go">    1  2.0  0.000000</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.trajectory_bounding_boxes">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">trajectory_bounding_boxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_trajectories</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">object_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ys</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.trajectory_bounding_boxes" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the bounding boxes of sets of trajectories.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_trajectories</strong></dt><dd><p>number of trajectories (unique object ids)</p>
</dd>
<dt><strong>object_ids</strong></dt><dd><p>column of object (e.g., vehicle) ids</p>
</dd>
<dt><strong>xs</strong></dt><dd><p>column of x-coordinates (in kilometers)</p>
</dd>
<dt><strong>ys</strong></dt><dd><p>column of y-coordinates (in kilometers)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>minimum bounding boxes (in kilometers) for each trajectory</p>
<dl class="simple">
<dt>x_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum x-coordinate of each bounding box</p>
</dd>
<dt>y_min<span class="classifier">cudf.Series</span></dt><dd><p>the minimum y-coordinate of each bounding box</p>
</dd>
<dt>x_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum x-coordinate of each bounding box</p>
</dd>
<dt>y_max<span class="classifier">cudf.Series</span></dt><dd><p>the maximum y-coordinate of each bounding box</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Compute the minimum bounding boxes of derived trajectories</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">objects</span><span class="p">,</span> <span class="n">traj_offsets</span> <span class="o">=</span> <span class="n">trajectory</span><span class="o">.</span><span class="n">derive_trajectories</span><span class="p">(</span>
<span class="go">        [0, 0, 1, 1],  # object_id</span>
<span class="go">        [0, 1, 2, 3],  # x</span>
<span class="go">        [0, 0, 1, 1],  # y</span>
<span class="go">        [0, 10, 0, 10] # timestamp</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj_bounding_boxes</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">trajectory_bounding_boxes</span><span class="p">(</span>
<span class="go">        len(traj_offsets),</span>
<span class="go">        objects['object_id'],</span>
<span class="go">        objects['x'],</span>
<span class="go">        objects['y']</span>
<span class="go">    )</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">traj_bounding_boxes</span><span class="p">)</span>
<span class="go">    x_min   y_min   x_max   y_max</span>
<span class="go">0     0.0     0.0     2.0     2.0</span>
<span class="go">1     1.0     1.0     3.0     3.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py class">
<dt class="sig sig-object py" id="cuspatial.CubicSpline">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">CubicSpline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.CubicSpline" title="Permalink to this definition">&para;</a></dt>
<dd><p>Fits each column of the input Series <cite>y</cite> to a hermetic cubic spline.</p>
<p><code class="docutils literal notranslate"><span class="pre">cuspatial.CubicSpline</span></code> supports two usage patterns: The first is
identical to scipy.interpolate.CubicSpline:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">curve</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">curve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
</pre></div>
</div>
<p>This allows API parity with scipy. This isn&rsquo;t recommended, as scipy
host based interpolation performance is likely to exceed GPU performance
for a single curve.</p>
<p>However, cuSpatial massively outperforms scipy when many splines are fit
simultaneously. Data must be arranged in a SoA format, and the exclusive
<cite>prefix_sum</cite> of the separate curves must also be passed to the function.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NUM_SPLINES</span> <span class="o">=</span> <span class="mi">100000</span>
<span class="n">SPLINE_LENGTH</span> <span class="o">=</span> <span class="mi">101</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">SPLINE_LENGTH</span><span class="p">),)</span> <span class="o">*</span> <span class="n">NUM_SPLINES</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">SPLINE_LENGTH</span><span class="o">*</span><span class="n">NUM_SPLINES</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="n">prefix_sum</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="n">cp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">NUM_SPLINES</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">SPLINE_LENGTH</span>
<span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'int32'</span><span class="p">)</span>
<span class="n">curve</span> <span class="o">=</span> <span class="n">cuspatial</span><span class="o">.</span><span class="n">CubicSpline</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prefixes</span><span class="o">=</span><span class="n">prefix_sum</span><span class="p">)</span>
<span class="n">new_samples</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
        <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">SPLINE_LENGTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">SPLINE_LENGTH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">),)</span> <span class="o">*</span> <span class="n">NUM_SPLINES</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="n">curve_ids</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">NUM_SPLINES</span><span class="p">),</span> <span class="n">SPLINE_LENGTH</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"int32"</span><span class="p">)</span>
<span class="n">new_points</span> <span class="o">=</span> <span class="n">curve</span><span class="p">(</span><span class="n">new_samples</span><span class="p">,</span> <span class="n">curve_ids</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cuspatial.CubicSpline.__call__" title="cuspatial.CubicSpline.__call__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code></a>(coordinates[,&nbsp;groups])</p></td>
<td><p>Interpolates new input values <cite>coordinates</cite> using the <cite>.c</cite> DataFrame or map of DataFrames.</p></td>
</tr>
</tbody>
</table>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.CubicSpline.__init__">
<span class="sig-prename descclassname"><span class="pre">CubicSpline.</span></span><span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefixes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.CubicSpline.__init__" title="Permalink to this definition">&para;</a></dt>
<dd><p>Computes various error preconditions on the input data, then
uses CUDA to compute cubic splines for each set of input
coordinates on the GPU in parallel.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>t</strong><span class="classifier">cudf.Series</span></dt><dd><p>time sample values. Must be monotonically increasing.</p>
</dd>
<dt><strong>y</strong><span class="classifier">cudf.Series</span></dt><dd><p>columns to have curves fit to according to x</p>
</dd>
<dt><strong>ids (Optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>ids of each spline</p>
</dd>
<dt><strong>size (Optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>fixed size of each spline</p>
</dd>
<dt><strong>prefixes (Optional)</strong><span class="classifier">cudf.Series</span></dt><dd><p>alternative to <cite>size</cite>, allows splines of varying
length. Not yet fully supported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>CubicSpline</strong><span class="classifier">callable <cite>o</cite></span></dt><dd><p><code class="docutils literal notranslate"><span class="pre">o.c</span></code> contains the coefficients that can be used to compute new
points along the spline fitting the original <code class="docutils literal notranslate"><span class="pre">t</span></code> data. <code class="docutils literal notranslate"><span class="pre">o(n)</span></code>
interpolates the spline coordinates along new input values <code class="docutils literal notranslate"><span class="pre">n</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt class="sig sig-object py" id="cuspatial.CubicSpline.__call__">
<span class="sig-prename descclassname"><span class="pre">CubicSpline.</span></span><span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">coordinates</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">groups</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.CubicSpline.__call__" title="Permalink to this definition">&para;</a></dt>
<dd><p>Interpolates new input values <cite>coordinates</cite> using the <cite>.c</cite> DataFrame
or map of DataFrames.</p>
</dd></dl>
</section>
<section id="io">
<h1>IO<a class="headerlink" href="#io" title="Permalink to this headline">&para;</a></h1>
<p>cuSpatial offers native GPU-accelerated shapefile reading. In addition, any host-side GeoPandas DataFrame can be copied into GPU memory for use with cuSpatial
algorithms.</p>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.read_polygon_shapefile">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">read_polygon_shapefile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.read_polygon_shapefile" title="Permalink to this definition">&para;</a></dt>
<dd><p>Reads polygon geometry from an ESRI shapefile into GPU memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filename</strong><span class="classifier">str, pathlike</span></dt><dd><p>ESRI Shapefile file path (usually ends in <code class="docutils literal notranslate"><span class="pre">.shp</span></code>)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">tuple (cudf.Series, cudf.Series, cudf.DataFrame)</span></dt><dd></dd>
<dt><strong>poly_offsets</strong><span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>Offsets of the first ring in each polygon</p>
</dd>
<dt><strong>ring_offsets</strong><span class="classifier">cudf.Series(dtype=np.int32)</span></dt><dd><p>Offsets of the first point in each ring</p>
</dd>
<dt><strong>points</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>DataFrame of all points in the shapefile</dt><dd><dl class="simple">
<dt>x<span class="classifier">cudf.Series(dtype=np.float64)</span></dt><dd><p>x-components of each polygon&rsquo;s points</p>
</dd>
<dt>y<span class="classifier">cudf.Series(dtype=np.float64)</span></dt><dd><p>y-components of each polygon&rsquo;s points</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt class="sig sig-object py" id="cuspatial.from_geopandas">
<span class="sig-prename descclassname"><span class="pre">cuspatial.</span></span><span class="sig-name descname"><span class="pre">from_geopandas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gpdf</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#cuspatial.from_geopandas" title="Permalink to this definition">&para;</a></dt>
<dd><p>Converts a geopandas mixed geometry dataframe into a cuspatial geometry
dataframe.</p>
<p>Possible inputs:</p>
<p>geopandas.geoseries.GeoSeries
geopandas.geodataframe.GeoDataFrame</p>
</dd></dl>
</section>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="p" class="btn btn-neutral float-left" href="index.html" rel="prev" title="Welcome to cuSpatial&rsquo;s documentation!"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
</div>
<hr>
<div role="contentinfo">
<p>
        &copy; Copyright 2019, NVIDIA.

    </p>
</div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>