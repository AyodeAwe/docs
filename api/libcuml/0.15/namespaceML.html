<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.18" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>cuML C++ API: ML Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcuml</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">libnvstrings</a><a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">nvstrings</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (0.15)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcuml/nightly">nightly (0.15)</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">stable (0.14)</a></div></div></div>

</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#namespaces">Namespaces</a> |
<a href="#nested-classes">Classes</a> |
<a href="#typedef-members">Typedefs</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> |
<a href="#var-members">Variables</a> </div>
<div class="headertitle">
<div class="title">ML Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceML_1_1Comms"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Comms.html">Comms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Datasets"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Datasets.html">Datasets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1DecisionTree"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1DecisionTree.html">DecisionTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1detail"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1fil"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1fil.html">fil</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1GLM"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1GLM.html">GLM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1HoltWinters"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1HoltWinters.html">HoltWinters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Internals"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Internals.html">Internals</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1kmeans"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1kmeans.html">kmeans</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Metrics"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Metrics.html">Metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Solver"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Solver.html">Solver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Spectral"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Spectral.html">Spectral</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1Stationarity"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1Stationarity.html">Stationarity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:namespaceML_1_1SVM"><td align="right" class="memItemLeft" valign="top">  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML_1_1SVM.html">SVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cachingDeviceAllocator.html">cachingDeviceAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Implemententation of ML::deviceAllocator using the cub's caching allocator API.  <a href="classML_1_1cachingDeviceAllocator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Handle to manage resources needed by cuML algorithms.  <a href="classML_1_1cumlHandle.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cumlHandle__impl.html">cumlHandle_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cumlMPICommunicator__impl.html">cumlMPICommunicator_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1cumlStdCommunicator__impl.html">cumlStdCommunicator_impl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">A cumlCommunicator implementation capable of running collective communications with NCCL and point-to-point-communications with UCX. Note that the latter is optional.  <a href="classML_1_1cumlStdCommunicator__impl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">The main Logging class for cuML library.  <a href="classML_1_1Logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1OptimParams.html">OptimParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1params.html">params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">structure for pca parameters. Ref: <a href="http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html">http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html</a> <a href="classML_1_1paramsPCATemplate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsSolver.html">paramsSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1PatternSetter.html">PatternSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">RAII based pattern setter for <a class="el" href="classML_1_1Logger.html" title="The main Logging class for cuML library.">Logger</a> class.  <a href="classML_1_1PatternSetter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1rand__mat.html">rand_mat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rf.html">rf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structML_1_1RF__params.html">RF_params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rfClassifier.html">rfClassifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rfRegressor.html">rfRegressor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rmmAllocatorAdapter.html">rmmAllocatorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Implemententation of ML::deviceAllocator using the RAPIDS Memory Manager (RMM) for allocations.  <a href="classML_1_1rmmAllocatorAdapter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1rmmPoolAllocatorAdapter.html">rmmPoolAllocatorAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Implemententation of ML::deviceAllocator using the RMM pool.  <a href="classML_1_1rmmPoolAllocatorAdapter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1stdAllocatorAdapter.html">stdAllocatorAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1Tensor.html">Tensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1thrustAllocatorAdapter.html">thrustAllocatorAdapter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1UMAP__API.html">UMAP_API</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">class  </td><td class="memItemRight" valign="bottom"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gab2bffedf6f8d520e216a6542ebf6a0f1"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsTSVDTemplate.html">paramsTSVDTemplate</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a></td></tr>
<tr class="separator:gab2bffedf6f8d520e216a6542ebf6a0f1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga239d146c5a5545dd84e3d0b6e305f631"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="classML_1_1paramsPCATemplate.html">paramsPCATemplate</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a></td></tr>
<tr class="separator:ga239d146c5a5545dd84e3d0b6e305f631"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a36df48edc11fcd68dd8b6f4a76526e7b"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a></td></tr>
<tr class="separator:a36df48edc11fcd68dd8b6f4a76526e7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acbf0352d6a255f990fcdf949b898d6af"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, int &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a></td></tr>
<tr class="separator:acbf0352d6a255f990fcdf949b898d6af"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a79048a796facf156e926834d97bec78f"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; float, float &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a></td></tr>
<tr class="separator:a79048a796facf156e926834d97bec78f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a64f2117024176a6fab67a1a6b8925243"><td align="right" class="memItemLeft" valign="top">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; double, double &gt; </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a></td></tr>
<tr class="separator:a64f2117024176a6fab67a1a6b8925243"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7324898185a2fc9a9145f9bad555049b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__pcaSolver.html#ga7324898185a2fc9a9145f9bad555049b">solver</a> : int { <a class="el" href="group__pcaSolver.html#gga7324898185a2fc9a9145f9bad555049ba38769546eb5536bd58d5eb9922c3e0bf">solver::COV_EIG_DQ</a>, 
<a class="el" href="group__pcaSolver.html#gga7324898185a2fc9a9145f9bad555049ba3a077c1d31d8e7f29a92eb7ea002daad">solver::COV_EIG_JACOBI</a>, 
<a class="el" href="group__pcaSolver.html#gga7324898185a2fc9a9145f9bad555049ba98f1b25da14f4d5d8c73d1a98bc79cc3">solver::RANDOMIZED</a>
 }</td></tr>
<tr class="separator:ga7324898185a2fc9a9145f9bad555049b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d83b99fe769e2e9bf3596bb1604ab4f"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> { <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf">CLASSIFICATION</a>, 
<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586">REGRESSION</a>
 }</td></tr>
<tr class="separator:a4d83b99fe769e2e9bf3596bb1604ab4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a> { <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315">REGRESSION_MODEL</a> = 1, 
<a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006">CLASSIFICATION_MODEL</a> = 2
 }</td></tr>
<tr class="separator:af60801cb5c9adac3f6f5bd4bd43aa2f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4d9fd2e8fe0cfbbd81877eee212b88d9"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">MetricType</a> { <br/>
  <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a138628cbf0d89bc28f2dd159f426c13d">METRIC_INNER_PRODUCT</a> = 0, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a5e87bd6f2a6c86ad23937eedf66de99b">METRIC_L2</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a6d9ec7c577a546e75c72ee872241ef4e">METRIC_L1</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9aa01f9bc4910d9f004046489a11dc815e">METRIC_Linf</a>, 
<br/>
  <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ab136e195c4dd9de8a55edaa0830ddf2f">METRIC_Lp</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ae507c1b9eb779a39b742fa8e3e22cd0e">METRIC_Canberra</a> = 20, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9a2124363d5cceb96ec8c9d87e0e9ece05">METRIC_BrayCurtis</a>, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ad4265672a802bf53d58db72de56ddd22">METRIC_JensenShannon</a>, 
<br/>
  <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ae401fdab977404f1b08e85985f7b4bf8">METRIC_Cosine</a> = 100, 
<a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9ad4bc32758f26d167d264e7574429b024">METRIC_Correlation</a>
<br/>
 }</td></tr>
<tr class="separator:a4d9fd2e8fe0cfbbd81877eee212b88d9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga134c8dc1d94a4ee420679aec61849e2b"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga134c8dc1d94a4ee420679aec61849e2b">random_matrix_type</a> { <a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baa7bee409e76fac7544d660db7e2eb7c0">unset</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2bad1e6d312a4b10fe213eac82ffb1cdd72">dense</a>, 
<a class="el" href="group__paramsRPROJ.html#gga134c8dc1d94a4ee420679aec61849e2baca3f848ed01f4ea23129374f48c98293">sparse</a>
 }</td></tr>
<tr class="separator:ga134c8dc1d94a4ee420679aec61849e2b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1adf3fea9cf9cde96ecf353b43818079"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">lr_type</a> { <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1">OPTIMAL</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb">CONSTANT</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106">INVSCALING</a>, 
<a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a">ADAPTIVE</a>
 }</td></tr>
<tr class="separator:a1adf3fea9cf9cde96ecf353b43818079"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67da49ce109878bcdbb29a8777d28de1"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">loss_funct</a> { <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4">SQRD_LOSS</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a">HINGE</a>, 
<a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d">LOG</a>
 }</td></tr>
<tr class="separator:a67da49ce109878bcdbb29a8777d28de1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a899c5f26e201a81a2c12bb7eed9b015d"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">penalty</a> { <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07">NONE</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627">ELASTICNET</a>
 }</td></tr>
<tr class="separator:a899c5f26e201a81a2c12bb7eed9b015d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe9899e0c7ff1cf722a35bcf35283953"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953">SPLIT_ALGO</a> { <a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a5ce779f6c1df4e4ec40cd9cee88837e2">HIST</a>, 
<a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a61e77c561b3834cdc46508db24d72f90">GLOBAL_QUANTILE</a>, 
<a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953a5773eabe7d91f72e535b233ca73ba5c9">SPLIT_ALGO_END</a>
 }</td></tr>
<tr class="separator:afe9899e0c7ff1cf722a35bcf35283953"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a823912afaa51f58a997564eadb6d9405"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> { <br/>
  <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6">GINI</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161">ENTROPY</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e">MSE</a>, 
<a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e">MAE</a>, 
<br/>
  <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174">CRITERION_END</a>
<br/>
 }</td></tr>
<tr class="separator:a823912afaa51f58a997564eadb6d9405"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d55de18185e36dd8f8a6d735e6a91e6"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">SeasonalType</a> { <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3">ADDITIVE</a>, 
<a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226">MULTIPLICATIVE</a>
 }</td></tr>
<tr class="separator:a8d55de18185e36dd8f8a6d735e6a91e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85e691126b37f5e1dc834841cad1479c"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">OptimCriterion</a> { <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21">OPTIM_BFGS_ITER_LIMIT</a> = 0, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590">OPTIM_MIN_PARAM_DIFF</a> = 1, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5">OPTIM_MIN_ERROR_DIFF</a> = 2, 
<a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc">OPTIM_MIN_GRAD_NORM</a> = 3
 }</td></tr>
<tr class="separator:a85e691126b37f5e1dc834841cad1479c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1529da2b94c67018bb14f404f6e9aeac"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">Norm</a> { <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc">L0</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072">L1</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e">L2</a>, 
<a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26">LINF</a>
 }</td></tr>
<tr class="separator:a1529da2b94c67018bb14f404f6e9aeac"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af1a8aaa312a62f236a4238b4abdbbd49"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af1a8aaa312a62f236a4238b4abdbbd49">initialize_mpi_comms</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, MPI_Comm comm)</td></tr>
<tr class="separator:af1a8aaa312a62f236a4238b4abdbbd49"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b5faa4ceb0e330450d1b210b3bd86c4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a3b5faa4ceb0e330450d1b210b3bd86c4">inject_comms</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, ncclComm_t comm, int size, int rank)</td></tr>
<tr class="memdesc:a3b5faa4ceb0e330450d1b210b3bd86c4"><td class="mdescLeft"> </td><td class="mdescRight">Given an initialized comms handle for NCCL, this function builds a cumlCommunicator object and injects it into the given <a class="el" href="classML_1_1cumlHandle.html" title="Handle to manage resources needed by cuML algorithms.">cumlHandle</a> instance. The underlying cumlCommunicator will only have support for collective communications functions.  <a href="namespaceML.html#a3b5faa4ceb0e330450d1b210b3bd86c4">More...</a><br/></td></tr>
<tr class="separator:a3b5faa4ceb0e330450d1b210b3bd86c4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8d9a73d4716feafd591de704ce998cb9"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8d9a73d4716feafd591de704ce998cb9">ucx_enabled</a> ()</td></tr>
<tr class="separator:a8d9a73d4716feafd591de704ce998cb9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6df300b3bb64878210f979639702e618"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a6df300b3bb64878210f979639702e618">inject_comms_py</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> *handle, ncclComm_t comm, void *ucp_worker, void *eps, int size, int rank)</td></tr>
<tr class="memdesc:a6df300b3bb64878210f979639702e618"><td class="mdescLeft"> </td><td class="mdescRight">This function wraps the inject comms functions in <a class="el" href="std_2include_2cuML__comms_8hpp.html">cpp/comms/std/include/cuML_comms.hpp</a> to decouple the Python layer from the optional UCX dependency in the C++ build. This allows the Cython to compile without having to propagate the <code>WITH_UCX</code> directive to that layer.  <a href="namespaceML.html#a6df300b3bb64878210f979639702e618">More...</a><br/></td></tr>
<tr class="separator:a6df300b3bb64878210f979639702e618"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c91b8b040db35e8c514caf92ef9faa9"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7c91b8b040db35e8c514caf92ef9faa9">inject_comms_py_coll</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> *handle, ncclComm_t comm, int size, int rank)</td></tr>
<tr class="memdesc:a7c91b8b040db35e8c514caf92ef9faa9"><td class="mdescLeft"> </td><td class="mdescRight">This function follows the design of the wrapper function in <a class="el" href="std_2include_2cuML__comms_8hpp.html">cpp/comms/std/include/cuML_comms.hpp</a> to decouple the Python layer injection functions from the C++ layer functions.  <a href="namespaceML.html#a7c91b8b040db35e8c514caf92ef9faa9">More...</a><br/></td></tr>
<tr class="separator:a7c91b8b040db35e8c514caf92ef9faa9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4cd9a45777c1905c63cad95ae03fa275"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4cd9a45777c1905c63cad95ae03fa275">ncclUniqueIdFromChar</a> (ncclUniqueId *id, char *uniqueId, int size)</td></tr>
<tr class="memdesc:a4cd9a45777c1905c63cad95ae03fa275"><td class="mdescLeft"> </td><td class="mdescRight">Stores the given character array on the given ncclUniqueId struct.  <a href="namespaceML.html#a4cd9a45777c1905c63cad95ae03fa275">More...</a><br/></td></tr>
<tr class="separator:a4cd9a45777c1905c63cad95ae03fa275"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa600091e11674391cf9ccedee8904612"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa600091e11674391cf9ccedee8904612">get_unique_id</a> (char *uid, int size)</td></tr>
<tr class="memdesc:aa600091e11674391cf9ccedee8904612"><td class="mdescLeft"> </td><td class="mdescRight">Returns a NCCL unique ID as a character array. PyTorch uses this same approach, so that it can be more easily converted to a native Python string by Cython and further serialized to be sent across process &amp; node boundaries.  <a href="namespaceML.html#aa600091e11674391cf9ccedee8904612">More...</a><br/></td></tr>
<tr class="separator:aa600091e11674391cf9ccedee8904612"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gaf0c1766c9fb22fd1fdd08a5e05bb5668"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#gaf0c1766c9fb22fd1fdd08a5e05bb5668">dbscanFit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, int n_rows, int n_cols, float eps, int min_pts, int *labels, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:gaf0c1766c9fb22fd1fdd08a5e05bb5668"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga44c7fb3c9ffb06d1c1ad51cad2cc3684"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#ga44c7fb3c9ffb06d1c1ad51cad2cc3684">dbscanFit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, int n_rows, int n_cols, double eps, int min_pts, int *labels, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ga44c7fb3c9ffb06d1c1ad51cad2cc3684"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga2ee74db981acaee5a050ed4654ebbb7b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#ga2ee74db981acaee5a050ed4654ebbb7b">dbscanFit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, int64_t n_rows, int64_t n_cols, float eps, int min_pts, int64_t *labels, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ga2ee74db981acaee5a050ed4654ebbb7b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gadd1a88140a10d7a9e0a712fae925fe2d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="group__DbscanCpp.html#gadd1a88140a10d7a9e0a712fae925fe2d">dbscanFit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, int64_t n_rows, int64_t n_cols, double eps, int min_pts, int64_t *labels, size_t max_bytes_per_batch=0, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:gadd1a88140a10d7a9e0a712fae925fe2d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gabb9694969393f0288a606c9184435ef9"><td align="right" class="memItemLeft" valign="top">std::string </td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gabb9694969393f0288a606c9184435ef9">format</a> (const char *fmt, va_list &amp;vl)</td></tr>
<tr class="separator:gabb9694969393f0288a606c9184435ef9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gad55df9da3c66646eee88f92620cef30a"><td align="right" class="memItemLeft" valign="top">std::string </td><td class="memItemRight" valign="bottom"><a class="el" href="group__CStringFormat.html#gad55df9da3c66646eee88f92620cef30a">format</a> (const char *fmt,...)</td></tr>
<tr class="separator:gad55df9da3c66646eee88f92620cef30a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a650eaab0fc4163345a1b1b8079d87e1d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a650eaab0fc4163345a1b1b8079d87e1d">pcaFit</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a650eaab0fc4163345a1b1b8079d87e1d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a08408e733e361d2f369648b8e27d2ffb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a08408e733e361d2f369648b8e27d2ffb">pcaFit</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a08408e733e361d2f369648b8e27d2ffb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa42a9bd0873815ffa067f6c68366e425"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa42a9bd0873815ffa067f6c68366e425">pcaFitTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, float *mu, float *noise_vars, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:aa42a9bd0873815ffa067f6c68366e425"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a073f1d1acd1f22f726a4ab8801a9cd6d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a073f1d1acd1f22f726a4ab8801a9cd6d">pcaFitTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, double *mu, double *noise_vars, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a073f1d1acd1f22f726a4ab8801a9cd6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a72bff3ce27b8d1e10d96ba47ebbe52de"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a72bff3ce27b8d1e10d96ba47ebbe52de">pcaInverseTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *trans_input, float *components, float *singular_vals, float *mu, float *input, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a72bff3ce27b8d1e10d96ba47ebbe52de"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5321540ed0a062057c8617ca56382d35"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5321540ed0a062057c8617ca56382d35">pcaInverseTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *trans_input, double *components, double *singular_vals, double *mu, double *input, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a5321540ed0a062057c8617ca56382d35"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91afa12c5a354f240d50cf7051f58561"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a91afa12c5a354f240d50cf7051f58561">pcaTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, float *components, float *trans_input, float *singular_vals, float *mu, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a91afa12c5a354f240d50cf7051f58561"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3b77d53971e6f922973514d1e169a15b"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a3b77d53971e6f922973514d1e169a15b">pcaTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, double *components, double *trans_input, double *singular_vals, double *mu, const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp;prms)</td></tr>
<tr class="separator:a3b77d53971e6f922973514d1e169a15b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abf3d16c9eb89125f257082b713e6a7f6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#abf3d16c9eb89125f257082b713e6a7f6">tsvdFit</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, float *components, float *singular_vals, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:abf3d16c9eb89125f257082b713e6a7f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a330b04019c207fde869a3572d36335dd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a330b04019c207fde869a3572d36335dd">tsvdFit</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, double *components, double *singular_vals, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a330b04019c207fde869a3572d36335dd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a09770de4a23e8765b6c419dd4e8a09ca"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a09770de4a23e8765b6c419dd4e8a09ca">tsvdInverseTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *trans_input, float *components, float *input, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a09770de4a23e8765b6c419dd4e8a09ca"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a11c6b91cabee4748ce043bec4736c11c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a11c6b91cabee4748ce043bec4736c11c">tsvdInverseTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *trans_input, double *components, double *input, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a11c6b91cabee4748ce043bec4736c11c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7c823835f3b168baf3d0ec6878de4114"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7c823835f3b168baf3d0ec6878de4114">tsvdTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, float *components, float *trans_input, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a7c823835f3b168baf3d0ec6878de4114"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aba4a75968fc9bf15a80a5208542c28f4"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aba4a75968fc9bf15a80a5208542c28f4">tsvdTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, double *components, double *trans_input, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:aba4a75968fc9bf15a80a5208542c28f4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4bcc22831a2f38b9b7c142d6238a447c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4bcc22831a2f38b9b7c142d6238a447c">tsvdFitTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *input, float *trans_input, float *components, float *explained_var, float *explained_var_ratio, float *singular_vals, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:a4bcc22831a2f38b9b7c142d6238a447c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac078362b68c7ac43eab61249012ce16f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac078362b68c7ac43eab61249012ce16f">tsvdFitTransform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, double *input, double *trans_input, double *components, double *explained_var, double *explained_var_ratio, double *singular_vals, const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp;prms)</td></tr>
<tr class="separator:ac078362b68c7ac43eab61249012ce16f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c7fcf2379a3d18e1c08840ff530eda9"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a5c7fcf2379a3d18e1c08840ff530eda9">set_all_rf_metrics</a> (<a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> rf_type, float accuracy, double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:a5c7fcf2379a3d18e1c08840ff530eda9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85f241652a9dfc89e280200e7618ed32"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85f241652a9dfc89e280200e7618ed32">set_rf_metrics_classification</a> (float accuracy)</td></tr>
<tr class="separator:a85f241652a9dfc89e280200e7618ed32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaa0b5eb27fbd28c93285b9ada72930d8"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aaa0b5eb27fbd28c93285b9ada72930d8">set_rf_metrics_regression</a> (double mean_abs_error, double mean_squared_error, double median_abs_error)</td></tr>
<tr class="separator:aaa0b5eb27fbd28c93285b9ada72930d8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a390319c6e316ef242d477e8fa326f2d0"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a390319c6e316ef242d477e8fa326f2d0">print</a> (const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> rf_metrics)</td></tr>
<tr class="separator:a390319c6e316ef242d477e8fa326f2d0"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a45c9a84e0b86ac2c4838a3eaab325dfc"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a45c9a84e0b86ac2c4838a3eaab325dfc">set_rf_params</a> (<a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, int cfg_n_trees=1, bool cfg_bootstrap=true, float cfg_rows_sample=1.0f, int cfg_seed=-1, int cfg_n_streams=8)</td></tr>
<tr class="separator:a45c9a84e0b86ac2c4838a3eaab325dfc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a510e44e64dee8d7fb35b527ece1ceada"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a510e44e64dee8d7fb35b527ece1ceada">set_all_rf_params</a> (<a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp;<a class="el" href="classML_1_1params.html">params</a>, int cfg_n_trees, bool cfg_bootstrap, float cfg_rows_sample, int cfg_seed, int cfg_n_streams, <a class="el" href="structML_1_1DecisionTree_1_1DecisionTreeParams.html">DecisionTree::DecisionTreeParams</a> cfg_tree_params)</td></tr>
<tr class="separator:a510e44e64dee8d7fb35b527ece1ceada"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a69f0169515a838c25ba3080b48ae2ceb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a69f0169515a838c25ba3080b48ae2ceb">validity_check</a> (const <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params)</td></tr>
<tr class="separator:a69f0169515a838c25ba3080b48ae2ceb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa3ded9ffe5af3b52a2b8a301a362af10"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa3ded9ffe5af3b52a2b8a301a362af10">print</a> (const <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params)</td></tr>
<tr class="separator:aa3ded9ffe5af3b52a2b8a301a362af10"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa25bebb87dff8c328b2d4809f640f789"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa25bebb87dff8c328b2d4809f640f789">preprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa25bebb87dff8c328b2d4809f640f789"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a05ee22c0f2c66e9bb7d60c72e5d61b32">postprocess_labels</a> (int n_rows, std::vector&lt; int &gt; &amp;labels, std::map&lt; int, int &gt; &amp;labels_map, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a05ee22c0f2c66e9bb7d60c72e5d61b32"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab1275db1b0385b97fbb481b719322a25"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:ab1275db1b0385b97fbb481b719322a25"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab1275db1b0385b97fbb481b719322a25">null_trees_ptr</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&amp;forest)</td></tr>
<tr class="separator:ab1275db1b0385b97fbb481b719322a25"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a47bd45d133f5b3bb3748a6e5d1c61c91"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a47bd45d133f5b3bb3748a6e5d1c61c91">delete_rf_metadata</a> (<a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a47bd45d133f5b3bb3748a6e5d1c61c91"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a40395e030bda0e7170453320450b5f8a"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a40395e030bda0e7170453320450b5f8a"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a40395e030bda0e7170453320450b5f8a">print_rf_summary</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a40395e030bda0e7170453320450b5f8a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a983711adcb719ce812e5f5d3641f108e"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a983711adcb719ce812e5f5d3641f108e"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a983711adcb719ce812e5f5d3641f108e">print_rf_detailed</a> (const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest)</td></tr>
<tr class="separator:a983711adcb719ce812e5f5d3641f108e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a684813418506a4839a61692008e4cfb9"><td class="memTemplParams" colspan="2">template&lt;class T , class L &gt; </td></tr>
<tr class="memitem:a684813418506a4839a61692008e4cfb9"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceML.html#a684813418506a4839a61692008e4cfb9">build_treelite_forest</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> *model, const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *forest, int num_features, int <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">task_category</a>)</td></tr>
<tr class="separator:a684813418506a4839a61692008e4cfb9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td align="right" class="memItemLeft" valign="top"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">concatenate_trees</a> (std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af142813513ee46988a79fd3dc4ab52a6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af142813513ee46988a79fd3dc4ab52a6">compare_concat_forest_to_subforests</a> (<a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> concat_tree_handle, std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; treelite_handles)</td></tr>
<tr class="separator:af142813513ee46988a79fd3dc4ab52a6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3178043c2fb0711c827614649cd6028f"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a3178043c2fb0711c827614649cd6028f">fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp;forest, float *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a3178043c2fb0711c827614649cd6028f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af46cf0ee6ea9c998146d3102ccd01868"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af46cf0ee6ea9c998146d3102ccd01868">fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp;forest, double *input, int n_rows, int n_cols, int *labels, int n_unique_labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:af46cf0ee6ea9c998146d3102ccd01868"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac091c51e7c651e9e75a7d16ef2c0b833"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ac091c51e7c651e9e75a7d16ef2c0b833">predict</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ac091c51e7c651e9e75a7d16ef2c0b833"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afd9088f0eb72425f5a189bda4ba9190d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afd9088f0eb72425f5a189bda4ba9190d">predict</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:afd9088f0eb72425f5a189bda4ba9190d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a238f7921f115171581bdc6d4bd2b373c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a238f7921f115171581bdc6d4bd2b373c">predictGetAll</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const float *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a238f7921f115171581bdc6d4bd2b373c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab21de19a1297048acf9e29ee67832147"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab21de19a1297048acf9e29ee67832147">predictGetAll</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const double *input, int n_rows, int n_cols, int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ab21de19a1297048acf9e29ee67832147"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af494468925b451bbb729222f794e2f37"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af494468925b451bbb729222f794e2f37">score</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:af494468925b451bbb729222f794e2f37"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a713c689e1979ec0282f6f1986b20e1ae"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a713c689e1979ec0282f6f1986b20e1ae">score</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *forest, const int *ref_labels, int n_rows, const int *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a713c689e1979ec0282f6f1986b20e1ae"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c0fe802b28704b3cfc87185a9ff028b"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2c0fe802b28704b3cfc87185a9ff028b">set_rf_class_obj</a> (int max_depth, int max_leaves, float max_features, int n_bins, int split_algo, int min_rows_per_node, float min_impurity_decrease, bool bootstrap_features, bool bootstrap, int n_trees, float rows_sample, int seed, <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> split_criterion, bool quantile_per_tree, int cfg_n_streams)</td></tr>
<tr class="separator:a2c0fe802b28704b3cfc87185a9ff028b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad45e1013123ee57f6547a791b7cb40c6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad45e1013123ee57f6547a791b7cb40c6">fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp;forest, float *input, int n_rows, int n_cols, float *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:ad45e1013123ee57f6547a791b7cb40c6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa31ee6fbdebd3e6d899e8de88b304473"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa31ee6fbdebd3e6d899e8de88b304473">fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp;forest, double *input, int n_rows, int n_cols, double *labels, <a class="el" href="structML_1_1RF__params.html">RF_params</a> rf_params, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:aa31ee6fbdebd3e6d899e8de88b304473"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2aeb706e9c6ad4d09649040cde64de04"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2aeb706e9c6ad4d09649040cde64de04">predict</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *input, int n_rows, int n_cols, float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a2aeb706e9c6ad4d09649040cde64de04"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af597ab3d0b866d746894d1f01fec48b1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af597ab3d0b866d746894d1f01fec48b1">predict</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *input, int n_rows, int n_cols, double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:af597ab3d0b866d746894d1f01fec48b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:acb0c99770c5d304c065f2e4250f623ff"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#acb0c99770c5d304c065f2e4250f623ff">score</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *forest, const float *ref_labels, int n_rows, const float *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:acb0c99770c5d304c065f2e4250f623ff"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a431e76b38ada50ecb92dc346dd37814c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a431e76b38ada50ecb92dc346dd37814c">score</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;user_handle, const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *forest, const double *ref_labels, int n_rows, const double *predictions, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>)</td></tr>
<tr class="separator:a431e76b38ada50ecb92dc346dd37814c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4e2908f6a67d8590d7b55d1bb28d8601"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a4e2908f6a67d8590d7b55d1bb28d8601">TSNE_fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const float *X, float *Y, const int n, const int p, const int dim=2, int n_neighbors=1023, const float theta=0.5f, const float epssq=0.0025, float perplexity=50.0f, const int perplexity_max_iter=100, const float perplexity_tol=1e-5, const float early_exaggeration=12.0f, const int exaggeration_iter=250, const float min_gain=0.01f, const float pre_learning_rate=200.0f, const float post_learning_rate=500.0f, const int max_iter=1000, const float min_grad_norm=1e-7, const float pre_momentum=0.5, const float post_momentum=0.8, const long long random_state=-1, int verbosity=<a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a>, const bool intialize_embeddings=true, bool barnes_hut=true)</td></tr>
<tr class="memdesc:a4e2908f6a67d8590d7b55d1bb28d8601"><td class="mdescLeft"> </td><td class="mdescRight">Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2).  <a href="namespaceML.html#a4e2908f6a67d8590d7b55d1bb28d8601">More...</a><br/></td></tr>
<tr class="separator:a4e2908f6a67d8590d7b55d1bb28d8601"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8fa60115383a17ed87ca372c1fcddbdb"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a8fa60115383a17ed87ca372c1fcddbdb">transform</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *X, int n, int d, int64_t *knn_indices, float *knn_dists, float *orig_X, int orig_n, float *embedding, int embedding_n, <a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> *<a class="el" href="classML_1_1params.html">params</a>, float *transformed)</td></tr>
<tr class="separator:a8fa60115383a17ed87ca372c1fcddbdb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afb04181b9f5bbcbf551b761927a0f24d"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#afb04181b9f5bbcbf551b761927a0f24d">find_ab</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, <a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:afb04181b9f5bbcbf551b761927a0f24d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad764fd7aacaefdae4073c077e4ad636a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad764fd7aacaefdae4073c077e4ad636a">fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *X, float *y, int n, int d, int64_t *knn_indices, float *knn_dists, <a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> *<a class="el" href="classML_1_1params.html">params</a>, float *embeddings)</td></tr>
<tr class="separator:ad764fd7aacaefdae4073c077e4ad636a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96e08b2209718522d472238b3792cfb8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a96e08b2209718522d472238b3792cfb8">fit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *X, int n, int d, int64_t *knn_indices, float *knn_dists, <a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> *<a class="el" href="classML_1_1params.html">params</a>, float *embeddings)</td></tr>
<tr class="separator:a96e08b2209718522d472238b3792cfb8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a398a682ed8fe6c94b92c16ea8d976dbd"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a398a682ed8fe6c94b92c16ea8d976dbd">brute_force_knn</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, std::vector&lt; float * &gt; &amp;input, std::vector&lt; int &gt; &amp;sizes, int D, float *search_items, int n, int64_t *res_I, float *res_D, int k, bool rowMajorIndex=false, bool rowMajorQuery=false, <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">MetricType</a> metric=MetricType::METRIC_L2, float metric_arg=2.0f, bool expanded=false)</td></tr>
<tr class="memdesc:a398a682ed8fe6c94b92c16ea8d976dbd"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances.  <a href="namespaceML.html#a398a682ed8fe6c94b92c16ea8d976dbd">More...</a><br/></td></tr>
<tr class="separator:a398a682ed8fe6c94b92c16ea8d976dbd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a533599d0a845ce150a5292830d3e9044"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a533599d0a845ce150a5292830d3e9044">knn_classify</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, int *out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_labels, size_t n_samples, int k)</td></tr>
<tr class="memdesc:a533599d0a845ce150a5292830d3e9044"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#a533599d0a845ce150a5292830d3e9044">More...</a><br/></td></tr>
<tr class="separator:a533599d0a845ce150a5292830d3e9044"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa135fed945f1fadf8fe6b96de1652a1c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aa135fed945f1fadf8fe6b96de1652a1c">knn_regress</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, float *out, int64_t *knn_indices, std::vector&lt; float * &gt; &amp;y, size_t n_labels, size_t n_samples, int k)</td></tr>
<tr class="memdesc:aa135fed945f1fadf8fe6b96de1652a1c"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn.  <a href="namespaceML.html#aa135fed945f1fadf8fe6b96de1652a1c">More...</a><br/></td></tr>
<tr class="separator:aa135fed945f1fadf8fe6b96de1652a1c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a85e06ffab0789d683296b9ab05b25ea6"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a85e06ffab0789d683296b9ab05b25ea6">knn_class_proba</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, std::vector&lt; float * &gt; &amp;out, int64_t *knn_indices, std::vector&lt; int * &gt; &amp;y, size_t n_labels, size_t n_samples, int k)</td></tr>
<tr class="memdesc:a85e06ffab0789d683296b9ab05b25ea6"><td class="mdescLeft"> </td><td class="mdescRight">Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is.  <a href="namespaceML.html#a85e06ffab0789d683296b9ab05b25ea6">More...</a><br/></td></tr>
<tr class="separator:a85e06ffab0789d683296b9ab05b25ea6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gae043ea63501b625fb2ce349e6ace0920"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:gae043ea63501b625fb2ce349e6ace0920"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#gae043ea63501b625fb2ce349e6ace0920">RPROJfit</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:gae043ea63501b625fb2ce349e6ace0920"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ga5d7e0d9de2a49451f5933bdedd14dbef"><td class="memTemplParams" colspan="2">template&lt;typename math_t &gt; </td></tr>
<tr class="memitem:ga5d7e0d9de2a49451f5933bdedd14dbef"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#ga5d7e0d9de2a49451f5933bdedd14dbef">RPROJtransform</a> (const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, math_t *input, <a class="el" href="structML_1_1rand__mat.html">rand_mat</a>&lt; math_t &gt; *random_matrix, math_t *output, <a class="el" href="structML_1_1paramsRPROJ.html">paramsRPROJ</a> *<a class="el" href="classML_1_1params.html">params</a>)</td></tr>
<tr class="separator:ga5d7e0d9de2a49451f5933bdedd14dbef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td align="right" class="memItemLeft" valign="top">size_t </td><td class="memItemRight" valign="bottom"><a class="el" href="group__paramsRPROJ.html#gacb2b3ebad5d3f97745d7d8d8e57d8345">johnson_lindenstrauss_min_dim</a> (size_t n_samples, double eps)</td></tr>
<tr class="separator:gacb2b3ebad5d3f97745d7d8d8e57d8345"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abe9258f141190a2dd9cd6a505391c420"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#abe9258f141190a2dd9cd6a505391c420">batched_loglike</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const double *d_y, int batch_size, int nobs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const double *d_params, double *loglike, double *d_vs, bool trans=true, bool host_loglike=true, int fc_steps=0, double *d_fc=nullptr)</td></tr>
<tr class="separator:abe9258f141190a2dd9cd6a505391c420"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad2dd01625283c09ff6fc613ddf3166f7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad2dd01625283c09ff6fc613ddf3166f7">batched_loglike</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const double *d_y, int batch_size, int nobs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *loglike, double *d_vs, bool trans=true, bool host_loglike=true, int fc_steps=0, double *d_fc=nullptr)</td></tr>
<tr class="separator:ad2dd01625283c09ff6fc613ddf3166f7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad7f408347d607273ea5b615a5097a32c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ad7f408347d607273ea5b615a5097a32c">predict</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const double *d_y, int batch_size, int nobs, int start, int end, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *d_vs, double *d_y_p)</td></tr>
<tr class="separator:ad7f408347d607273ea5b615a5097a32c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adbda523803274a0af10ca60a511ffbe8"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#adbda523803274a0af10ca60a511ffbe8">information_criterion</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const double *d_y, int batch_size, int nobs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, double *ic, int ic_type)</td></tr>
<tr class="separator:adbda523803274a0af10ca60a511ffbe8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaeb06dba6a8e515d43b454601beeab4a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aaeb06dba6a8e515d43b454601beeab4a">estimate_x0</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const double *d_y, int batch_size, int nobs, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order)</td></tr>
<tr class="separator:aaeb06dba6a8e515d43b454601beeab4a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9083be04bc457d748589a598eb6aaae2"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9083be04bc457d748589a598eb6aaae2">batched_kalman_filter</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const double *d_ys_b, int nobs, const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp;<a class="el" href="classML_1_1params.html">params</a>, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, double *loglike, double *d_vs, bool host_loglike=true, int fc_steps=0, double *d_fc=nullptr)</td></tr>
<tr class="separator:a9083be04bc457d748589a598eb6aaae2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a21530a429fac6b95cc4d0ea78a2c40d1"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a21530a429fac6b95cc4d0ea78a2c40d1">batched_jones_transform</a> (<a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp;handle, const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp;order, int batch_size, bool isInv, const double *h_params, double *h_Tparams)</td></tr>
<tr class="separator:a21530a429fac6b95cc4d0ea78a2c40d1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0f446810d4972e9bee95fca756cb958"><td align="right" class="memItemLeft" valign="top">auto </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#af0f446810d4972e9bee95fca756cb958">thrust_exec_policy</a> (std::shared_ptr&lt; <a class="el" href="classMLCommon_1_1deviceAllocator.html">deviceAllocator</a> &gt; allocator, cudaStream_t stream) -&gt; std::unique_ptr&lt; decltype(thrust::cuda::par(_decltypeHelper)), std::function&lt; void(decltype(thrust::cuda::par(_decltypeHelper)) *)&gt;&gt;</td></tr>
<tr class="memdesc:af0f446810d4972e9bee95fca756cb958"><td class="mdescLeft"> </td><td class="mdescRight">Returns a unique_ptr to a Thrust CUDA execution policy that uses the passed in allocator for temporary memory allocation.  <a href="namespaceML.html#af0f446810d4972e9bee95fca756cb958">More...</a><br/></td></tr>
<tr class="separator:af0f446810d4972e9bee95fca756cb958"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9d769926cc27c80a2daa3779c606c133"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9d769926cc27c80a2daa3779c606c133">convert_level_to_spdlog</a> (int level)</td></tr>
<tr class="separator:a9d769926cc27c80a2daa3779c606c133"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aacfa74158f3a2d08f6ddae02dbfb2992"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">PUSH_RANGE</a> (const char *name)</td></tr>
<tr class="memdesc:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="mdescLeft"> </td><td class="mdescRight">Push a named nvtx range.  <a href="namespaceML.html#aacfa74158f3a2d08f6ddae02dbfb2992">More...</a><br/></td></tr>
<tr class="separator:aacfa74158f3a2d08f6ddae02dbfb2992"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a516be7eeb210dc391738e9761a886533"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a516be7eeb210dc391738e9761a886533">POP_RANGE</a> ()</td></tr>
<tr class="separator:a516be7eeb210dc391738e9761a886533"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9597fa4e87eb201ef8bbe7e8b1c5dcab"><td align="right" class="memItemLeft" valign="top">bool </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9597fa4e87eb201ef8bbe7e8b1c5dcab">is_dev_ptr</a> (const void *p)</td></tr>
<tr class="separator:a9597fa4e87eb201ef8bbe7e8b1c5dcab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td align="right" class="memItemLeft" valign="top">int </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae9e9f22920ecd0dd7ab05981dd3a0cac">get_device</a> (const void *ptr)</td></tr>
<tr class="separator:ae9e9f22920ecd0dd7ab05981dd3a0cac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ea5c03024c5683984f17d889421f40c"><td align="right" class="memItemLeft" valign="top">cudaMemoryType </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2ea5c03024c5683984f17d889421f40c">memory_type</a> (const void *p)</td></tr>
<tr class="separator:a2ea5c03024c5683984f17d889421f40c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9259a8d354f6d0bf7d0b4f33be85ad3c"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a9259a8d354f6d0bf7d0b4f33be85ad3c">tsvdFitSPMG</a> (float *h_input, float *h_components, float *h_singular_vals, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:a9259a8d354f6d0bf7d0b4f33be85ad3c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a521794d6b91c2c15ed37321d0ac93b65"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a521794d6b91c2c15ed37321d0ac93b65">tsvdFitSPMG</a> (double *h_input, double *h_components, double *h_singular_vals, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:a521794d6b91c2c15ed37321d0ac93b65"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab8f1d940bc437de0556ab644b3257640"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ab8f1d940bc437de0556ab644b3257640">tsvdInverseTransformSPMG</a> (float *h_trans_input, float *h_components, bool trans_comp, float *input, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:ab8f1d940bc437de0556ab644b3257640"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ac8b6b177c8f99ec861d9905322a3f5"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2ac8b6b177c8f99ec861d9905322a3f5">tsvdInverseTransformSPMG</a> (double *h_trans_input, double *h_components, bool trans_comp, double *input, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:a2ac8b6b177c8f99ec861d9905322a3f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a67b68b55bf5bd708f36fefaace86535a"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a67b68b55bf5bd708f36fefaace86535a">tsvdTransformSPMG</a> (float *h_input, float *h_components, bool trans_comp, float *h_trans_input, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:a67b68b55bf5bd708f36fefaace86535a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a028e814482b7b03ba9378572424a9fa7"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a028e814482b7b03ba9378572424a9fa7">tsvdTransformSPMG</a> (double *h_input, double *h_components, bool trans_comp, double *h_trans_input, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:a028e814482b7b03ba9378572424a9fa7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d5240f241eab0ab8cf3d0ce93979016"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a2d5240f241eab0ab8cf3d0ce93979016">tsvdFitTransformSPMG</a> (float *h_input, float *h_trans_input, float *h_components, float *h_explained_var, float *h_explained_var_ratio, float *h_singular_vals, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:a2d5240f241eab0ab8cf3d0ce93979016"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae4543eab72008cf0583f88a5ff7b0090"><td align="right" class="memItemLeft" valign="top">void </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#ae4543eab72008cf0583f88a5ff7b0090">tsvdFitTransformSPMG</a> (double *h_input, double *h_trans_input, double *h_components, double *h_explained_var, double *h_explained_var_ratio, double *h_singular_vals, <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> prms, int *gpu_ids, int n_gpus)</td></tr>
<tr class="separator:ae4543eab72008cf0583f88a5ff7b0090"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a7181e4d6d170b0aa91dc7a368abf3d1c"><td align="right" class="memItemLeft" valign="top"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> </td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">handleMap</a></td></tr>
<tr class="memdesc:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="mdescLeft"> </td><td class="mdescRight">Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>)  <a href="namespaceML.html#a7181e4d6d170b0aa91dc7a368abf3d1c">More...</a><br/></td></tr>
<tr class="separator:a7181e4d6d170b0aa91dc7a368abf3d1c"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acbf0352d6a255f990fcdf949b898d6af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf0352d6a255f990fcdf949b898d6af">◆ </a></span>RandomForestClassifierD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, int&gt; <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">ML::RandomForestClassifierD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a36df48edc11fcd68dd8b6f4a76526e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36df48edc11fcd68dd8b6f4a76526e7b">◆ </a></span>RandomForestClassifierF</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, int&gt; <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">ML::RandomForestClassifierF</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a64f2117024176a6fab67a1a6b8925243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f2117024176a6fab67a1a6b8925243">◆ </a></span>RandomForestRegressorD</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;double, double&gt; <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">ML::RandomForestRegressorD</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a79048a796facf156e926834d97bec78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79048a796facf156e926834d97bec78f">◆ </a></span>RandomForestRegressorF</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">typedef <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt;float, float&gt; <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">ML::RandomForestRegressorF</a></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a823912afaa51f58a997564eadb6d9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823912afaa51f58a997564eadb6d9405">◆ </a></span>CRITERION</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">ML::CRITERION</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405af633f697107611ea3f0f2d18986be3e6"></a>GINI </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ab55a4e6aef097bd8f786f4ddfd1de161"></a>ENTROPY </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a746a9f45470e731c984d37744c48432e"></a>MSE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405a71d3454116e1aace7f91b15f56567b1e"></a>MAE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a823912afaa51f58a997564eadb6d9405ae346b778011ef4f488c1c87d64c1b174"></a>CRITERION_END </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a67da49ce109878bcdbb29a8777d28de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67da49ce109878bcdbb29a8777d28de1">◆ </a></span>loss_funct</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a67da49ce109878bcdbb29a8777d28de1">ML::loss_funct</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad3c28e4d0ab8ed2b4c69c0483c6ffea4"></a>SQRD_LOSS </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1a007e4d0f43a45d8d9be3dde194ea410a"></a>HINGE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a67da49ce109878bcdbb29a8777d28de1ad24128f8a7b16f59075a28323f13803d"></a>LOG </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a1adf3fea9cf9cde96ecf353b43818079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf3fea9cf9cde96ecf353b43818079">◆ </a></span>lr_type</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a1adf3fea9cf9cde96ecf353b43818079">ML::lr_type</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a5ccc94f0f9ce653134966e2377c71ca1"></a>OPTIMAL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079aabfea584e2f24b9920a5fb3058dd06bb"></a>CONSTANT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a98a91ed2cd2ff227d0393c406e09a106"></a>INVSCALING </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1adf3fea9cf9cde96ecf353b43818079a8108470840df674d6403e12c0d2ac63a"></a>ADAPTIVE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a4d9fd2e8fe0cfbbd81877eee212b88d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9fd2e8fe0cfbbd81877eee212b88d9">◆ </a></span>MetricType</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">ML::MetricType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a138628cbf0d89bc28f2dd159f426c13d"></a>METRIC_INNER_PRODUCT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a5e87bd6f2a6c86ad23937eedf66de99b"></a>METRIC_L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a6d9ec7c577a546e75c72ee872241ef4e"></a>METRIC_L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9aa01f9bc4910d9f004046489a11dc815e"></a>METRIC_Linf </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ab136e195c4dd9de8a55edaa0830ddf2f"></a>METRIC_Lp </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ae507c1b9eb779a39b742fa8e3e22cd0e"></a>METRIC_Canberra </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9a2124363d5cceb96ec8c9d87e0e9ece05"></a>METRIC_BrayCurtis </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ad4265672a802bf53d58db72de56ddd22"></a>METRIC_JensenShannon </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ae401fdab977404f1b08e85985f7b4bf8"></a>METRIC_Cosine </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d9fd2e8fe0cfbbd81877eee212b88d9ad4bc32758f26d167d264e7574429b024"></a>METRIC_Correlation </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a1529da2b94c67018bb14f404f6e9aeac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1529da2b94c67018bb14f404f6e9aeac">◆ </a></span>Norm</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a1529da2b94c67018bb14f404f6e9aeac">ML::Norm</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca6527e252610c64b85fdc9fc357c979cc"></a>L0 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca83820f75ef6d53c49873c4269fdcdc26"></a>LINF </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a85e691126b37f5e1dc834841cad1479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e691126b37f5e1dc834841cad1479c">◆ </a></span>OptimCriterion</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a85e691126b37f5e1dc834841cad1479c">ML::OptimCriterion</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca7a9fdcb8befd1162d7ba06c5bc34bd21"></a>OPTIM_BFGS_ITER_LIMIT </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca80e3d3c81590a148d565b7ddb78ef590"></a>OPTIM_MIN_PARAM_DIFF </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca01a4b4daad43785b0587346034b10ef5"></a>OPTIM_MIN_ERROR_DIFF </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a85e691126b37f5e1dc834841cad1479ca6c4ee736abd198cfc853b82b1e3a1fcc"></a>OPTIM_MIN_GRAD_NORM </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a899c5f26e201a81a2c12bb7eed9b015d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899c5f26e201a81a2c12bb7eed9b015d">◆ </a></span>penalty</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a899c5f26e201a81a2c12bb7eed9b015d">ML::penalty</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015daf8cf4476d6fa69254aa96e2a9b385b07"></a>NONE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca1fb22843d62f821b692757ad5541f072"></a>L1 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1529da2b94c67018bb14f404f6e9aeaca4b6f8af39a7cbeb4aa24ef995e5b6e0e"></a>L2 </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a899c5f26e201a81a2c12bb7eed9b015da80cad9123fc734ada9ef3a33ac30e627"></a>ELASTICNET </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a4d83b99fe769e2e9bf3596bb1604ab4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d83b99fe769e2e9bf3596bb1604ab4f">◆ </a></span>RF_type</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">ML::RF_type</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa9d8edfe721557c504d925e3bcace2edf"></a>CLASSIFICATION </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a4d83b99fe769e2e9bf3596bb1604ab4fa2864cd9bbe2aa57118c71b9c717c3586"></a>REGRESSION </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="a8d55de18185e36dd8f8a6d735e6a91e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d55de18185e36dd8f8a6d735e6a91e6">◆ </a></span>SeasonalType</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#a8d55de18185e36dd8f8a6d735e6a91e6">ML::SeasonalType</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6af28ffe4c75342f4012bcf16f798e0ec3"></a>ADDITIVE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8d55de18185e36dd8f8a6d735e6a91e6abc34c50dc7f29a357f52f9e5c0308226"></a>MULTIPLICATIVE </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="afe9899e0c7ff1cf722a35bcf35283953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9899e0c7ff1cf722a35bcf35283953">◆ </a></span>SPLIT_ALGO</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#afe9899e0c7ff1cf722a35bcf35283953">ML::SPLIT_ALGO</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a5ce779f6c1df4e4ec40cd9cee88837e2"></a>HIST </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a61e77c561b3834cdc46508db24d72f90"></a>GLOBAL_QUANTILE </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afe9899e0c7ff1cf722a35bcf35283953a5773eabe7d91f72e535b233ca73ba5c9"></a>SPLIT_ALGO_END </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<a id="af60801cb5c9adac3f6f5bd4bd43aa2f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af60801cb5c9adac3f6f5bd4bd43aa2f7">◆ </a></span>task_category</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespaceML.html#af60801cb5c9adac3f6f5bd4bd43aa2f7">ML::task_category</a></td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a88b80439ca4076839158d63d31271315"></a>REGRESSION_MODEL </td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af60801cb5c9adac3f6f5bd4bd43aa2f7a9c8a19e179622826abd959f7639c7006"></a>CLASSIFICATION_MODEL </td><td class="fielddoc"></td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a21530a429fac6b95cc4d0ea78a2c40d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21530a429fac6b95cc4d0ea78a2c40d1">◆ </a></span>batched_jones_transform()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_jones_transform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>isInv</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>h_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_Tparams</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convenience function for batched "jones transform" used in ARIMA to ensure certain properties of the AR and MA parameters (takes host array and returns host array)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series analyzed. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">isInv</td><td>Do the inverse transform? </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">h_params</td><td>ARIMA parameters by batch (mu, ar, ma) (host) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">h_Tparams</td><td>Transformed ARIMA parameters (expects pre-allocated array of size (p+q)*batch_size) (host) </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a9083be04bc457d748589a598eb6aaae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9083be04bc457d748589a598eb6aaae2">◆ </a></span>batched_kalman_filter()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_kalman_filter </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_ys_b</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>An ARIMA specialized batched kalman filter to evaluate ARMA parameters and provide the resulting prediction as well as loglikelihood fit.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_ys_b</td><td>Batched time series Shape (nobs, batch_size) (col-major, device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of series making up the batch </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Resulting loglikelihood (for each series) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>Residual between the prediction and the original series. shape=(nobs-d-s*D, batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad2dd01625283c09ff6fc613ddf3166f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2dd01625283c09ff6fc613ddf3166f7">◆ </a></span>batched_loglike() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="section note"><dt>Note</dt><dd>: this overload should be used when the parameters are already unpacked to avoid useless packing / unpacking</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (nobs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series (host) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>The residual between model and original signal. shape = (nobs-d-s*D, batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="abe9258f141190a2dd9cd6a505391c420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9258f141190a2dd9cd6a505391c420">◆ </a></span>batched_loglike() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::batched_loglike </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>loglike</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>host_loglike</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>fc_steps</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_fc</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the loglikelihood of the given parameter on the given time series in a batched context.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (nobs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Number of time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of observations in a time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_params</td><td>Parameters to evaluate grouped by series: [mu0, ar.., ma.., mu1, ..] (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">loglike</td><td>Log-Likelihood of the model per series (host) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>The residual between model and original signal. shape = (nobs-d-s*D, batch_size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">trans</td><td>Run <code>jones_transform</code> on params. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">host_loglike</td><td>Whether loglike is a host pointer </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">fc_steps</td><td>Number of steps to forecast </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_fc</td><td>Array to store the forecast </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a398a682ed8fe6c94b92c16ea8d976dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398a682ed8fe6c94b92c16ea8d976dbd">◆ </a></span>brute_force_knn()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::brute_force_knn </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>sizes</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>search_items</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>res_I</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>res_D</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorIndex</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>rowMajorQuery</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a4d9fd2e8fe0cfbbd81877eee212b88d9">MetricType</a> </td>
<td class="paramname"><em>metric</em> = <code>MetricType::METRIC_L2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>metric_arg</em> = <code>2.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>expanded</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a brute force knn on a series of input arrays and combine the results into a single output array for indexes and distances. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramname">input</td><td>vector of pointers to the input arrays </td></tr>
<tr><td class="paramname">sizes</td><td>vector of sizes of input arrays </td></tr>
<tr><td class="paramname">D</td><td>the dimensionality of the arrays </td></tr>
<tr><td class="paramname">search_items</td><td>array of items to search of dimensionality D </td></tr>
<tr><td class="paramname">n</td><td>number of rows in search_items </td></tr>
<tr><td class="paramname">res_I</td><td>the resulting index array of size n * k </td></tr>
<tr><td class="paramname">res_D</td><td>the resulting distance array of size n * k </td></tr>
<tr><td class="paramname">k</td><td>the number of nearest neighbors to return </td></tr>
<tr><td class="paramname">rowMajorIndex</td><td>are the index arrays in row-major order? </td></tr>
<tr><td class="paramname">rowMajorQuery</td><td>are the query arrays in row-major order? </td></tr>
<tr><td class="paramname">metric</td><td>distance metric to use. Euclidean (L2) is used by default </td></tr>
<tr><td class="paramname">metric_arg</td><td>the value of <code>p</code> for Minkowski (l-p) distances. This is ignored if the metric_type is not Minkowski. </td></tr>
<tr><td class="paramname">expanded</td><td>should lp-based distances be returned in their expanded form (e.g., without raising to the 1/p power). </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a684813418506a4839a61692008e4cfb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684813418506a4839a61692008e4cfb9">◆ </a></span>build_treelite_forest()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::build_treelite_forest </td>
<td>(</td>
<td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> * </td>
<td class="paramname"><em>model</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>num_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>task_category</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af142813513ee46988a79fd3dc4ab52a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af142813513ee46988a79fd3dc4ab52a6">◆ </a></span>compare_concat_forest_to_subforests()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::compare_concat_forest_to_subforests </td>
<td>(</td>
<td class="paramtype"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> </td>
<td class="paramname"><em>concat_tree_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; </td>
<td class="paramname"><em>treelite_handles</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab85e3eaa2c4e4de0a0a6aa9b6d68e5ee">◆ </a></span>concatenate_trees()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> ML::concatenate_trees </td>
<td>(</td>
<td class="paramtype">std::vector&lt; <a class="el" href="treelite__defs_8hpp.html#af55d689ab3378ed1dd2e821b3650672a">ModelHandle</a> &gt; </td>
<td class="paramname"><em>treelite_handles</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9d769926cc27c80a2daa3779c606c133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d769926cc27c80a2daa3779c606c133">◆ </a></span>convert_level_to_spdlog()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int ML::convert_level_to_spdlog </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>level</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a47bd45d133f5b3bb3748a6e5d1c61c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bd45d133f5b3bb3748a6e5d1c61c91">◆ </a></span>delete_rf_metadata()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::delete_rf_metadata </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aaeb06dba6a8e515d43b454601beeab4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb06dba6a8e515d43b454601beeab4a">◆ </a></span>estimate_x0()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::estimate_x0 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Provide initial estimates to ARIMA parameters mu, AR, and MA</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (nobs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="afb04181b9f5bbcbf551b761927a0f24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb04181b9f5bbcbf551b761927a0f24d">◆ </a></span>find_ab()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::find_ab </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> * </td>
<td class="paramname"><em>params</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad764fd7aacaefdae4073c077e4ad636a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad764fd7aacaefdae4073c077e4ad636a">◆ </a></span>fit() <span class="overload">[1/6]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>d</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>knn_dists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> * </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>embeddings</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a96e08b2209718522d472238b3792cfb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e08b2209718522d472238b3792cfb8">◆ </a></span>fit() <span class="overload">[2/6]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>d</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>knn_dists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> * </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>embeddings</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af46cf0ee6ea9c998146d3102ccd01868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46cf0ee6ea9c998146d3102ccd01868">◆ </a></span>fit() <span class="overload">[3/6]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_unique_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a3178043c2fb0711c827614649cd6028f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3178043c2fb0711c827614649cd6028f">◆ </a></span>fit() <span class="overload">[4/6]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_unique_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa31ee6fbdebd3e6d899e8de88b304473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31ee6fbdebd3e6d899e8de88b304473">◆ </a></span>fit() <span class="overload">[5/6]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad45e1013123ee57f6547a791b7cb40c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45e1013123ee57f6547a791b7cb40c6">◆ </a></span>fit() <span class="overload">[6/6]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> *&amp; </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae9e9f22920ecd0dd7ab05981dd3a0cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e9f22920ecd0dd7ab05981dd3a0cac">◆ </a></span>get_device()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">int ML::get_device </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>ptr</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa600091e11674391cf9ccedee8904612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa600091e11674391cf9ccedee8904612">◆ </a></span>get_unique_id()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::get_unique_id </td>
<td>(</td>
<td class="paramtype">char * </td>
<td class="paramname"><em>uid</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a NCCL unique ID as a character array. PyTorch uses this same approach, so that it can be more easily converted to a native Python string by Cython and further serialized to be sent across process &amp; node boundaries. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">uid</td><td>nccl unique id for establishing a new clique. </td></tr>
<tr><td class="paramname">size</td><td>uid size </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="adbda523803274a0af10ca60a511ffbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbda523803274a0af10ca60a511ffbe8">◆ </a></span>information_criterion()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::information_criterion </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>ic</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>ic_type</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute an information criterion (AIC, AICc, BIC)</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Series to fit: shape = (nobs, batch_size) and expects column major data layout. (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ic</td><td>Array where to write the information criteria Shape: (batch_size) (host) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ic_type</td><td>Type of information criterion wanted. 0: AIC, 1: AICc, 2: BIC </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af1a8aaa312a62f236a4238b4abdbbd49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1a8aaa312a62f236a4238b4abdbbd49">◆ </a></span>initialize_mpi_comms()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::initialize_mpi_comms </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">MPI_Comm </td>
<td class="paramname"><em>comm</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a3b5faa4ceb0e330450d1b210b3bd86c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5faa4ceb0e330450d1b210b3bd86c4">◆ </a></span>inject_comms()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::inject_comms </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ncclComm_t </td>
<td class="paramname"><em>comm</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>rank</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Given an initialized comms handle for NCCL, this function builds a cumlCommunicator object and injects it into the given <a class="el" href="classML_1_1cumlHandle.html" title="Handle to manage resources needed by cuML algorithms.">cumlHandle</a> instance. The underlying cumlCommunicator will only have support for collective communications functions. </p>
<p>Underlying comms, like NCCL and UCX, should be initialized and ready for use, and maintained, outside of the cuML <a class="el" href="namespaceML_1_1Comms.html">Comms</a> lifecycle. This allows us to decouple the ownership of the actual comms from cuml so that they can also be used outside of cuml.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to inject a new communicator instance into </td></tr>
<tr><td class="paramname">comm</td><td>initialized nccl communicator </td></tr>
<tr><td class="paramname">size</td><td>the size of the cluster </td></tr>
<tr><td class="paramname">rank</td><td>rank of the current worker</td></tr>
</table>
</dd>
</dl>
<p>For instance, nccl-py can be used to bootstrap a ncclComm_t before it is used to construct a cuml comms instance. UCX endpoints can be bootstrapped in Python using ucx-py, before being used to construct a cuML comms instance. </p>
</div>
</div>
<a id="a6df300b3bb64878210f979639702e618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df300b3bb64878210f979639702e618">◆ </a></span>inject_comms_py()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::inject_comms_py </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">ML::cumlHandle</a> * </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ncclComm_t </td>
<td class="paramname"><em>comm</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>ucp_worker</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">void * </td>
<td class="paramname"><em>eps</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>rank</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function wraps the inject comms functions in <a class="el" href="std_2include_2cuML__comms_8hpp.html">cpp/comms/std/include/cuML_comms.hpp</a> to decouple the Python layer from the optional UCX dependency in the C++ build. This allows the Cython to compile without having to propagate the <code>WITH_UCX</code> directive to that layer. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to inject a new communicator instance into </td></tr>
<tr><td class="paramname">comm</td><td>initialized nccl communicator </td></tr>
<tr><td class="paramname">ucp_worker</td><td>ucp_worker_h instance for the current initialized ucp context </td></tr>
<tr><td class="paramname">eps</td><td>an array of ucp_ep_h endpoints to the other ucp workers in the cluster </td></tr>
<tr><td class="paramname">size</td><td>the size of the cluster (number of elements in eps) </td></tr>
<tr><td class="paramname">rank</td><td>rank of the current worker </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a7c91b8b040db35e8c514caf92ef9faa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c91b8b040db35e8c514caf92ef9faa9">◆ </a></span>inject_comms_py_coll()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::inject_comms_py_coll </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> * </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ncclComm_t </td>
<td class="paramname"><em>comm</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>rank</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function follows the design of the wrapper function in <a class="el" href="std_2include_2cuML__comms_8hpp.html">cpp/comms/std/include/cuML_comms.hpp</a> to decouple the Python layer injection functions from the C++ layer functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to inject a new communicator instance into </td></tr>
<tr><td class="paramname">comm</td><td>initialized nccl communicator </td></tr>
<tr><td class="paramname">size</td><td>the size of the cluster (number of elements in eps) </td></tr>
<tr><td class="paramname">rank</td><td>rank of the current worker </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a9597fa4e87eb201ef8bbe7e8b1c5dcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9597fa4e87eb201ef8bbe7e8b1c5dcab">◆ </a></span>is_dev_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool ML::is_dev_ptr </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a85e06ffab0789d683296b9ab05b25ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e06ffab0789d683296b9ab05b25ea6">◆ </a></span>knn_class_proba()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_class_proba </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_samples</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to compute knn class probabilities using a vector of device arrays containing discrete class labels. Note that the output is a vector, which is. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramname">out</td><td>vector of output arrays on device. vector size = n_outputs. Each array should have size(n_samples, n_classes) </td></tr>
<tr><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
<tr><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
<tr><td class="paramname">n_labels</td><td>number of labels </td></tr>
<tr><td class="paramname">n_samples</td><td>number of samples in knn_indices and out </td></tr>
<tr><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a533599d0a845ce150a5292830d3e9044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533599d0a845ce150a5292830d3e9044">◆ </a></span>knn_classify()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_classify </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_samples</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a knn classification using a given a vector of label arrays. This supports multilabel classification by classifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramname">out</td><td>output array on device (size n_samples * size of y vector) </td></tr>
<tr><td class="paramname">knn_indices</td><td>index array on device resulting from knn query (size n_samples * k) </td></tr>
<tr><td class="paramname">y</td><td>vector of label arrays on device vector size is number of (size n_samples) </td></tr>
<tr><td class="paramname">n_labels</td><td>number of vertices in index (eg. size of each y array) </td></tr>
<tr><td class="paramname">n_samples</td><td>number of samples in knn_indices </td></tr>
<tr><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aa135fed945f1fadf8fe6b96de1652a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa135fed945f1fadf8fe6b96de1652a1c">◆ </a></span>knn_regress()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::knn_regress </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>out</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; float * &gt; &amp; </td>
<td class="paramname"><em>y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>n_samples</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Flat C++ API function to perform a knn regression using a given a vector of label arrays. This supports multilabel regression by clasifying on multiple label arrays. Note that each label is classified independently, as is done in scikit-learn. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">handle</td><td>the cuml handle to use </td></tr>
<tr><td class="paramname">out</td><td>output array on device (size n_samples) </td></tr>
<tr><td class="paramname">knn_indices</td><td>array on device of knn indices (size n_samples * k) </td></tr>
<tr><td class="paramname">y</td><td>array of labels on device (size n_samples) </td></tr>
<tr><td class="paramname">n_labels</td><td>number of vertices in index (eg. size of each y array) </td></tr>
<tr><td class="paramname">n_samples</td><td>number of samples in knn_indices and out </td></tr>
<tr><td class="paramname">k</td><td>number of nearest neighbors in knn_indices </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2ea5c03024c5683984f17d889421f40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea5c03024c5683984f17d889421f40c">◆ </a></span>memory_type()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">cudaMemoryType ML::memory_type </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>p</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a4cd9a45777c1905c63cad95ae03fa275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cd9a45777c1905c63cad95ae03fa275">◆ </a></span>ncclUniqueIdFromChar()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::ncclUniqueIdFromChar </td>
<td>(</td>
<td class="paramtype">ncclUniqueId * </td>
<td class="paramname"><em>id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">char * </td>
<td class="paramname"><em>uniqueId</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Stores the given character array on the given ncclUniqueId struct. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">id</td><td>the ncclUniqueId struct instance to store the given character array </td></tr>
<tr><td class="paramname">uniqueId</td><td>the unique id char array to store on the ncclUniqueId </td></tr>
<tr><td class="paramname">size</td><td>id size </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab1275db1b0385b97fbb481b719322a25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1275db1b0385b97fbb481b719322a25">◆ </a></span>null_trees_ptr()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::null_trees_ptr </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; *&amp; </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a08408e733e361d2f369648b8e27d2ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08408e733e361d2f369648b8e27d2ffb">◆ </a></span>pcaFit() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFit </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a650eaab0fc4163345a1b1b8079d87e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650eaab0fc4163345a1b1b8079d87e1d">◆ </a></span>pcaFit() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFit </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a073f1d1acd1f22f726a4ab8801a9cd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a073f1d1acd1f22f726a4ab8801a9cd6d">◆ </a></span>pcaFitTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFitTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa42a9bd0873815ffa067f6c68366e425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42a9bd0873815ffa067f6c68366e425">◆ </a></span>pcaFitTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaFitTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>noise_vars</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5321540ed0a062057c8617ca56382d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5321540ed0a062057c8617ca56382d35">◆ </a></span>pcaInverseTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaInverseTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a72bff3ce27b8d1e10d96ba47ebbe52de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bff3ce27b8d1e10d96ba47ebbe52de">◆ </a></span>pcaInverseTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaInverseTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a3b77d53971e6f922973514d1e169a15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b77d53971e6f922973514d1e169a15b">◆ </a></span>pcaTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a91afa12c5a354f240d50cf7051f58561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91afa12c5a354f240d50cf7051f58561">◆ </a></span>pcaTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::pcaTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>mu</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#ga239d146c5a5545dd84e3d0b6e305f631">paramsPCA</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a516be7eeb210dc391738e9761a886533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516be7eeb210dc391738e9761a886533">◆ </a></span>POP_RANGE()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::POP_RANGE </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Pop the latest range </p>
</div>
</div>
<a id="a05ee22c0f2c66e9bb7d60c72e5d61b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ee22c0f2c66e9bb7d60c72e5d61b32">◆ </a></span>postprocess_labels()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::postprocess_labels </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::map&lt; int, int &gt; &amp; </td>
<td class="paramname"><em>labels_map</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="afd9088f0eb72425f5a189bda4ba9190d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9088f0eb72425f5a189bda4ba9190d">◆ </a></span>predict() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac091c51e7c651e9e75a7d16ef2c0b833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac091c51e7c651e9e75a7d16ef2c0b833">◆ </a></span>predict() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af597ab3d0b866d746894d1f01fec48b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af597ab3d0b866d746894d1f01fec48b1">◆ </a></span>predict() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2aeb706e9c6ad4d09649040cde64de04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeb706e9c6ad4d09649040cde64de04">◆ </a></span>predict() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad7f408347d607273ea5b615a5097a32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f408347d607273ea5b615a5097a32c">◆ </a></span>predict() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predict </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>d_y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>batch_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>nobs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>start</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>end</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAOrder.html">ARIMAOrder</a> &amp; </td>
<td class="paramname"><em>order</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="structML_1_1ARIMAParams.html">ARIMAParams</a>&lt; double &gt; &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_vs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>d_y_p</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Batched in-sample and out-of-sample prediction of a time-series given all the model parameters</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>cuML handle </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">d_y</td><td>Batched Time series to predict. Shape: (num_samples, batch size) (device) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">batch_size</td><td>Total number of batched time series </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">nobs</td><td>Number of samples per time series (all series must be identical) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start</td><td>Index to start the prediction </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">end</td><td>Index to end the prediction (excluded) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">order</td><td>ARIMA hyper-parameters </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">params</td><td>ARIMA parameters (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_vs</td><td>Residual output (device) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">d_y_p</td><td>Prediction output (device) </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab21de19a1297048acf9e29ee67832147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21de19a1297048acf9e29ee67832147">◆ </a></span>predictGetAll() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predictGetAll </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a238f7921f115171581bdc6d4bd2b373c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238f7921f115171581bdc6d4bd2b373c">◆ </a></span>predictGetAll() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::predictGetAll </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_cols</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa25bebb87dff8c328b2d4809f640f789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25bebb87dff8c328b2d4809f640f789">◆ </a></span>preprocess_labels()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::preprocess_labels </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::vector&lt; int &gt; &amp; </td>
<td class="paramname"><em>labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">std::map&lt; int, int &gt; &amp; </td>
<td class="paramname"><em>labels_map</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a390319c6e316ef242d477e8fa326f2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390319c6e316ef242d477e8fa326f2d0">◆ </a></span>print() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::print </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> </td>
<td class="paramname"><em>rf_metrics</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aa3ded9ffe5af3b52a2b8a301a362af10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ded9ffe5af3b52a2b8a301a362af10">◆ </a></span>print() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::print </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a983711adcb719ce812e5f5d3641f108e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983711adcb719ce812e5f5d3641f108e">◆ </a></span>print_rf_detailed()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::print_rf_detailed </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a40395e030bda0e7170453320450b5f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40395e030bda0e7170453320450b5f8a">◆ </a></span>print_rf_summary()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class L &gt; </div>
<table class="memname">
<tr>
<td class="memname">void ML::print_rf_summary </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RandomForestMetaData.html">RandomForestMetaData</a>&lt; T, L &gt; * </td>
<td class="paramname"><em>forest</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aacfa74158f3a2d08f6ddae02dbfb2992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfa74158f3a2d08f6ddae02dbfb2992">◆ </a></span>PUSH_RANGE()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::PUSH_RANGE </td>
<td>(</td>
<td class="paramtype">const char * </td>
<td class="paramname"><em>name</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Push a named nvtx range. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">name</td><td>range name </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a713c689e1979ec0282f6f1986b20e1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713c689e1979ec0282f6f1986b20e1ae">◆ </a></span>score() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#acbf0352d6a255f990fcdf949b898d6af">RandomForestClassifierD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af494468925b451bbb729222f794e2f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af494468925b451bbb729222f794e2f37">◆ </a></span>score() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a36df48edc11fcd68dd8b6f4a76526e7b">RandomForestClassifierF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a431e76b38ada50ecb92dc346dd37814c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431e76b38ada50ecb92dc346dd37814c">◆ </a></span>score() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a64f2117024176a6fab67a1a6b8925243">RandomForestRegressorD</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const double * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="acb0c99770c5d304c065f2e4250f623ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0c99770c5d304c065f2e4250f623ff">◆ </a></span>score() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::score </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>user_handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="namespaceML.html#a79048a796facf156e926834d97bec78f">RandomForestRegressorF</a> * </td>
<td class="paramname"><em>forest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>ref_labels</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_rows</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>predictions</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a5c7fcf2379a3d18e1c08840ff530eda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7fcf2379a3d18e1c08840ff530eda9">◆ </a></span>set_all_rf_metrics()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_all_rf_metrics </td>
<td>(</td>
<td class="paramtype"><a class="el" href="namespaceML.html#a4d83b99fe769e2e9bf3596bb1604ab4f">RF_type</a> </td>
<td class="paramname"><em>rf_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>accuracy</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_abs_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_squared_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>median_abs_error</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a510e44e64dee8d7fb35b527ece1ceada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510e44e64dee8d7fb35b527ece1ceada">◆ </a></span>set_all_rf_params()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::set_all_rf_params </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_trees</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cfg_bootstrap</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>cfg_rows_sample</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_seed</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="structML_1_1DecisionTree_1_1DecisionTreeParams.html">DecisionTree::DecisionTreeParams</a> </td>
<td class="paramname"><em>cfg_tree_params</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2c0fe802b28704b3cfc87185a9ff028b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0fe802b28704b3cfc87185a9ff028b">◆ </a></span>set_rf_class_obj()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__params.html">RF_params</a> ML::set_rf_class_obj </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_depth</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_leaves</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>max_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_bins</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>split_algo</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>min_rows_per_node</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>min_impurity_decrease</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bootstrap_features</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>bootstrap</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_trees</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>rows_sample</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>seed</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespaceML.html#a823912afaa51f58a997564eadb6d9405">CRITERION</a> </td>
<td class="paramname"><em>split_criterion</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>quantile_per_tree</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a85f241652a9dfc89e280200e7618ed32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f241652a9dfc89e280200e7618ed32">◆ </a></span>set_rf_metrics_classification()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_classification </td>
<td>(</td>
<td class="paramtype">float </td>
<td class="paramname"><em>accuracy</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aaa0b5eb27fbd28c93285b9ada72930d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0b5eb27fbd28c93285b9ada72930d8">◆ </a></span>set_rf_metrics_regression()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="structML_1_1RF__metrics.html">RF_metrics</a> ML::set_rf_metrics_regression </td>
<td>(</td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_abs_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>mean_squared_error</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>median_abs_error</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a45c9a84e0b86ac2c4838a3eaab325dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9a84e0b86ac2c4838a3eaab325dfc">◆ </a></span>set_rf_params()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::set_rf_params </td>
<td>(</td>
<td class="paramtype"><a class="el" href="structML_1_1RF__params.html">RF_params</a> &amp; </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_trees</em> = <code>1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>cfg_bootstrap</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>cfg_rows_sample</em> = <code>1.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_seed</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>cfg_n_streams</em> = <code>8</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af0f446810d4972e9bee95fca756cb958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f446810d4972e9bee95fca756cb958">◆ </a></span>thrust_exec_policy()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">auto ML::thrust_exec_policy </td>
<td>(</td>
<td class="paramtype">std::shared_ptr&lt; <a class="el" href="classMLCommon_1_1deviceAllocator.html">deviceAllocator</a> &gt; </td>
<td class="paramname"><em>allocator</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">cudaStream_t </td>
<td class="paramname"><em>stream</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td> -&gt; std::unique_ptr&lt;
    decltype(thrust::cuda::par(_decltypeHelper)),
    std::function&lt;void(decltype(thrust::cuda::par(_decltypeHelper))*)&gt;&gt; </td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns a unique_ptr to a Thrust CUDA execution policy that uses the passed in allocator for temporary memory allocation. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">allocator</td><td>The allocator to use </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td>The stream that the allocator will use</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Thrust execution policy that will use allocator for temporary memory allocation. </dd></dl>
</div>
</div>
<a id="a8fa60115383a17ed87ca372c1fcddbdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa60115383a17ed87ca372c1fcddbdb">◆ </a></span>transform()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::transform </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>d</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t * </td>
<td class="paramname"><em>knn_indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>knn_dists</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>orig_X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>orig_n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>embedding</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>embedding_n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classML_1_1UMAPParams.html">UMAPParams</a> * </td>
<td class="paramname"><em>params</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>transformed</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a4e2908f6a67d8590d7b55d1bb28d8601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2908f6a67d8590d7b55d1bb28d8601">◆ </a></span>TSNE_fit()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::TSNE_fit </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float * </td>
<td class="paramname"><em>X</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>Y</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>n</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>p</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>dim</em> = <code>2</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_neighbors</em> = <code>1023</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>theta</em> = <code>0.5f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>epssq</em> = <code>0.0025</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float </td>
<td class="paramname"><em>perplexity</em> = <code>50.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>perplexity_max_iter</em> = <code>100</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>perplexity_tol</em> = <code>1e-5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>early_exaggeration</em> = <code>12.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>exaggeration_iter</em> = <code>250</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_gain</em> = <code>0.01f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_learning_rate</em> = <code>200.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_learning_rate</em> = <code>500.0f</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>max_iter</em> = <code>1000</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>min_grad_norm</em> = <code>1e-7</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>pre_momentum</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>post_momentum</em> = <code>0.8</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const long long </td>
<td class="paramname"><em>random_state</em> = <code>-1</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>verbosity</em> = <code><a class="el" href="group__CumlLogLevels.html#ga3079191acbd7edfd13f3ae347e8a608f">CUML_LEVEL_INFO</a></code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const bool </td>
<td class="paramname"><em>intialize_embeddings</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>barnes_hut</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Dimensionality reduction via TSNE using either Barnes Hut O(NlogN) or brute force O(N^2). </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>The GPU handle. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">X</td><td>The dataset you want to apply TSNE on. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">Y</td><td>The final embedding. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>Number of rows in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>Number of columns in data X. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dim</td><td>Number of output dimensions for embeddings Y. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">n_neighbors</td><td>Number of nearest neighbors used. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">theta</td><td>Float between 0 and 1. Tradeoff for speed (0) vs accuracy (1) for Barnes Hut only. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">epssq</td><td>A tiny jitter to promote numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity</td><td>How many nearest neighbors are used during construction of Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_max_iter</td><td>Number of iterations used to construct Pij. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">perplexity_tol</td><td>The small tolerance used for Pij to ensure numerical stability. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">early_exaggeration</td><td>How much early pressure you want the clusters in TSNE to spread out more. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">exaggeration_iter</td><td>How many iterations you want the early pressure to run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_gain</td><td>Rounds up small gradient updates. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_learning_rate</td><td>The learning rate during exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_learning_rate</td><td>The learning rate after exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations TSNE should run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_grad_norm</td><td>The smallest gradient norm TSNE should terminate on. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pre_momentum</td><td>The momentum used during the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">post_momentum</td><td>The momentum used after the exaggeration phase. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">random_state</td><td>Set this to -1 for pure random intializations or &gt;= 0 for reproducible outputs. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>verbosity level for logging messages during execution </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">intialize_embeddings</td><td>Whether to overwrite the current Y vector with random noise. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut</td><td>Whether to use the fast Barnes Hut or use the slower exact version.</td></tr>
</table>
</dd>
</dl>
<p>The CUDA implementation is derived from the excellent CannyLabs open source implementation here: <a href="https://github.com/CannyLab/tsne-cuda/">https://github.com/CannyLab/tsne-cuda/</a>. The CannyLabs code is licensed according to the conditions in cuml/cpp/src/tsne/cannylabs_tsne_license.txt. A full description of their approach is available in their article t-SNE-CUDA: GPU-Accelerated t-SNE and its Applications to Modern Data (<a href="https://arxiv.org/abs/1807.11824">https://arxiv.org/abs/1807.11824</a>). </p>
</div>
</div>
<a id="a330b04019c207fde869a3572d36335dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330b04019c207fde869a3572d36335dd">◆ </a></span>tsvdFit() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFit </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="abf3d16c9eb89125f257082b713e6a7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf3d16c9eb89125f257082b713e6a7f6">◆ </a></span>tsvdFit() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFit </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a521794d6b91c2c15ed37321d0ac93b65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a521794d6b91c2c15ed37321d0ac93b65">◆ </a></span>tsvdFitSPMG() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitSPMG </td>
<td>(</td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a9259a8d354f6d0bf7d0b4f33be85ad3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9259a8d354f6d0bf7d0b4f33be85ad3c">◆ </a></span>tsvdFitSPMG() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitSPMG </td>
<td>(</td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ac078362b68c7ac43eab61249012ce16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac078362b68c7ac43eab61249012ce16f">◆ </a></span>tsvdFitTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a4bcc22831a2f38b9b7c142d6238a447c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcc22831a2f38b9b7c142d6238a447c">◆ </a></span>tsvdFitTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ae4543eab72008cf0583f88a5ff7b0090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4543eab72008cf0583f88a5ff7b0090">◆ </a></span>tsvdFitTransformSPMG() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransformSPMG </td>
<td>(</td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2d5240f241eab0ab8cf3d0ce93979016"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5240f241eab0ab8cf3d0ce93979016">◆ </a></span>tsvdFitTransformSPMG() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdFitTransformSPMG </td>
<td>(</td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_explained_var</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_explained_var_ratio</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_singular_vals</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a11c6b91cabee4748ce043bec4736c11c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11c6b91cabee4748ce043bec4736c11c">◆ </a></span>tsvdInverseTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a09770de4a23e8765b6c419dd4e8a09ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09770de4a23e8765b6c419dd4e8a09ca">◆ </a></span>tsvdInverseTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a2ac8b6b177c8f99ec861d9905322a3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac8b6b177c8f99ec861d9905322a3f5">◆ </a></span>tsvdInverseTransformSPMG() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransformSPMG </td>
<td>(</td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans_comp</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ab8f1d940bc437de0556ab644b3257640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f1d940bc437de0556ab644b3257640">◆ </a></span>tsvdInverseTransformSPMG() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdInverseTransformSPMG </td>
<td>(</td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans_comp</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="aba4a75968fc9bf15a80a5208542c28f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba4a75968fc9bf15a80a5208542c28f4">◆ </a></span>tsvdTransform() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a7c823835f3b168baf3d0ec6878de4114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c823835f3b168baf3d0ec6878de4114">◆ </a></span>tsvdTransform() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransform </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classML_1_1cumlHandle.html">cumlHandle</a> &amp; </td>
<td class="paramname"><em>handle</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> &amp; </td>
<td class="paramname"><em>prms</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a028e814482b7b03ba9378572424a9fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028e814482b7b03ba9378572424a9fa7">◆ </a></span>tsvdTransformSPMG() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransformSPMG </td>
<td>(</td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans_comp</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>h_trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a67b68b55bf5bd708f36fefaace86535a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b68b55bf5bd708f36fefaace86535a">◆ </a></span>tsvdTransformSPMG() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::tsvdTransformSPMG </td>
<td>(</td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_components</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>trans_comp</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>h_trans_input</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="group__pcaSolver.html#gab2bffedf6f8d520e216a6542ebf6a0f1">paramsTSVD</a> </td>
<td class="paramname"><em>prms</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>gpu_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>n_gpus</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a8d9a73d4716feafd591de704ce998cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d9a73d4716feafd591de704ce998cb9">◆ </a></span>ucx_enabled()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">bool ML::ucx_enabled </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a69f0169515a838c25ba3080b48ae2ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f0169515a838c25ba3080b48ae2ceb">◆ </a></span>validity_check()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void ML::validity_check </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="structML_1_1RF__params.html">RF_params</a> </td>
<td class="paramname"><em>rf_params</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a7181e4d6d170b0aa91dc7a368abf3d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7181e4d6d170b0aa91dc7a368abf3d1c">◆ </a></span>handleMap</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="classML_1_1HandleMap.html">HandleMap</a> ML::handleMap</td>
</tr>
</table>
</div><div class="memdoc">
<p>Static handle map instance (see <a class="el" href="cumlHandle_8cpp.html">cumlHandle.cpp</a>) </p>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.18
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
