<!DOCTYPE html>
<html class="writer-html5" lang="en"><head>
  <meta charset="utf-8">
  <meta content="Docutils 0.17.1: http://docutils.sourceforge.net/" name="generator">

  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  
  <title>cuGraph API Reference &mdash; cugraph 0.20.0 documentation</title>
  

  
  <link href="_static/css/theme.css" rel="stylesheet" type="text/css">
  <link href="_static/pygments.css" rel="stylesheet" type="text/css">
  <link href="_static/pygments.css" rel="stylesheet" type="text/css">
  <link href="_static/css/theme.css" rel="stylesheet" type="text/css">
  <link href="_static/copybutton.css" rel="stylesheet" type="text/css">
  <link href="_static/params.css" rel="stylesheet" type="text/css">
  <link href="_static/references.css" rel="stylesheet" type="text/css">

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script src="_static/js/theme.js" type="text/javascript"></script>

    
    <link href="genindex.html" rel="index" title="Index">
    <link href="search.html" rel="search" title="Search">
    <link href="dask-cugraph.html" rel="next" title="Multi-GPU with cuGraph">
    <link href="cugraph_intro.html" rel="prev" title="cuGraph Introduction"> 
<link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"></head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav class="wy-nav-side" data-toggle="wy-nav-shift">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"><div id="rapids-jtd-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cugraph</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cucim/stable/api.html">cucim</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/dask-cuda/stable/api.html">dask-cuda</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/librmm/stable/annotated.html">librmm</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/api.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (21.08)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cugraph/nightly/api.html">nightly (21.08)</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">stable (21.06)</a><a class="rapids-selector__menu-item" href="/api/cugraph/legacy/api.html">legacy (0.19)</a></div></div></div>
          

          
            

          
            
            
              
            
          

          
<div role="search">
  <form action="search.html" class="wy-form" id="rtd-search-form" method="get">
    <input name="q" placeholder="Search docs" type="text">
    <input name="check_keywords" type="hidden" value="yes">
    <input name="area" type="hidden" value="default">
  </form>
</div>

          
        </div>

        
        <div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="cugraph_intro.html">cuGraph Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="cugraph_intro.html#vision">Vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="cugraph_intro.html#terminology">Terminology</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">cuGraph API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#structure">Structure</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#graph">Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.symmetrize">Symmetrize</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.structure.convert_matrix">Conversion from Other Formats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#centrality">Centrality</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.centrality.betweenness_centrality">Betweenness Centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.centrality.katz_centrality">Katz Centrality</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.dask.centrality.katz_centrality">Katz Centrality (MG)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#community">Community</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.egonet">EgoNet</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.ecg">Ensemble clustering for graphs (ECG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.ktruss_subgraph">K-Truss</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.leiden">Leiden</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.louvain">Louvain</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.dask.community.louvain">Louvain (MG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.spectral_clustering">Spectral Clustering</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.subgraph_extraction">Subgraph Extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.community.triangle_count">Triangle Counting</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#components">Components</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.components.connectivity">Connected Components</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#cores">Cores</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.cores.core_number">Core Number</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.cores.k_core">K-Core</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#layout">Layout</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.layout.force_atlas2">Force Atlas 2</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#linear-assignment">Linear Assignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.linear_assignment.hungarian">Hungarian</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#parameters">Parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#returns">Returns</a></li>
<li class="toctree-l4"><a class="reference internal" href="#examples">Examples</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-analysis">Link Analysis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_analysis.hits">HITS</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_analysis.pagerank">Pagerank</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.dask.link_analysis.pagerank">Pagerank (MG)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#link-prediction">Link Prediction</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.jaccard">Jaccard Coefficient</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.link_prediction.overlap">Overlap Coefficient</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#sampling">Sampling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.sampling.random_walks">Random Walks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#traversal">Traversal</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.bfs">Breadth-first-search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.dask.traversal.bfs">Breadth-first-search (MG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.sssp">Single-source-shortest-path</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.dask.traversal.sssp">Single-source-shortest-path (MG)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.traversal.traveling_salesperson">Traveling-salesperson-problem</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tree">Tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-cugraph.tree.minimum_spanning_tree">Minimum Spanning Tree</a></li>
<li class="toctree-l3"><a class="reference internal" href="#maximum-spanning-tree">Maximum Spanning Tree</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-cugraph.comms.comms">DASK MG Helper functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="dask-cugraph.html">Multi-GPU with cuGraph</a></li>
<li class="toctree-l1"><a class="reference internal" href="cugraph_blogs.html">cuGraph BLOGS and Presentations</a></li>
<li class="toctree-l1"><a class="reference internal" href="cugraph_ref.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="nx_transition.html">NetworkX Compatibility and Transition</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">

      
      <nav aria-label="top navigation" class="wy-nav-top">
        
          <i class="fa fa-bars" data-toggle="wy-nav-top"></i>
          <a href="index.html">cugraph</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div aria-label="breadcrumbs navigation" role="navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a class="icon icon-home" href="index.html"></a> &raquo;</li>
        
      <li>cuGraph API Reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr>
</div>
          <div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="cugraph-api-reference">
<h1>cuGraph API Reference<a class="headerlink" href="#cugraph-api-reference" title="Permalink to this headline">&para;</a></h1>
<section id="structure">
<h2>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">&para;</a></h2>
<section id="graph">
<h3>Graph<a class="headerlink" href="#graph" title="Permalink to this headline">&para;</a></h3>
<dl class="py class">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">cugraph.structure.graph_classes.</span></span><span class="sig-name descname"><span class="pre">Graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_graph</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L28"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph" title="Permalink to this definition">&para;</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%">
<col style="width: 90%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.add_internal_vertex_id" title="cugraph.structure.graph_classes.Graph.add_internal_vertex_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_internal_vertex_id</span></code></a>(df,&nbsp;&hellip;[,&nbsp;drop,&nbsp;&hellip;])</p></td>
<td><p>Given a DataFrame containing external vertex ids in the identified columns, return a DataFrame containing the internal vertex ids as the specified column name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.add_nodes_from" title="cugraph.structure.graph_classes.Graph.add_nodes_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_nodes_from</span></code></a>(nodes)</p></td>
<td><p>Add nodes information to the Graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.clear" title="cugraph.structure.graph_classes.Graph.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</p></td>
<td><p>Empty the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_cudf_adjlist" title="cugraph.structure.graph_classes.Graph.from_cudf_adjlist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_cudf_adjlist</span></code></a>(offset_col,&nbsp;index_col[,&nbsp;&hellip;])</p></td>
<td><p>Initialize a graph from the adjacency list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_cudf_edgelist" title="cugraph.structure.graph_classes.Graph.from_cudf_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_cudf_edgelist</span></code></a>(input_df[,&nbsp;source,&nbsp;&hellip;])</p></td>
<td><p>Initialize a graph from the edge list.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_dask_cudf_edgelist" title="cugraph.structure.graph_classes.Graph.from_dask_cudf_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_dask_cudf_edgelist</span></code></a>(input_ddf[,&nbsp;source,&nbsp;&hellip;])</p></td>
<td><p>Initializes the distributed graph from the dask_cudf.DataFrame edgelist.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_numpy_array" title="cugraph.structure.graph_classes.Graph.from_numpy_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_numpy_array</span></code></a>(np_array[,&nbsp;nodes])</p></td>
<td><p>Initializes the graph from numpy array containing adjacency matrix.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_numpy_matrix" title="cugraph.structure.graph_classes.Graph.from_numpy_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_numpy_matrix</span></code></a>(np_matrix)</p></td>
<td><p>Initializes the graph from numpy matrix containing adjacency matrix.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_pandas_adjacency" title="cugraph.structure.graph_classes.Graph.from_pandas_adjacency"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas_adjacency</span></code></a>(pdf)</p></td>
<td><p>Initializes the graph from pandas adjacency matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.from_pandas_edgelist" title="cugraph.structure.graph_classes.Graph.from_pandas_edgelist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas_edgelist</span></code></a>(pdf[,&nbsp;source,&nbsp;&hellip;])</p></td>
<td><p>Initialize a graph from the edge list.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.has_isolated_vertices" title="cugraph.structure.graph_classes.Graph.has_isolated_vertices"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_isolated_vertices</span></code></a>()</p></td>
<td><p>Returns True if the graph has isolated vertices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.is_bipartite" title="cugraph.structure.graph_classes.Graph.is_bipartite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_bipartite</span></code></a>()</p></td>
<td><p>Checks if Graph is bipartite.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.is_directed" title="cugraph.structure.graph_classes.Graph.is_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_directed</span></code></a>()</p></td>
<td><p>Returns True if the graph is a directed graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.is_multigraph" title="cugraph.structure.graph_classes.Graph.is_multigraph"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multigraph</span></code></a>()</p></td>
<td><p>Returns True if the graph is a multigraph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.is_multipartite" title="cugraph.structure.graph_classes.Graph.is_multipartite"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_multipartite</span></code></a>()</p></td>
<td><p>Checks if Graph is multipartite.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.is_renumbered" title="cugraph.structure.graph_classes.Graph.is_renumbered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_renumbered</span></code></a>()</p></td>
<td><p>Returns True if the graph is renumbered.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.is_weighted" title="cugraph.structure.graph_classes.Graph.is_weighted"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_weighted</span></code></a>()</p></td>
<td><p>Returns True if the graph has edge weights.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.lookup_internal_vertex_id" title="cugraph.structure.graph_classes.Graph.lookup_internal_vertex_id"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lookup_internal_vertex_id</span></code></a>(df[,&nbsp;column_name])</p></td>
<td><p>Given a DataFrame containing external vertex ids in the identified columns, or a Series containing external vertex ids, return a Series with the internal vertex ids.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.to_directed" title="cugraph.structure.graph_classes.Graph.to_directed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_directed</span></code></a>()</p></td>
<td><p>Return a directed representation of the graph.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.to_undirected" title="cugraph.structure.graph_classes.Graph.to_undirected"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_undirected</span></code></a>()</p></td>
<td><p>Return an undirected copy of the graph.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cugraph.structure.graph_classes.Graph.unrenumber" title="cugraph.structure.graph_classes.Graph.unrenumber"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unrenumber</span></code></a>(df,&nbsp;column_name[,&nbsp;&hellip;])</p></td>
<td><p>Given a DataFrame containing internal vertex ids in the identified column, replace this with external vertex ids.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 58%">
<col style="width: 42%">
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Properties</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.Properties">
<em class="property"><span class="pre">class</span> </em><span class="sig-name descname"><span class="pre">Properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">directed</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L29"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.Properties" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.add_internal_vertex_id">
<span class="sig-name descname"><span class="pre">add_internal_vertex_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">internal_column_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">external_column_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">drop</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L373"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.add_internal_vertex_id" title="Permalink to this definition">&para;</a></dt>
<dd><p>Given a DataFrame containing external vertex ids in the identified
columns, return a DataFrame containing the internal vertex ids as the
specified column name.  Optionally drop the external vertex id columns.
Optionally preserve the order of the original DataFrame.
Parameters
&mdash;&mdash;&mdash;-
df: cudf.DataFrame or dask_cudf.DataFrame
A DataFrame containing external vertex identifiers that will be
converted into internal vertex identifiers.</p>
<p>internal_column_name: string
Name of column to contain the internal vertex id</p>
<p>external_column_name: string or list of strings
Name of the column(s) containing the external vertex ids</p>
<p>drop: (optional) bool, defaults to True
Drop the external columns from the returned DataFrame</p>
<p>preserve_order: (optional) bool, defaults to False
Preserve the order of the data frame (requires an extra sort)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or dask_cudf.DataFrame</span></dt><dd><p>Original DataFrame with new column containing internal vertex
id</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.add_nodes_from">
<span class="sig-name descname"><span class="pre">add_nodes_from</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nodes</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L533"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.add_nodes_from" title="Permalink to this definition">&para;</a></dt>
<dd><p>Add nodes information to the Graph.
Parameters
&mdash;&mdash;&mdash;-
nodes : list or cudf.Series
The nodes of the graph to be stored.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L419"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.clear" title="Permalink to this definition">&para;</a></dt>
<dd><p>Empty the graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_cudf_adjlist">
<span class="sig-name descname"><span class="pre">from_cudf_adjlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">offset_col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">index_col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L131"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_cudf_adjlist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initialize a graph from the adjacency list. It is an error to call this
method on an initialized Graph object. The passed offset_col and
index_col arguments wrap gdf_column objects that represent a graph
using the adjacency list format.
If value_col is None, an unweighted graph is created. If value_col is
not None, a weighted graph is created.
Undirected edges must be stored as directed edges in both directions.
Parameters
&mdash;&mdash;&mdash;-
offset_col : cudf.Series
This cudf.Series wraps a gdf_column of size V + 1 (V: number of
vertices).  The gdf column contains the offsets for the vertices in
this graph.  Offsets must be in the range [0, E] (E: number of edges).</p>
<p>index_col : cudf.Series
This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be in the range [0, V)
(V: number of vertices).</p>
<p>value_col : cudf.Series, optional
This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>.  If not, this cudf.Series wraps a
gdf_column of size E (E: number of edges).  The gdf column contains the
weight value for each edge.  The expected type of the gdf_column
element is floating point number.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">M</span><span class="p">[</span><span class="s1">'2'</span><span class="p">],(</span><span class="n">M</span><span class="p">[</span><span class="s1">'0'</span><span class="p">],</span><span class="n">M</span><span class="p">[</span><span class="s1">'1'</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_adjlist</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_cudf_edgelist">
<span class="sig-name descname"><span class="pre">from_cudf_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'source'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'destination'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renumber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L69"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_cudf_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. The passed input_df argument
wraps gdf_column objects that represent a graph using the edge list
format. source argument is source column name and destination argument
is destination column name.
By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.
If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">cudf.DataFrame or dask_cudf.DataFrame</span></dt><dd></dd>
<dt><strong>A DataFrame that contains edge information If a dask_cudf.DataFrame is</strong></dt><dd></dd>
<dt><strong>passed it will be reinterpreted as a cudf.DataFrame. For the</strong></dt><dd></dd>
<dt><strong>distributed path please use from_dask_cudf_edgelist.</strong></dt><dd></dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd></dd>
<dt><strong>source column name or array of column names</strong></dt><dd></dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd></dd>
<dt><strong>destination column name or array of column names</strong></dt><dd></dd>
<dt><strong>edge_attr</strong><span class="classifier">str or None</span></dt><dd></dd>
<dt><strong>the weights column name. Default is None</strong></dt><dd></dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>Indicate whether or not to renumber the source and destination vertex</strong></dt><dd></dd>
<dt><strong>IDs. Default is True.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                         edge_attr='2', renumber=False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_dask_cudf_edgelist">
<span class="sig-name descname"><span class="pre">from_dask_cudf_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_ddf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'source'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'destination'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renumber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L182"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_dask_cudf_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the distributed graph from the dask_cudf.DataFrame
edgelist. Undirected Graphs are not currently supported.
By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.
Note that the graph object will store a reference to the
dask_cudf.DataFrame provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_ddf</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd></dd>
<dt><strong>The edgelist as a dask_cudf.DataFrame</strong></dt><dd></dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd></dd>
<dt><strong>source column name or array of column names</strong></dt><dd></dd>
<dt><strong>destination</strong><span class="classifier">str</span></dt><dd></dd>
<dt><strong>destination column name or array of column names</strong></dt><dd></dd>
<dt><strong>edge_attr</strong><span class="classifier">str</span></dt><dd></dd>
<dt><strong>weights column name.</strong></dt><dd></dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>If source and destination indices are not in range 0 to V where V is</strong></dt><dd></dd>
<dt><strong>number of vertices, renumber argument should be True.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_numpy_array">
<span class="sig-name descname"><span class="pre">from_numpy_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">np_array</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L289"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_numpy_array" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from numpy array containing adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_numpy_matrix">
<span class="sig-name descname"><span class="pre">from_numpy_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">np_matrix</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L305"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_numpy_matrix" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from numpy matrix containing adjacency matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_pandas_adjacency">
<span class="sig-name descname"><span class="pre">from_pandas_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pdf</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L281"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_pandas_adjacency" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from pandas adjacency matrix</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.from_pandas_edgelist">
<span class="sig-name descname"><span class="pre">from_pandas_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'source'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'destination'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">renumber</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L232"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.from_pandas_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. Source argument is source
column name and destination argument is destination column name.
By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.
If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">pandas.DataFrame</span></dt><dd></dd>
<dt><strong>A DataFrame that contains edge information</strong></dt><dd></dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd></dd>
<dt><strong>source column name or array of column names</strong></dt><dd></dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd></dd>
<dt><strong>destination column name or array of column names</strong></dt><dd></dd>
<dt><strong>edge_attr</strong><span class="classifier">str or None</span></dt><dd></dd>
<dt><strong>the weights column name. Default is None</strong></dt><dd></dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd></dd>
<dt><strong>Indicate whether or not to renumber the source and destination vertex</strong></dt><dd></dd>
<dt><strong>IDs. Default is True.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                         edge_attr='2', renumber=False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.has_isolated_vertices">
<span class="sig-name descname"><span class="pre">has_isolated_vertices</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L469"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.has_isolated_vertices" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns True if the graph has isolated vertices.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.is_bipartite">
<span class="sig-name descname"><span class="pre">is_bipartite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L425"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.is_bipartite" title="Permalink to this definition">&para;</a></dt>
<dd><p>Checks if Graph is bipartite. This solely relies on the user call of
add_nodes_from with the bipartite parameter. This does not parse the
graph to check if it is bipartite.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.is_directed">
<span class="sig-name descname"><span class="pre">is_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L450"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.is_directed" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns True if the graph is a directed graph.
Returns False if the graph is an undirected graph.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.is_multigraph">
<span class="sig-name descname"><span class="pre">is_multigraph</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L443"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.is_multigraph" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns True if the graph is a multigraph. Else returns False.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.is_multipartite">
<span class="sig-name descname"><span class="pre">is_multipartite</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L434"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.is_multipartite" title="Permalink to this definition">&para;</a></dt>
<dd><p>Checks if Graph is multipartite. This solely relies on the user call
of add_nodes_from with the partition parameter. This does not parse
the graph to check if it is multipartite.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.is_renumbered">
<span class="sig-name descname"><span class="pre">is_renumbered</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L457"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.is_renumbered" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns True if the graph is renumbered.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.is_weighted">
<span class="sig-name descname"><span class="pre">is_weighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L463"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.is_weighted" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns True if the graph has edge weights.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.lookup_internal_vertex_id">
<span class="sig-name descname"><span class="pre">lookup_internal_vertex_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L349"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.lookup_internal_vertex_id" title="Permalink to this definition">&para;</a></dt>
<dd><p>Given a DataFrame containing external vertex ids in the identified
columns, or a Series containing external vertex ids, return a
Series with the internal vertex ids.
Note that this function does not guarantee order in single GPU mode,
and does not guarantee order or partitioning in multi-GPU mode.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: cudf.DataFrame, cudf.Series, dask_cudf.DataFrame, dask_cudf.Series</strong></dt><dd></dd>
<dt><strong>A DataFrame containing external vertex identifiers that will be</strong></dt><dd></dd>
<dt><strong>converted into internal vertex identifiers.</strong></dt><dd></dd>
<dt><strong>column_name: (optional) string</strong></dt><dd></dd>
<dt><strong>Name of the column containing the external vertex ids</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>series</strong><span class="classifier">cudf.Series or dask_cudf.Series</span></dt><dd><p>The internal vertex identifiers</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.to_directed">
<span class="sig-name descname"><span class="pre">to_directed</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L475"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.to_directed" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return a directed representation of the graph.
This function sets the type of graph as DiGraph() and returns the
directed view.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">DiGraph</span></dt><dd></dd>
<dt>A directed graph with the same nodes, and each edge (u,v,weights)</dt><dd></dd>
<dt>replaced by two directed edges (u,v,weights) and (v,u,weights).</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DiG</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">to_directed</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.to_undirected">
<span class="sig-name descname"><span class="pre">to_undirected</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L503"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.to_undirected" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return an undirected copy of the graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">Graph</span></dt><dd></dd>
<dt>A undirected graph with the same nodes, and each directed edge</dt><dd></dd>
<dt>(u,v,weights) replaced by an undirected edge (u,v,weights).</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DiG</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DiG</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">DiG</span><span class="o">.</span><span class="n">to_undirected</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="cugraph.structure.graph_classes.Graph.unrenumber">
<span class="sig-name descname"><span class="pre">unrenumber</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">column_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preserve_order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_column_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/graph_classes.py#L312"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.graph_classes.Graph.unrenumber" title="Permalink to this definition">&para;</a></dt>
<dd><p>Given a DataFrame containing internal vertex ids in the identified
column, replace this with external vertex ids.  If the renumbering
is from a single column, the output dataframe will use the same
name for the external vertex identifiers.  If the renumbering is from
a multi-column input, the output columns will be labeled 0 through
n-1 with a suffix of _column_name.
Note that this function does not guarantee order in single GPU mode,
and does not guarantee order or partitioning in multi-GPU mode.  If you
wish to preserve ordering, add an index column to df and sort the
return by that index column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df: cudf.DataFrame or dask_cudf.DataFrame</strong></dt><dd></dd>
<dt><strong>A DataFrame containing internal vertex identifiers that will be</strong></dt><dd></dd>
<dt><strong>converted into external vertex identifiers.</strong></dt><dd></dd>
<dt><strong>column_name: string</strong></dt><dd></dd>
<dt><strong>Name of the column containing the internal vertex id.</strong></dt><dd></dd>
<dt><strong>preserve_order: (optional) bool</strong></dt><dd></dd>
<dt><strong>If True, preserve the order of the rows in the output DataFrame to</strong></dt><dd></dd>
<dt><strong>match the input DataFrame</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or dask_cudf.DataFrame</span></dt><dd></dd>
<dt>The original DataFrame columns exist unmodified.  The external vertex</dt><dd></dd>
<dt>identifiers are added to the DataFrame, the internal vertex identifier</dt><dd></dd>
<dt>column is removed from the dataframe.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-cugraph.structure.symmetrize">
<span id="symmetrize"></span><h3>Symmetrize<a class="headerlink" href="#module-cugraph.structure.symmetrize" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.symmetrize.symmetrize">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.symmetrize.</span></span><span class="sig-name descname"><span class="pre">symmetrize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">source_col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dest_col</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value_col</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/symmetrize.py#L151"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize" title="Permalink to this definition">&para;</a></dt>
<dd><p>Take a COO set of source destination pairs along with associated values
stored in a single GPU or distributed
create a new COO set of source destination pairs along with values where
all edges exist in both directions.</p>
<p>Return from this call will be a COO stored as two cudf Series or
dask_cudf.Series -the symmetrized source column and the symmetrized dest
column, along with
an optional cudf Series containing the associated values (only if the
values are passed in).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>source_col</strong><span class="classifier">cudf.Series or dask_cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the source index for each edge.
Source indices must be an integer type.</p>
</dd>
<dt><strong>dest_col</strong><span class="classifier">cudf.Series or dask_cudf.Series</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains the destination index for each edge.
Destination indices must be an integer type.</p>
</dd>
<dt><strong>value_col</strong><span class="classifier">cudf.Series or dask_cudf.Series (optional)</span></dt><dd><p>This cudf.Series wraps a gdf_column of size E (E: number of edges).
The gdf column contains values associated with this edge.
For this function the values can be any type, they are not
examined, just copied.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sources</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">'0'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">destinations</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">'1'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">values</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="s1">'2'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">destinations</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.symmetrize.symmetrize_ddf">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.symmetrize.</span></span><span class="sig-name descname"><span class="pre">symmetrize_ddf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/symmetrize.py#L92"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize_ddf" title="Permalink to this definition">&para;</a></dt>
<dd><p>Take a COO stored in a distributed DataFrame, and the column names of
the source and destination columns and create a new data frame
using the same column names that symmetrize the graph so that all
edges appear in both directions.</p>
<p>Note that if other columns exist in the data frame (e.g. edge weights)
the other columns will also be replicated.  That is, if (u,v,data)
represents the source value (u), destination value (v) and some
set of other columns (data) in the input data, then the output
data will contain both (u,v,data) and (v,u,data) with matching
data.</p>
<p>If (u,v,data1) and (v,u,data2) exist in the input data where data1
!= data2 then this code will arbitrarily pick the smaller data
element to keep, if this is not desired then the caller should
should correct the data prior to calling symmetrize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>Input data frame containing COO.  Columns should contain source
ids, destination ids and any properties associated with the
edges.</p>
</dd>
<dt><strong>src_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the source ids</p>
</dd>
<dt><strong>dst_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the destination ids</p>
</dd>
<dt><strong>multi</strong><span class="classifier">bool</span></dt><dd><p>Set to True if graph is a Multi(Di)Graph. This allows multiple
edges instead of dropping them.</p>
</dd>
<dt><strong>symmetrize</strong><span class="classifier">bool</span></dt><dd><p>Default is True to perform symmetrization. If False only duplicate
edges are dropped.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym_df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">'0'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.symmetrize.symmetrize_df">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.symmetrize.</span></span><span class="sig-name descname"><span class="pre">symmetrize_df</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">src_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dst_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">multi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/symmetrize.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.symmetrize.symmetrize_df" title="Permalink to this definition">&para;</a></dt>
<dd><p>Take a COO stored in a DataFrame, along with the column names of
the source and destination columns and create a new data frame
using the same column names that symmetrize the graph so that all
edges appear in both directions.
Note that if other columns exist in the data frame (e.g. edge weights)
the other columns will also be replicated.  That is, if (u,v,data)
represents the source value (u), destination value (v) and some
set of other columns (data) in the input data, then the output
data will contain both (u,v,data) and (v,u,data) with matching
data.
If (u,v,data1) and (v,u,data2) exist in the input data where data1
!= data2 then this code will arbitrarily pick the smaller data
element to keep, if this is not desired then the caller should
should correct the data prior to calling symmetrize.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Input data frame containing COO.  Columns should contain source
ids, destination ids and any properties associated with the
edges.</p>
</dd>
<dt><strong>src_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the source ids</p>
</dd>
<dt><strong>dst_name</strong><span class="classifier">string</span></dt><dd><p>Name of the column in the data frame containing the destination ids</p>
</dd>
<dt><strong>multi</strong><span class="classifier">bool</span></dt><dd><p>Set to True if graph is a Multi(Di)Graph. This allows multiple
edges instead of dropping them.</p>
</dd>
<dt><strong>symmetrize</strong><span class="classifier">bool</span></dt><dd><p>Default is True to perform symmetrization. If False only duplicate
edges are dropped.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Comms</span><span class="o">.</span><span class="n">initialize</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'weight'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sym_ddf</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">symmetrize_ddf</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="s2">"src"</span><span class="p">,</span> <span class="s2">"dst"</span><span class="p">,</span> <span class="s2">"weight"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Comms</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.structure.convert_matrix">
<span id="conversion-from-other-formats"></span><h3>Conversion from Other Formats<a class="headerlink" href="#module-cugraph.structure.convert_matrix" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_adjlist">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_adjlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">offsets</span></em>, <em class="sig-param"><span class="pre">indices</span></em>, <em class="sig-param"><span class="pre">values=None</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L86"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_adjlist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from cuDF or Pandas Series representing adjacency
matrix CSR data and returns a new cugraph.Graph object if &lsquo;create_using&rsquo; is
set to cugraph.Graph (the default), or cugraph.DiGraph if &lsquo;create_using&rsquo; is
set to cugraph.DiGraph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>offsets</strong><span class="classifier">cudf.Series, pandas.Series</span></dt><dd><p>The offsets of a CSR adjacency matrix.</p>
</dd>
<dt><strong>indices</strong><span class="classifier">cudf.Series, pandas.Series</span></dt><dd><p>The indices of a CSR adjacency matrix.</p>
</dd>
<dt><strong>values</strong><span class="classifier">cudf.Series, pandas.Series, or None (default), optional</span></dt><dd><p>The values in a CSR adjacency matrix, which represent edge weights in a
graph. If not provided, the resulting graph is considered unweighted.</p>
</dd>
<dt><strong>create_using</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>Specify the type of Graph to create.  Default is cugraph.Graph</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">... </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="s1">'int32'</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="s1">'int32'</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span><span class="s1">'float32'</span><span class="p">},</span>
<span class="gp">... </span>                  <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">pdf</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="n">pdf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">pdf</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offsets</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_adjlist</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_cudf_edgelist">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_cudf_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">df</span></em>, <em class="sig-param"><span class="pre">source='source'</span></em>, <em class="sig-param"><span class="pre">destination='destination'</span></em>, <em class="sig-param"><span class="pre">edge_attr=None</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em>, <em class="sig-param"><span class="pre">renumber=True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L146"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_cudf_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return a new graph created from the edge list representaion. This function
is added for NetworkX compatibility (this function is a RAPIDS version of
NetworkX&rsquo;s from_pandas_edge_list()).  This function does not support
multiple source or destination columns.  But does support renumbering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>This cudf.DataFrame contains columns storing edge source vertices,
destination (or target following NetworkX&rsquo;s terminology) vertices, and
(optional) weights.</p>
</dd>
<dt><strong>source</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the source column.</p>
</dd>
<dt><strong>destination</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the destination (or target following NetworkX&rsquo;s
terminology) column.</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">string or integer, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If not, this is used to index the weight
column.</p>
</dd>
<dt><strong>create_using</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>Specify the type of Graph to create.  Default is cugraph.Graph</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>If source and destination indices are not in range 0 to V where V
is number of vertices, renumber argument should be True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_edgelist">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">df</span></em>, <em class="sig-param"><span class="pre">source='source'</span></em>, <em class="sig-param"><span class="pre">destination='destination'</span></em>, <em class="sig-param"><span class="pre">edge_attr=None</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em>, <em class="sig-param"><span class="pre">renumber=True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L30"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Return a new graph created from the edge list representaion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame, pandas.DataFrame, dask_cudf.core.DataFrame</span></dt><dd><p>This DataFrame contains columns storing edge source vertices,
destination (or target following NetworkX&rsquo;s terminology) vertices, and
(optional) weights.</p>
</dd>
<dt><strong>source</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the source column.</p>
</dd>
<dt><strong>destination</strong><span class="classifier">string or integer</span></dt><dd><p>This is used to index the destination (or target following NetworkX&rsquo;s
terminology) column.</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">string or integer, optional</span></dt><dd><p>This pointer can be <code class="docutils literal notranslate"><span class="pre">None</span></code>. If not, this is used to index the weight
column.</p>
</dd>
<dt><strong>create_using</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>Specify the type of Graph to create.  Default is cugraph.Graph</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>If source and destination indices are not in range 0 to V where V
is number of vertices, renumber argument should be True.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">from_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                              edge_attr='2')</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_numpy_array">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_numpy_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L303"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_numpy_array" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from numpy array containing adjacency matrix.
Set create_using to cugraph.DiGraph for directed graph and
cugraph.Graph for undirected Graph.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_numpy_matrix">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_numpy_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">A</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L328"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_numpy_matrix" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from numpy matrix containing adjacency matrix.
Set create_using to cugraph.DiGraph for directed graph and
cugraph.Graph for undirected Graph.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_pandas_adjacency">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_pandas_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">df</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L277"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_pandas_adjacency" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initializes the graph from pandas adjacency matrix.
Set create_using to cugraph.DiGraph for directed graph and
cugraph.Graph for undirected Graph.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.from_pandas_edgelist">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">from_pandas_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">df</span></em>, <em class="sig-param"><span class="pre">source='source'</span></em>, <em class="sig-param"><span class="pre">destination='destination'</span></em>, <em class="sig-param"><span class="pre">edge_attr=None</span></em>, <em class="sig-param"><span class="pre">create_using=&lt;class</span> <span class="pre">'cugraph.structure.graph_classes.Graph'&gt;</span></em>, <em class="sig-param"><span class="pre">renumber=True</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L194"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.from_pandas_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initialize a graph from the edge list. It is an error to call this
method on an initialized Graph object. Source argument is source
column name and destination argument is destination column name.</p>
<p>By default, renumbering is enabled to map the source and destination
vertices into an index in the range [0, V) where V is the number
of vertices.  If the input vertices are a single column of integers
in the range [0, V), renumbering can be disabled and the original
external vertex ids will be used.</p>
<p>If weights are present, edge_attr argument is the weights column name.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_df</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>A DataFrame that contains edge information</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>edge_attr</strong><span class="classifier">str or None</span></dt><dd><p>the weights column name. Default is None</p>
</dd>
<dt><strong>renumber</strong><span class="classifier">bool</span></dt><dd><p>Indicate whether or not to renumber the source and destination
vertex IDs. Default is True.</p>
</dd>
<dt><strong>create_using: cugraph.DiGraph or cugraph.Graph</strong></dt><dd><p>Indicate whether to create a directed or undirected graph</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.DiGraph or cugraph.Graph</span></dt><dd><p>graph containing edges from the pandas edgelist</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_pandas_edgelist</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span>
<span class="go">                           edge_attr='2', renumber=False)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.to_numpy_array">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">to_numpy_array</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L320"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_numpy_array" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns the graph adjacency matrix as a NumPy array.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.to_numpy_matrix">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">to_numpy_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L344"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_numpy_matrix" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns the graph adjacency matrix as a NumPy matrix.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.to_pandas_adjacency">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">to_pandas_adjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L294"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_pandas_adjacency" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns the graph adjacency matrix as a Pandas DataFrame.
The row indices denote source and column names denote destination.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.structure.convert_matrix.to_pandas_edgelist">
<span class="sig-prename descclassname"><span class="pre">cugraph.structure.convert_matrix.</span></span><span class="sig-name descname"><span class="pre">to_pandas_edgelist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'source'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">destination</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'destination'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/structure/convert_matrix.py#L254"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.structure.convert_matrix.to_pandas_edgelist" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns the graph edge list as a Pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or cugraph.DiGraph</span></dt><dd><p>Graph containg the edgelist.</p>
</dd>
<dt><strong>source</strong><span class="classifier">str or array-like</span></dt><dd><p>source column name or array of column names</p>
</dd>
<dt><strong>destination</strong><span class="classifier">str or array-like</span></dt><dd><p>destination column name or array of column names</p>
</dd>
<dt><strong>Returns</strong></dt><dd></dd>
<dt><strong>&mdash;&mdash;</strong></dt><dd></dd>
<dt><strong>df</strong><span class="classifier">pandas.DataFrame</span></dt><dd><p>pandas dataframe containing the edgelist as source and
destination columns.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="centrality">
<h2>Centrality<a class="headerlink" href="#centrality" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.centrality.betweenness_centrality">
<span id="betweenness-centrality"></span><h3>Betweenness Centrality<a class="headerlink" href="#module-cugraph.centrality.betweenness_centrality" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.centrality.betweenness_centrality.betweenness_centrality">
<span class="sig-prename descclassname"><span class="pre">cugraph.centrality.betweenness_centrality.</span></span><span class="sig-name descname"><span class="pre">betweenness_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">k=None</span></em>, <em class="sig-param"><span class="pre">normalized=True</span></em>, <em class="sig-param"><span class="pre">weight=None</span></em>, <em class="sig-param"><span class="pre">endpoints=False</span></em>, <em class="sig-param"><span class="pre">seed=None</span></em>, <em class="sig-param"><span class="pre">result_dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/centrality/betweenness_centrality.py#L25"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.centrality.betweenness_centrality.betweenness_centrality" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the betweenness centrality for all vertices of the graph G.
Betweenness centrality is a measure of the number of shortest paths that
pass through a vertex.  A vertex with a high betweenness centrality score
has more paths passing through it and is therefore believed to be more
important.</p>
<p>To improve performance. rather than doing an all-pair shortest path,
a sample of k starting vertices can be used.</p>
<p>CuGraph does not currently support the &lsquo;endpoints&rsquo; and &lsquo;weight&rsquo; parameters
as seen in the corresponding networkX call.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph can be either directed (DiGraph) or undirected (Graph).
Weights in the graph are ignored, the current implementation uses
BFS traversals. Use weight parameter if weights need to be considered
(currently not supported)</p>
</dd>
<dt><strong>k</strong><span class="classifier">int or list or None, optional, default=None</span></dt><dd><p>If k is not None, use k node samples to estimate betweenness.  Higher
values give better approximation.  If k is a list, use the content
of the list for estimation: the list should contain vertex
identifiers. If k is None (the default), all the vertices are used
to estimate betweenness.  Vertices obtained through sampling or
defined as a list will be used assources for traversals inside the
algorithm.</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool, optional</span></dt><dd><p>Default is True.
If true, the betweenness values are normalized by
__2 / ((n - 1) * (n - 2))__ for Graphs (undirected), and
__1 / ((n - 1) * (n - 2))__ for DiGraphs (directed graphs)
where n is the number of nodes in G.
Normalization will ensure that values are in [0, 1],
this normalization scales for the highest possible value where one
node is crossed by every single shortest path.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">cudf.DataFrame, optional, default=None</span></dt><dd><p>Specifies the weights to be used for each edge.
Should contain a mapping between
edges and weights.
(Not Supported)</p>
</dd>
<dt><strong>endpoints</strong><span class="classifier">bool, optional, default=False</span></dt><dd><p>If true, include the endpoints in the shortest path counts.
(Not Supported)</p>
</dd>
<dt><strong>seed</strong><span class="classifier">optional</span></dt><dd><p>if k is specified and k is an integer, use seed to initialize the
random number generator.
Using None as seed relies on random.seed() behavior: using current
system time
If k is either None or list: seed parameter is ignored</p>
</dd>
<dt><strong>result_dtype</strong><span class="classifier">np.float32 or np.float64, optional, default=np.float64</span></dt><dd><p>Indicate the data type of the betweenness centrality scores</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding betweenness centrality values.
Please note that the resulting the &lsquo;vertex&rsquo; column might not be
in ascending order.  The Dictionary conatains the same two columns</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;betweenness_centrality&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the betweenness centrality of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.centrality.betweenness_centrality.edge_betweenness_centrality">
<span class="sig-prename descclassname"><span class="pre">cugraph.centrality.betweenness_centrality.</span></span><span class="sig-name descname"><span class="pre">edge_betweenness_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">G</span></em>, <em class="sig-param"><span class="pre">k=None</span></em>, <em class="sig-param"><span class="pre">normalized=True</span></em>, <em class="sig-param"><span class="pre">weight=None</span></em>, <em class="sig-param"><span class="pre">seed=None</span></em>, <em class="sig-param"><span class="pre">result_dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/centrality/betweenness_centrality.py#L148"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.centrality.betweenness_centrality.edge_betweenness_centrality" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the edge betweenness centrality for all edges of the graph G.
Betweenness centrality is a measure of the number of shortest paths
that pass over an edge.  An edge with a high betweenness centrality
score has more paths passing over it and is therefore believed to be
more important.</p>
<p>To improve performance, rather than doing an all-pair shortest path,
a sample of k starting vertices can be used.</p>
<p>CuGraph does not currently support the &lsquo;weight&rsquo; parameter
as seen in the corresponding networkX call.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph can be either directed (DiGraph) or undirected (Graph).
Weights in the graph are ignored, the current implementation uses
BFS traversals. Use weight parameter if weights need to be considered
(currently not supported)</p>
</dd>
<dt><strong>k</strong><span class="classifier">int or list or None, optional, default=None</span></dt><dd><p>If k is not None, use k node samples to estimate betweenness.  Higher
values give better approximation.
If k is a list, use the content of the list for estimation: the list
should contain vertices identifiers.
Vertices obtained through sampling or defined as a list will be used as
sources for traversals inside the algorithm.</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool, optional</span></dt><dd><p>Default is True.
If true, the betweenness values are normalized by
2 / (n * (n - 1)) for Graphs (undirected), and
1 / (n * (n - 1)) for DiGraphs (directed graphs)
where n is the number of nodes in G.
Normalization will ensure that values are in [0, 1],
this normalization scales for the highest possible value where one
edge is crossed by every single shortest path.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">cudf.DataFrame, optional, default=None</span></dt><dd><p>Specifies the weights to be used for each edge.
Should contain a mapping between
edges and weights.
(Not Supported)</p>
</dd>
<dt><strong>seed</strong><span class="classifier">optional</span></dt><dd><p>if k is specified and k is an integer, use seed to initialize the
random number generator.
Using None as seed relies on random.seed() behavior: using current
system time
If k is either None or list: seed parameter is ignored</p>
</dd>
<dt><strong>result_dtype</strong><span class="classifier">np.float32 or np.float64, optional, default=np.float64</span></dt><dd><p>Indicate the data type of the betweenness centrality scores
Using double automatically switch implementation to &ldquo;default&rdquo;</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing three cudf.Series of size E: the vertex
identifiers of the sources, the vertex identifies of the destinations
and the corresponding betweenness centrality values.
Please note that the resulting the &lsquo;src&rsquo;, &lsquo;dst&rsquo; column might not be
in ascending order.</p>
<dl class="simple">
<dt>df[&lsquo;src&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers of the source of each edge</p>
</dd>
<dt>df[&lsquo;dst&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers of the destination of each edge</p>
</dd>
<dt>df[&lsquo;edge_betweenness_centrality&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the betweenness centrality of edges</p>
</dd>
</dl>
<p>When using undirected graphs, &lsquo;src&rsquo; and &lsquo;dst&rsquo; only contains elements
such that &lsquo;src&rsquo; &lt; &lsquo;dst&rsquo;, which might differ from networkx and user&rsquo;s
input. Namely edge (1 -&gt; 0) is transformed into (0 -&gt; 1) but
contains the betweenness centrality of edge (1 -&gt; 0).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ebc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">edge_betweenness_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.centrality.katz_centrality">
<span id="katz-centrality"></span><h3>Katz Centrality<a class="headerlink" href="#module-cugraph.centrality.katz_centrality" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.centrality.katz_centrality.katz_centrality">
<span class="sig-prename descclassname"><span class="pre">cugraph.centrality.katz_centrality.</span></span><span class="sig-name descname"><span class="pre">katz_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-06</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/centrality/katz_centrality.py#L18"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.centrality.katz_centrality.katz_centrality" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the Katz centrality for the nodes of the graph G. cuGraph does not
currently support the &lsquo;beta&rsquo; and &lsquo;weight&rsquo; parameters as seen in the
corresponding networkX call. This implementation is based on a relaxed
version of Katz defined by Foster with a reduced computational complexity
of O(n+m)</p>
<p>Foster, K.C., Muth, S.Q., Potterat, J.J. et al.
Computational &amp; Mathematical Organization Theory (2001) 7: 275.
<a class="reference external" href="https://doi.org/10.1023/A:1013470632383">https://doi.org/10.1023/A:1013470632383</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph can
contain either directed (DiGraph) or undirected edges (Graph).</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Attenuation factor defaulted to None. If alpha is not specified then
it is internally calculated as 1/(degree_max) where degree_max is the
maximum out degree.</p>
<dl class="simple">
<dt>NOTE</dt><dd><p>The maximum acceptable value of alpha for convergence
alpha_max = 1/(lambda_max) where lambda_max is the largest
eigenvalue of the graph.
Since lambda_max is always lesser than or equal to degree_max for a
graph, alpha_max will always be greater than or equal to
(1/degree_max). Therefore, setting alpha to (1/degree_max) will
guarantee that it will never exceed alpha_max thus in turn
fulfilling the requirement for convergence.</p>
</dd>
</dl>
</dd>
<dt><strong>beta</strong><span class="classifier">None</span></dt><dd><p>A weight scalar - currently Not Supported</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0e-6.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 1e-2 and 1e-6 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for katz centrality.</p>
<dl class="simple">
<dt>nstart[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>nstart[&lsquo;values&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the katz centrality values of vertices</p>
</dd>
</dl>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool</span></dt><dd><p>If True normalize the resulting katz centrality values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or Dictionary if using NetworkX</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding katz centrality values.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;katz_centrality&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the katz centrality of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kc</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.dask.centrality.katz_centrality">
<span id="katz-centrality-mg"></span><h3>Katz Centrality (MG)<a class="headerlink" href="#module-cugraph.dask.centrality.katz_centrality" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.centrality.katz_centrality.call_katz_centrality">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.centrality.katz_centrality.</span></span><span class="sig-name descname"><span class="pre">call_katz_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sID</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_verts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_partition_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate_segment_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/centrality/katz_centrality.py#L25"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.centrality.katz_centrality.call_katz_centrality" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.centrality.katz_centrality.katz_centrality">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.centrality.katz_centrality.</span></span><span class="sig-name descname"><span class="pre">katz_centrality</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/centrality/katz_centrality.py#L57"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.centrality.katz_centrality.katz_centrality" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the Katz centrality for the nodes of the graph G.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>input_graph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph can
contain either directed (DiGraph) or undirected edges (Graph).</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>Attenuation factor defaulted to None. If alpha is not specified then
it is internally calculated as 1/(degree_max) where degree_max is the
maximum out degree.</p>
<dl class="simple">
<dt>NOTE</dt><dd><p>The maximum acceptable value of alpha for convergence
alpha_max = 1/(lambda_max) where lambda_max is the largest
eigenvalue of the graph.
Since lambda_max is always lesser than or equal to degree_max for a
graph, alpha_max will always be greater than or equal to
(1/degree_max). Therefore, setting alpha to (1/degree_max) will
guarantee that it will never exceed alpha_max thus in turn
fulfilling the requirement for convergence.</p>
</dd>
</dl>
</dd>
<dt><strong>beta</strong><span class="classifier">None</span></dt><dd><p>A weight scalar - currently Not Supported</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0e-6.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 1e-2 and 1e-6 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">dask_cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for katz centrality</p>
<dl class="simple">
<dt>nstart[&lsquo;vertex&rsquo;]<span class="classifier">dask_cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>nstart[&lsquo;values&rsquo;]<span class="classifier">dask_cudf.Series</span></dt><dd><p>Contains the katz centrality values of vertices</p>
</dd>
</dl>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool</span></dt><dd><p>If True normalize the resulting katz centrality values</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>katz_centrality</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>GPU data frame containing two dask_cudf.Series of size V: the
vertex identifiers and the corresponding katz centrality values.</p>
<dl class="simple">
<dt>ddf[&lsquo;vertex&rsquo;]<span class="classifier">dask_cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>ddf[&lsquo;katz_centrality&rsquo;]<span class="classifier">dask_cudf.Series</span></dt><dd><p>Contains the katz centrality of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="n">Init</span> <span class="n">a</span> <span class="n">DASK</span> <span class="n">Cluster</span>
<span class="go">&gt;&gt;    see https://docs.rapids.ai/api/cugraph/stable/dask-cugraph.html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'value'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span><span class="o">.</span><span class="n">from_dask_cudf_edgelist</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'src'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'dst'</span><span class="p">,</span>
<span class="go">                               edge_attr='value')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">katz_centrality</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="community">
<h2>Community<a class="headerlink" href="#community" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.community.egonet">
<span id="egonet"></span><h3>EgoNet<a class="headerlink" href="#module-cugraph.community.egonet" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.egonet.batched_ego_graphs">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.egonet.</span></span><span class="sig-name descname"><span class="pre">batched_ego_graphs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seeds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undirected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/egonet.py#L118"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.egonet.batched_ego_graphs" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the  induced subgraph of neighbors for each node in seeds
within a given radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information. Edge weights, if present, should be single or double
precision floating point values.</p>
</dd>
<dt><strong>seeds</strong><span class="classifier">cudf.Series or list or cudf.DataFrame</span></dt><dd><p>Specifies the seeds of the induced egonet subgraphs.</p>
</dd>
<dt><strong>radius: integer, optional</strong></dt><dd><p>Include all neighbors of distance&lt;=radius from n.</p>
</dd>
<dt><strong>center: bool, optional</strong></dt><dd><p>Defaults to True. False is not supported</p>
</dd>
<dt><strong>undirected: bool, optional</strong></dt><dd><p>Defaults to False. True is not supported</p>
</dd>
<dt><strong>distance: key, optional</strong></dt><dd><p>Distances are counted in hops from n. Other cases are not supported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>ego_edge_lists</strong><span class="classifier">cudf.DataFrame or pandas.DataFrame</span></dt><dd><p>GPU data frame containing all induced sources identifiers,
destination identifiers, edge weights</p>
</dd>
<dt>seeds_offsets: cudf.Series</dt><dd><p>Series containing the starting offset in the returned edge list
for each seed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.egonet.ego_graph">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.egonet.</span></span><span class="sig-name descname"><span class="pre">ego_graph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">undirected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/egonet.py#L50"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.egonet.ego_graph" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the  induced subgraph of neighbors centered at node n,
within a given radius.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information. Edge weights, if present, should be single or double
precision floating point values.</p>
</dd>
<dt><strong>n</strong><span class="classifier">integer or cudf.DataFrame</span></dt><dd><p>A single node as integer or a cudf.DataFrame if nodes are
represented with multiple columns. If a cudf.DataFrame is provided,
only the first row is taken as the node input.</p>
</dd>
<dt><strong>radius: integer, optional</strong></dt><dd><p>Include all neighbors of distance&lt;=radius from n.</p>
</dd>
<dt><strong>center: bool, optional</strong></dt><dd><p>Defaults to True. False is not supported</p>
</dd>
<dt><strong>undirected: bool, optional</strong></dt><dd><p>Defaults to False. True is not supported</p>
</dd>
<dt><strong>distance: key, optional</strong></dt><dd><p>Distances are counted in hops from n. Other cases are not supported.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_ego</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A graph descriptor with a minimum spanning tree or forest.
The networkx graph will not have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ego_graph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">ego_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">seed</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.ecg">
<span id="ensemble-clustering-for-graphs-ecg"></span><h3>Ensemble clustering for graphs (ECG)<a class="headerlink" href="#module-cugraph.community.ecg" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.ecg.ecg">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.ecg.</span></span><span class="sig-name descname"><span class="pre">ecg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ensemble_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">16</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/ecg.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.ecg.ecg" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the Ensemble Clustering for Graphs (ECG) partition of the input
graph. ECG runs truncated Louvain on an ensemble of permutations of the
input graph, then uses the ensemble partitions to determine weights for
the input graph. The final result is found by running full Louvain on
the input graph using the determined weights.</p>
<p>See <a class="reference external" href="https://arxiv.org/abs/1809.05578">https://arxiv.org/abs/1809.05578</a> for further information.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph or NetworkX Graph</span></dt><dd><p>The graph descriptor should contain the connectivity information
and weights. The adjacency list will be computed if not already
present.</p>
</dd>
<dt><strong>min_weight</strong><span class="classifier">floating point</span></dt><dd><p>The minimum value to assign as an edgeweight in the ECG algorithm.
It should be a value in the range [0,1] usually left as the default
value of .05</p>
</dd>
<dt><strong>ensemble_size</strong><span class="classifier">integer</span></dt><dd><p>The number of graph permutations to use for the ensemble.
The default value is 16, larger values may produce higher quality
partitions for some graphs.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">str</span></dt><dd><p>This parameter is here for NetworkX compatibility and
represents which NetworkX data column represents Edge weights.
Default is None</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame or python dictionary</span></dt><dd><p>GPU data frame of size V containing two columns, the vertex id and
the partition id it is assigned to.</p>
<dl class="simple">
<dt>df[vertex]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[partition]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the partition assigned to the vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="s1">' '</span><span class="p">,</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">ecg</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.ktruss_subgraph">
<span id="k-truss"></span><h3>K-Truss<a class="headerlink" href="#module-cugraph.community.ktruss_subgraph" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.ktruss_subgraph.k_truss">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.ktruss_subgraph.</span></span><span class="sig-name descname"><span class="pre">k_truss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/ktruss_subgraph.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.ktruss_subgraph.k_truss" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns the K-Truss subgraph of a graph for a specific k.</p>
<p>The k-truss of a graph is a subgraph where each edge is part of at least
(k&minus;2) triangles. K-trusses are used for finding tighlty knit groups of
vertices in a graph. A k-truss is a relaxation of a k-clique in the graph
and was define in [1]. Finding cliques is computationally demanding and
finding the maximal k-clique is known to be NP-Hard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. k-Trusses are
defined for only undirected graphs as they are defined for
undirected triangle in a graph.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The desired k to be used for extracting the k-truss subgraph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_truss</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A cugraph graph descriptor with the k-truss subgraph for the given k.
The networkx graph will NOT have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.ktruss_subgraph.ktruss_subgraph">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.ktruss_subgraph.</span></span><span class="sig-name descname"><span class="pre">ktruss_subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/ktruss_subgraph.py#L59"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.ktruss_subgraph.ktruss_subgraph" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns the K-Truss subgraph of a graph for a specific k.</p>
<p>The k-truss of a graph is a subgraph where each edge is part of at least
(k&minus;2) triangles. K-trusses are used for finding tighlty knit groups of
vertices in a graph. A k-truss is a relaxation of a k-clique in the graph
and was define in [1]. Finding cliques is computationally demanding and
finding the maximal k-clique is known to be NP-Hard.</p>
<p>In contrast, finding a k-truss is computationally tractable as its
key building block, namely triangle counting counting, can be executed
in polnymomial time.Typically, it takes many iterations of triangle
counting to find the k-truss of a graph. Yet these iterations operate
on a weakly monotonically shrinking graph.
Therefore, finding the k-truss of a graph can be done in a fairly
reasonable amount of time. The solution in cuGraph is based on a
GPU algorithm first shown in [2] and uses the triangle counting algorithm
from [3].</p>
<p>[1] Cohen, J.,
&ldquo;Trusses: Cohesive subgraphs for social network analysis&rdquo;
National security agency technical report, 2008</p>
<p>[2] O. Green, J. Fox, E. Kim, F. Busato, et al.
&ldquo;Quickly Finding a Truss in a Haystack&rdquo;
IEEE High Performance Extreme Computing Conference (HPEC), 2017
<a class="reference external" href="https://doi.org/10.1109/HPEC.2017.8091038">https://doi.org/10.1109/HPEC.2017.8091038</a></p>
<p>[3] O. Green, P. Yalamanchili, L.M. Munguia,
&ldquo;Fast Triangle Counting on GPU&rdquo;
Irregular Applications: Architectures and Algorithms (IA3), 2014</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. k-Trusses are
defined for only undirected graphs as they are defined for
undirected triangle in a graph.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int</span></dt><dd><p>The desired k to be used for extracting the k-truss subgraph.</p>
</dd>
<dt><strong>use_weights</strong><span class="classifier">Bool</span></dt><dd><p>whether the output should contain the edge weights if G has them</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_truss</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>A cugraph graph descriptor with the k-truss subgraph for the given k.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">k_subgraph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">ktruss_subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.leiden">
<span id="leiden"></span><h3>Leiden<a class="headerlink" href="#module-cugraph.community.leiden" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.leiden.leiden">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.leiden.</span></span><span class="sig-name descname"><span class="pre">leiden</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/leiden.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.leiden.leiden" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Leiden algorithm</p>
<p>It uses the Louvain method described in:</p>
<p>Traag, V. A., Waltman, L., &amp; van Eck, N. J. (2019). From Louvain to Leiden:
guaranteeing well-connected communities. Scientific reports, 9(1), 5233.
doi: 10.1038/s41598-019-41695-z</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor of type Graph</p>
<p>The adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Leiden
algorithm. When specified the algorithm will terminate after no more
than the specified number of iterations. No error occurs when the
algorithm terminates early in this manner.</p>
</dd>
<dt><strong>resolution: float/double, optional</strong></dt><dd><p>Called gamma in the modularity formula, this changes the size
of the communities.  Higher resolutions lead to more smaller
communities, lower resolutions lead to fewer larger communities.
Defaults to 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns the vertex id and the
partition id it is assigned to.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;partition&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the partition assigned to the vertices</p>
</dd>
</dl>
</dd>
<dt><strong>modularity_score</strong><span class="classifier">float</span></dt><dd><p>a floating point number containing the global modularity score of the
partitioning.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">leiden</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.louvain">
<span id="louvain"></span><h3>Louvain<a class="headerlink" href="#module-cugraph.community.louvain" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.louvain.louvain">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.louvain.</span></span><span class="sig-name descname"><span class="pre">louvain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/louvain.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.louvain.louvain" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Louvain method</p>
<p>It uses the Louvain method described in:</p>
<p>VD Blondel, J-L Guillaume, R Lambiotte and E Lefebvre: Fast unfolding of
community hierarchies in large networks, J Stat Mech P10008 (2008),
<a class="reference external" href="http://arxiv.org/abs/0803.0476">http://arxiv.org/abs/0803.0476</a></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or NetworkX Graph</span></dt><dd><p>The graph descriptor should contain the connectivity information
and weights. The adjacency list will be computed if not already
present.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Louvain
algorithm. When specified the algorithm will terminate after no more
than the specified number of iterations. No error occurs when the
algorithm terminates early in this manner.</p>
</dd>
<dt><strong>resolution: float/double, optional</strong></dt><dd><p>Called gamma in the modularity formula, this changes the size
of the communities.  Higher resolutions lead to more smaller
communities, lower resolutions lead to fewer larger communities.
Defaults to 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>parts</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing two columns the vertex id and the
partition id it is assigned to.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;partition&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the partition assigned to the vertices</p>
</dd>
</dl>
</dd>
<dt><strong>modularity_score</strong><span class="classifier">float</span></dt><dd><p>a floating point number containing the global modularity score of the
partitioning.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.dask.community.louvain">
<span id="louvain-mg"></span><h3>Louvain (MG)<a class="headerlink" href="#module-cugraph.dask.community.louvain" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.community.louvain.call_louvain">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.community.louvain.</span></span><span class="sig-name descname"><span class="pre">call_louvain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sID</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_verts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_partition_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate_segment_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_level</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/community/louvain.py#L27"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.community.louvain.call_louvain" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.community.louvain.louvain">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.community.louvain.</span></span><span class="sig-name descname"><span class="pre">louvain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/community/louvain.py#L51"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.community.louvain.louvain" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the modularity optimizing partition of the input graph using the
Louvain method on multiple GPUs</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="n">Init</span> <span class="n">a</span> <span class="n">DASK</span> <span class="n">Cluster</span>
<span class="go">&gt;&gt;    see https://docs.rapids.ai/api/cugraph/stable/dask-cugraph.html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'value'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span><span class="o">.</span><span class="n">from_dask_cudf_edgelist</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'src'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'dst'</span><span class="p">,</span>
<span class="go">                               edge_attr='value')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parts</span><span class="p">,</span> <span class="n">modularity_score</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">louvain</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.spectral_clustering">
<span id="spectral-clustering"></span><h3>Spectral Clustering<a class="headerlink" href="#module-cugraph.community.spectral_clustering" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.spectral_clustering.analyzeClustering_edge_cut">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.spectral_clustering.</span></span><span class="sig-name descname"><span class="pre">analyzeClustering_edge_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clustering</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vertex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cluster'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/spectral_clustering.py#L242"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_edge_cut" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the edge cut score for a partitioning/clustering
The assumption is that &ldquo;clustering&rdquo; is the results from a call
from a special clustering algorithm and contains columns named
&ldquo;vertex&rdquo; and &ldquo;cluster&rdquo;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
<dt><strong>vertex_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the external vertex id</p>
</dd>
<dt><strong>cluster_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the cluster id</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed edge cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_edge_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.spectral_clustering.analyzeClustering_modularity">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.spectral_clustering.</span></span><span class="sig-name descname"><span class="pre">analyzeClustering_modularity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clustering</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vertex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cluster'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/spectral_clustering.py#L176"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_modularity" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the modularity score for a given partitioning/clustering.
The assumption is that &ldquo;clustering&rdquo; is the results from a call
from a special clustering algorithm and contains columns named
&ldquo;vertex&rdquo; and &ldquo;cluster&rdquo;.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or networkx.Graph</span></dt><dd><p>graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
<dt><strong>vertex_col_name</strong><span class="classifier">str or list of str</span></dt><dd><p>The names of the column in the clustering dataframe identifying
the external vertex id</p>
</dd>
<dt><strong>cluster_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the cluster id</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed modularity score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_modularity</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.spectral_clustering.analyzeClustering_ratio_cut">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.spectral_clustering.</span></span><span class="sig-name descname"><span class="pre">analyzeClustering_ratio_cut</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clustering</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'vertex'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_col_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cluster'</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/spectral_clustering.py#L308"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.analyzeClustering_ratio_cut" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the ratio cut score for a partitioning/clustering</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>n_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters in the given clustering</p>
</dd>
<dt><strong>clustering</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>The cluster assignment to analyze.</p>
</dd>
<dt><strong>vertex_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the external vertex id</p>
</dd>
<dt><strong>cluster_col_name</strong><span class="classifier">str</span></dt><dd><p>The name of the column in the clustering dataframe identifying
the cluster id</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>score</strong><span class="classifier">float</span></dt><dd><p>The computed ratio cut score</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">score</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">analyzeClustering_ratio_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>  <span class="s1">'vertex'</span><span class="p">,</span> <span class="s1">'cluster'</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.spectral_clustering.spectralBalancedCutClustering">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.spectral_clustering.</span></span><span class="sig-name descname"><span class="pre">spectralBalancedCutClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_eigen_vects</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evs_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evs_max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmean_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmean_max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/spectral_clustering.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralBalancedCutClustering" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
balanced cut method.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or networkx.Graph</span></dt><dd><p>graph descriptor</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find, must be greater than 1</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters.   Default is 2</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver.
Default is 0.00001</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver.
Default is 100</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver.
Default is 0.00001</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver.
Default is 100</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding cluster assignments.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;cluster&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralBalancedCutClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.spectral_clustering.spectralModularityMaximizationClustering">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.spectral_clustering.</span></span><span class="sig-name descname"><span class="pre">spectralModularityMaximizationClustering</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_eigen_vects</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evs_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">evs_max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmean_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kmean_max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/spectral_clustering.py#L99"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.spectral_clustering.spectralModularityMaximizationClustering" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute a clustering/partitioning of the given graph using the spectral
modularity maximization method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor. This graph should have edge weights.</p>
</dd>
<dt><strong>num_clusters</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of clusters to find</p>
</dd>
<dt><strong>num_eigen_vects</strong><span class="classifier">integer</span></dt><dd><p>Specifies the number of eigenvectors to use. Must be lower or equal to
num_clusters.  Default is 2</p>
</dd>
<dt><strong>evs_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the eigensolver.
Default is 0.00001</p>
</dd>
<dt><strong>evs_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the eigensolver.
Default is 100</p>
</dd>
<dt><strong>kmean_tolerance: float</strong></dt><dd><p>Specifies the tolerance to use in the k-means solver.
Default is 0.00001</p>
</dd>
<dt><strong>kmean_max_iter: integer</strong></dt><dd><p>Specifies the maximum number of iterations for the k-means solver.
Default is 100</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;cluster&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>contains the cluster assignments</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">spectralModularityMaximizationClustering</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.subgraph_extraction">
<span id="subgraph-extraction"></span><h3>Subgraph Extraction<a class="headerlink" href="#module-cugraph.community.subgraph_extraction" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.subgraph_extraction.subgraph">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.subgraph_extraction.</span></span><span class="sig-name descname"><span class="pre">subgraph</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertices</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/subgraph_extraction.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.subgraph_extraction.subgraph" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute a subgraph of the existing graph including only the specified
vertices.  This algorithm works for both directed and undirected graphs,
it does not actually traverse the edges, simply pulls out any edges that
are incident on vertices that are both contained in the vertices list.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor</p>
</dd>
<dt><strong>vertices</strong><span class="classifier">cudf.Series or cudf.DataFrame</span></dt><dd><p>Specifies the vertices of the induced subgraph. For multi-column
vertices, vertices should be provided as a cudf.DataFrame</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>Sg</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>A graph object containing the subgraph induced by the given vertex set.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">numpy</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">verts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sverts</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Sg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">sverts</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.community.triangle_count">
<span id="triangle-counting"></span><h3>Triangle Counting<a class="headerlink" href="#module-cugraph.community.triangle_count" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.community.triangle_count.triangles">
<span class="sig-prename descclassname"><span class="pre">cugraph.community.triangle_count.</span></span><span class="sig-name descname"><span class="pre">triangles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/community/triangle_count.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.community.triangle_count.triangles" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the number of triangles (cycles of length three) in the
input graph.</p>
<p>Unlike NetworkX, this algorithm simply returns the total number of
triangle and not the number per vertex.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information,
(edge weights are not used in this algorithm)</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>count</strong><span class="classifier">int64</span></dt><dd><p>A 64 bit integer whose value gives the number of triangles in the
graph.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">count</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">triangles</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="components">
<h2>Components<a class="headerlink" href="#components" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.components.connectivity">
<span id="connected-components"></span><h3>Connected Components<a class="headerlink" href="#module-cugraph.components.connectivity" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.components.connectivity.connected_components">
<span class="sig-prename descclassname"><span class="pre">cugraph.components.connectivity.</span></span><span class="sig-name descname"><span class="pre">connected_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'weak'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/components/connectivity.py#L315"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.components.connectivity.connected_components" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generate either the stronlgly or weakly connected components and attach a
component label to each vertex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information (edge weights are not used for this algorithm). If using a
graph object, the graph can be either directed or undirected where an
undirected edge is represented by a directed edge in both directions.
The adjacency list will be computed if not already present.  The number
of vertices should fit into a 32b int.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only. Raises
TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph
and only move from point i to point j along paths csgraph[i, j]. If
False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
</dd>
<dt><strong>connection</strong><span class="classifier">str, optional</span></dt><dd><p>[&lsquo;weak&rsquo;|&rsquo;strong&rsquo;]. Return either weakly or strongly connected
components.</p>
</dd>
<dt><strong>return_labels</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only. Raises
TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then return the labels for each of the connected
components.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding component identifier.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]</dt><dd><p>Contains the vertex identifier</p>
</dd>
<dt>df[&lsquo;labels&rsquo;]</dt><dd><p>The component identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>python dictionary, where keys are vertices and values are the component
identifiers.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>CuPy ndarray (if CuPy matrix input) or Numpy ndarray (if SciPy matrix
input) of shape (&lt;num vertices&gt;, 2), where column 0 contains component
identifiers and column 1 contains vertices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">connection</span><span class="o">=</span><span class="s2">"weak"</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.components.connectivity.strongly_connected_components">
<span class="sig-prename descclassname"><span class="pre">cugraph.components.connectivity.</span></span><span class="sig-name descname"><span class="pre">strongly_connected_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/components/connectivity.py#L217"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.components.connectivity.strongly_connected_components" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generate the Strongly Connected Components and attach a component label to
each vertex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information (edge weights are not used for this algorithm). If using a
graph object, the graph can be either directed or undirected where an
undirected edge is represented by a directed edge in both directions.
The adjacency list will be computed if not already present.  The number
of vertices should fit into a 32b int.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only.
Raises TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph
and only move from point i to point j along paths csgraph[i, j]. If
False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
</dd>
<dt><strong>connection</strong><span class="classifier">str, optional</span></dt><dd><p>Added for SciPy compatibility, can only be specified for non-Graph-type
(eg. sparse matrix) values of G only (raises TypeError if used with a
Graph object), and can only be set to &ldquo;strong&rdquo; for this API.</p>
</dd>
<dt><strong>return_labels</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only. Raises
TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then return the labels for each of the connected
components.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding component identifier.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]</dt><dd><p>Contains the vertex identifier</p>
</dd>
<dt>df[&lsquo;labels&rsquo;]</dt><dd><p>The component identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>python dictionary, where keys are vertices and values are the component
identifiers.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>CuPy ndarray (if CuPy matrix input) or Numpy ndarray (if SciPy matrix
input) of shape (&lt;num vertices&gt;, 2), where column 0 contains component
identifiers and column 1 contains vertices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">strongly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.components.connectivity.weakly_connected_components">
<span class="sig-prename descclassname"><span class="pre">cugraph.components.connectivity.</span></span><span class="sig-name descname"><span class="pre">weakly_connected_components</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/components/connectivity.py#L120"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.components.connectivity.weakly_connected_components" title="Permalink to this definition">&para;</a></dt>
<dd><p>Generate the Weakly Connected Components and attach a component label to
each vertex.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information (edge weights are not used for this algorithm). If using a
graph object, the graph can be either directed or undirected where an
undirected edge is represented by a directed edge in both directions.
The adjacency list will be computed if not already present.  The number
of vertices should fit into a 32b int.</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only.
Raises TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph
and only move from point i to point j along paths csgraph[i, j]. If
False, then find the shortest path on an undirected graph: the
algorithm can progress from point i to j along csgraph[i, j] or
csgraph[j, i].</p>
</dd>
<dt><strong>connection</strong><span class="classifier">str, optional</span></dt><dd><p>Added for SciPy compatibility, can only be specified for non-Graph-type
(eg. sparse matrix) values of G only (raises TypeError if used with a
Graph object), and can only be set to &ldquo;weak&rdquo; for this API.</p>
</dd>
<dt><strong>return_labels</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only. Raises
TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then return the labels for each of the connected
components.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding component identifier.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]</dt><dd><p>Contains the vertex identifier</p>
</dd>
<dt>df[&lsquo;labels&rsquo;]</dt><dd><p>The component identifier</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>python dictionary, where keys are vertices and values are the component
identifiers.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>CuPy ndarray (if CuPy matrix input) or Numpy ndarray (if SciPy matrix
input) of shape (&lt;num vertices&gt;, 2), where column 0 contains component
identifiers and column 1 contains vertices.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span>
<span class="go">                      delimiter = ' ',</span>
<span class="go">                      dtype=['int32', 'int32', 'float32'],</span>
<span class="go">                      header=None)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">weakly_connected_components</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="cores">
<h2>Cores<a class="headerlink" href="#cores" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.cores.core_number">
<span id="core-number"></span><h3>Core Number<a class="headerlink" href="#module-cugraph.cores.core_number" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.cores.core_number.core_number">
<span class="sig-prename descclassname"><span class="pre">cugraph.cores.core_number.</span></span><span class="sig-name descname"><span class="pre">core_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/cores/core_number.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.cores.core_number.core_number" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the core numbers for the nodes of the graph G. A k-core of a graph
is a maximal subgraph that contains nodes of degree k or more.
A node has a core number of k if it belongs a k-core but not to k+1-core.
This call does not support a graph with self-loops and parallel
edges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph should contain undirected edges where undirected edges are
represented as directed edges in both directions. While this graph
can contain edge weights, they don&rsquo;t participate in the calculation
of the core numbers.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame or python dictionary (in NetworkX input)</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding core number values.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;core_number&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the core number of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cn</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">core_number</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.cores.k_core">
<span id="k-core"></span><h3>K-Core<a class="headerlink" href="#module-cugraph.cores.k_core" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.cores.k_core.k_core">
<span class="sig-prename descclassname"><span class="pre">cugraph.cores.k_core.</span></span><span class="sig-name descname"><span class="pre">k_core</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">core_number</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/cores/k_core.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.cores.k_core.k_core" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the k-core of the graph G based on the out degree of its nodes. A
k-core of a graph is a maximal subgraph that contains nodes of degree k or
more. This call does not support a graph with self-loops and parallel
edges.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information. The graph
should contain undirected edges where undirected edges are represented
as directed edges in both directions. While this graph can contain edge
weights, they don&rsquo;t participate in the calculation of the k-core.</p>
</dd>
<dt><strong>k</strong><span class="classifier">int, optional</span></dt><dd><p>Order of the core. This value must not be negative. If set to None, the
main core is returned.</p>
</dd>
<dt><strong>core_number</strong><span class="classifier">cudf.DataFrame, optional</span></dt><dd><p>Precomputed core number of the nodes of the graph G containing two
cudf.Series of size V: the vertex identifiers and the corresponding
core number values. If set to None, the core numbers of the nodes are
calculated internally.</p>
<dl class="simple">
<dt>core_number[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>core_number[&lsquo;values&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the core number of vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>KCoreGraph</strong><span class="classifier">cuGraph.Graph</span></dt><dd><p>K Core of the input graph</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">KCoreGraph</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">k_core</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="layout">
<h2>Layout<a class="headerlink" href="#layout" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.layout.force_atlas2">
<span id="force-atlas-2"></span><h3>Force Atlas 2<a class="headerlink" href="#module-cugraph.layout.force_atlas2" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.layout.force_atlas2.force_atlas2">
<span class="sig-prename descclassname"><span class="pre">cugraph.layout.force_atlas2.</span></span><span class="sig-name descname"><span class="pre">force_atlas2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pos_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outbound_attraction_distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lin_log_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prevent_overlapping</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_weight_influence</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">jitter_tolerance</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">barnes_hut_optimize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">barnes_hut_theta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scaling_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">strong_gravity_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gravity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/layout/force_atlas2.py#L17"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.layout.force_atlas2.force_atlas2" title="Permalink to this definition">&para;</a></dt>
<dd><p>ForceAtlas2 is a continuous graph layout algorithm for handy network
visualization.</p>
<p>NOTE: Peak memory allocation occurs at 30*V.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.
Edge weights, if present, should be single or double precision
floating point values.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">integer</span></dt><dd><p>This controls the maximum number of levels/iterations of the Force
Atlas algorithm. When specified the algorithm will terminate after
no more than the specified number of iterations.
No error occurs when the algorithm terminates in this manner.
Good short-term quality can be achieved with 50-100 iterations.
Above 1000 iterations is discouraged.</p>
</dd>
<dt><strong>pos_list: cudf.DataFrame</strong></dt><dd><p>Data frame with initial vertex positions containing two columns:
&lsquo;x&rsquo; and &lsquo;y&rsquo; positions.</p>
</dd>
<dt><strong>outbound_attraction_distribution: bool</strong></dt><dd><p>Distributes attraction along outbound edges.
Hubs attract less and thus are pushed to the borders.</p>
</dd>
<dt><strong>lin_log_mode: bool</strong></dt><dd><p>Switch Force Atlas model from lin-lin to lin-log.
Makes clusters more tight.</p>
</dd>
<dt><strong>prevent_overlapping: bool</strong></dt><dd><p>Prevent nodes to overlap.</p>
</dd>
<dt><strong>edge_weight_influence: float</strong></dt><dd><p>How much influence you give to the edges weight.
0 is &ldquo;no influence&rdquo; and 1 is &ldquo;normal&rdquo;.</p>
</dd>
<dt><strong>jitter_tolerance: float</strong></dt><dd><p>How much swinging you allow. Above 1 discouraged.
Lower gives less speed and more precision.</p>
</dd>
<dt><strong>barnes_hut_optimize: bool</strong></dt><dd><p>Whether to use the Barnes Hut approximation or the slower
exact version.</p>
</dd>
<dt><strong>barnes_hut_theta: float</strong></dt><dd><p>Float between 0 and 1. Tradeoff for speed (1) vs
accuracy (0) for Barnes Hut only.</p>
</dd>
<dt><strong>scaling_ratio: float</strong></dt><dd><p>How much repulsion you want. More makes a more sparse graph.
Switching from regular mode to LinLog mode needs a readjustment
of the scaling parameter.</p>
</dd>
<dt><strong>strong_gravity_mode: bool</strong></dt><dd><p>Sets a force that attracts the nodes that are distant from the
center more. It is so strong that it can sometimes dominate other
forces.</p>
</dd>
<dt><strong>gravity</strong><span class="classifier">float</span></dt><dd><p>Attracts nodes to the center. Prevents islands from drifting away.</p>
</dd>
<dt><strong>verbose: bool</strong></dt><dd><p>Output convergence info at each interation.</p>
</dd>
<dt><strong>callback: GraphBasedDimRedCallback</strong></dt><dd><p>An instance of GraphBasedDimRedCallback class to intercept
the internal state of positions while they are being trained.</p>
<dl class="simple">
<dt>Example of callback usage:</dt><dd><dl class="simple">
<dt>from cugraph.internals import GraphBasedDimRedCallback</dt><dd><dl class="simple">
<dt>class CustomCallback(GraphBasedDimRedCallback):</dt><dd><dl class="simple">
<dt>def on_preprocess_end(self, positions):</dt><dd><p>print(positions.copy_to_host())</p>
</dd>
<dt>def on_epoch_end(self, positions):</dt><dd><p>print(positions.copy_to_host())</p>
</dd>
<dt>def on_train_end(self, positions):</dt><dd><p>print(positions.copy_to_host())</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pos</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size V containing three columns:
the vertex identifiers and the x and y positions.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="linear-assignment">
<h2>Linear Assignment<a class="headerlink" href="#linear-assignment" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.linear_assignment.hungarian">
<span id="hungarian"></span><h3>Hungarian<a class="headerlink" href="#module-cugraph.linear_assignment.hungarian" title="Permalink to this headline">&para;</a></h3>
<p>Execute the Hungarian algorithm against a symmetric, weighted,
bipartite graph.</p>
<p>As a bipartite graph, the vertex set of the graph can be partitioned
into two disjoint sets such that all edges connect a vertex from
one set to a vertex of the other set.  The workers variable identifies
one of the sets of vertices, the other set is all vertices not in
the workers set (V - workers).</p>
<p>The edge weights reflect the cost of assigning a particular job to a
worker.</p>
<p>The Hungarian algorithm identifies the lowest cost matching of vertices
such that all workers that can be assigned work are assigned exactly
on job.</p>
<section id="parameters">
<h4>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">&para;</a></h4>
<dl class="simple">
<dt>G<span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an an edge list.  Edge weights are required. If an edge list is
not provided then it will be computed.</p>
</dd>
<dt>workers<span class="classifier">cudf.Series or cudf.DataFrame</span></dt><dd><p>A series or column that identifies the vertex ids of the vertices
in the workers set.  In case of multi-column vertices, it should be a
cudf.DataFrame. All vertices in G that are not in the workers
set are implicitly assigned to the jobs set.</p>
</dd>
<dt>epsilon<span class="classifier">float or double (matching weight type in graph)</span></dt><dd><p>Used for determining when value is close enough to zero to consider 0.
Defaults (if not specified) to 1e-6 in the C++ code.  Unused for
integer weight types.</p>
</dd>
</dl>
</section>
<section id="returns">
<h4>Returns<a class="headerlink" href="#returns" title="Permalink to this headline">&para;</a></h4>
<dl class="simple">
<dt>cost<span class="classifier">matches costs.dtype</span></dt><dd><p>The cost of the overall assignment</p>
</dd>
<dt>df<span class="classifier">cudf.DataFrame</span></dt><dd><dl class="simple">
<dt>df[&lsquo;vertex&rsquo;][i] gives the vertex id of the i&rsquo;th vertex.  Only vertices</dt><dd><p>in the workers list are defined in this column.</p>
</dd>
<dt>df[&lsquo;assignment&rsquo;][i] gives the vertex id of the &ldquo;job&rdquo; assigned to the</dt><dd><p>corresponding vertex.</p>
</dd>
</dl>
</dd>
</dl>
<p>FIXME: Update this with a real example&hellip;</p>
</section>
<section id="examples">
<h4>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">&para;</a></h4>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/bipartite.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">,</span> <span class="n">edge_attr</span><span class="o">=</span><span class="s1">'2'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">hungarian</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">workers</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="link-analysis">
<h2>Link Analysis<a class="headerlink" href="#link-analysis" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.link_analysis.hits">
<span id="hits"></span><h3>HITS<a class="headerlink" href="#module-cugraph.link_analysis.hits" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_analysis.hits.hits">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_analysis.hits.</span></span><span class="sig-name descname"><span class="pre">hits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalized</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_analysis/hits.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_analysis.hits.hits" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute HITS hubs and authorities values for each vertex</p>
<p>The HITS algorithm computes two numbers for a node.  Authorities
estimates the node value based on the incoming links.  Hubs estimates
the node value based on outgoing links.</p>
<p>The cuGraph implementation of HITS is a wrapper around the gunrock
implementation of HITS.</p>
<p>Note that the gunrock implementation uses a 2-norm, while networkx
uses a 1-norm.  The raw scores will be different, but the rank ordering
should be comparable with networkx.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm).
The adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned.
The gunrock implementation does not currently support tolerance,
so this will in fact be the number of iterations the HITS algorithm
executes.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.  This parameter is not currently supported.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>Not currently supported</p>
</dd>
<dt><strong>normalized</strong><span class="classifier">bool</span></dt><dd><p>Not currently supported, always used as True</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>HubsAndAuthorities</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing three cudf.Series of size V: the vertex
identifiers and the corresponding hubs values and the corresponding
authorities values.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;hubs&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the hubs score</p>
</dd>
<dt>df[&lsquo;authorities&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the authorities score</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">hits</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">hits</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.link_analysis.pagerank">
<span id="pagerank"></span><h3>Pagerank<a class="headerlink" href="#module-cugraph.link_analysis.pagerank" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_analysis.pagerank.pagerank">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_analysis.pagerank.</span></span><span class="sig-name descname"><span class="pre">pagerank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">personalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dangling</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_analysis/pagerank.py#L18"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_analysis.pagerank.pagerank" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the PageRank score for every vertex in a graph. cuGraph computes an
approximation of the Pagerank eigenvector using the power method. The
number of iterations depends on the properties of the network itself; it
increases when the tolerance descreases and/or alpha increases toward the
limiting value of 1. The user is free to use default values or to provide
inputs for the initial guess, tolerance and maximum number of iterations.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>graph</strong><span class="classifier">cugraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list.
The transposed adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The damping factor alpha represents the probability to follow an
outgoing edge, standard value is 0.85.
Thus, 1.0-alpha is the probability to &ldquo;teleport&rdquo; to a random vertex.
Alpha should be greater than 0.0 and strictly lower than 1.0.</p>
</dd>
<dt><strong>personalization</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the personalization information.</p>
<dl class="simple">
<dt>personalization[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for personalization</p>
</dd>
<dt>personalization[&lsquo;values&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Personalization values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned. This can
be used to limit the execution time and do an early exit before the
solver reaches the convergence tolerance.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 100.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0E-5.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 0.01 and 0.00001 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the initial guess for pagerank.</p>
<dl class="simple">
<dt>nstart[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for initial guess for pagerank values</p>
</dd>
<dt>nstart[&lsquo;values&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Pagerank values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>weight: str</strong></dt><dd><p>The attribute column to be used as edge weights if Graph is a NetworkX
Graph. This parameter is here for NetworkX compatibility and is ignored
in case of a cugraph.Graph</p>
</dd>
<dt><strong>dangling</strong><span class="classifier">dict</span></dt><dd><p>This parameter is here for NetworkX compatibility and ignored</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>PageRank</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame containing two cudf.Series of size V: the vertex
identifiers and the corresponding PageRank values.</p>
<dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>df[&lsquo;pagerank&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the PageRank score</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.85</span><span class="p">,</span> <span class="n">max_iter</span> <span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">tol</span> <span class="o">=</span> <span class="mf">1.0e-05</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.dask.link_analysis.pagerank">
<span id="pagerank-mg"></span><h3>Pagerank (MG)<a class="headerlink" href="#module-cugraph.dask.link_analysis.pagerank" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.link_analysis.pagerank.pagerank">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.link_analysis.pagerank.</span></span><span class="sig-name descname"><span class="pre">pagerank</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.85</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">personalization</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/link_analysis/pagerank.py#L54"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.link_analysis.pagerank.pagerank" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the PageRank values for each vertex in a graph using multiple GPUs.
cuGraph computes an approximation of the Pagerank using the power method.
The input graph must contain edge list as  dask-cudf dataframe with
one partition per GPU.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>graph</strong><span class="classifier">cugraph.DiGraph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as dask cudf edge list dataframe(edge weights are not used for this
algorithm). Undirected Graph not currently supported.</p>
</dd>
<dt><strong>alpha</strong><span class="classifier">float</span></dt><dd><p>The damping factor alpha represents the probability to follow an
outgoing edge, standard value is 0.85.
Thus, 1.0-alpha is the probability to &ldquo;teleport&rdquo; to a random vertex.
Alpha should be greater than 0.0 and strictly lower than 1.0.</p>
</dd>
<dt><strong>personalization</strong><span class="classifier">cudf.Dataframe</span></dt><dd><p>GPU Dataframe containing the personalization information.
Currently not supported.</p>
<dl class="simple">
<dt>personalization[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Subset of vertices of graph for personalization</p>
</dd>
<dt>personalization[&lsquo;values&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Personalization values for vertices</p>
</dd>
</dl>
</dd>
<dt><strong>max_iter</strong><span class="classifier">int</span></dt><dd><p>The maximum number of iterations before an answer is returned.
If this value is lower or equal to 0 cuGraph will use the default
value, which is 30.</p>
</dd>
<dt><strong>tolerance</strong><span class="classifier">float</span></dt><dd><p>Set the tolerance the approximation, this parameter should be a small
magnitude value.
The lower the tolerance the better the approximation. If this value is
0.0f, cuGraph will use the default value which is 1.0E-5.
Setting too small a tolerance can lead to non-convergence due to
numerical roundoff. Usually values between 0.01 and 0.00001 are
acceptable.</p>
</dd>
<dt><strong>nstart</strong><span class="classifier">not supported</span></dt><dd><p>initial guess for pagerank</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>PageRank</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>GPU data frame containing two dask_cudf.Series of size V: the
vertex identifiers and the corresponding PageRank values.</p>
<dl class="simple">
<dt>ddf[&lsquo;vertex&rsquo;]<span class="classifier">dask_cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>ddf[&lsquo;pagerank&rsquo;]<span class="classifier">dask_cudf.Series</span></dt><dd><p>Contains the PageRank score</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="n">Init</span> <span class="n">a</span> <span class="n">DASK</span> <span class="n">Cluster</span>
<span class="go">&gt;&gt;    see https://docs.rapids.ai/api/cugraph/stable/dask-cugraph.html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'value'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span><span class="o">.</span><span class="n">from_dask_cudf_edgelist</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'src'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'dst'</span><span class="p">,</span>
<span class="go">                               edge_attr='value')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pr</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">pagerank</span><span class="p">(</span><span class="n">dg</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="link-prediction">
<h2>Link Prediction<a class="headerlink" href="#link-prediction" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.link_prediction.jaccard">
<span id="jaccard-coefficient"></span><h3>Jaccard Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.jaccard" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_prediction.jaccard.jaccard">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_prediction.jaccard.</span></span><span class="sig-name descname"><span class="pre">jaccard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_pair</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_prediction/jaccard.py#L23"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_prediction.jaccard.jaccard" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the Jaccard similarity between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Jaccard similarity is defined between two sets as the ratio of the volume
of their intersection divided by the volume of their union. In the context
of graphs, the neighborhood of a vertex is seen as a set. The Jaccard
similarity weight of each edge represents the strength of connection
between vertices based on the relative similarity of their neighbors. If
first is specified but second is not, or vice versa, an exception will be
thrown.</p>
<p>NOTE: If the vertex_pair parameter is not specified then the behavior
of cugraph.jaccard is different from the behavior of
networkx.jaccard_coefficient.</p>
<p>cugraph.jaccard, in the absence of a specified vertex pair list, will
use the edges of the graph to construct a vertex pair list and will
return the jaccard coefficient for those vertex pairs.</p>
<p>networkx.jaccard_coefficient, in the absence of a specified vertex
pair list, will return an upper triangular dense matrix, excluding
the diagonal as well as vertex pairs that are directly connected
by an edge in the graph, of jaccard coefficients.  Technically, networkx
returns a lazy iterator across this upper triangular matrix where
the actual jaccard coefficient is computed when the iterator is
dereferenced.  Computing a dense matrix of results is not feasible
if the number of vertices in the graph is large (100,000 vertices
would result in 4.9 billion values in that iterator).</p>
<p>If your graph is small enough (or you have enough memory and patience)
you can get the interesting (non-zero) values that are part of the networkx
solution by doing the following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pairs</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">get_two_hop_neighbors</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">pairs</span><span class="p">)</span>
</pre></div>
</div>
<p>But please remember that cugraph will fill the dataframe with the entire
solution you request, so you&rsquo;ll need enough memory to store the 2-hop
neighborhood dataframe.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
graph should be undirected where an undirected edge is represented by a
directed edge in both direction. The adjacency list will be computed if
not already present.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs.  If the vertex_pair is not provided then the
current implementation computes the jaccard coefficient for all
adjacent vertices in the graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[&lsquo;source&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified)</p>
</dd>
<dt>df[&lsquo;destination&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified)</p>
</dd>
<dt>df[&lsquo;jaccard_coeff&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Jaccard coefficient between the source and destination
vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_prediction.jaccard.jaccard_coefficient">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_prediction.jaccard.</span></span><span class="sig-name descname"><span class="pre">jaccard_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_prediction/jaccard.py#L128"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_prediction.jaccard.jaccard_coefficient" title="Permalink to this definition">&para;</a></dt>
<dd><p>For NetworkX Compatability.  See <cite>jaccard</cite></p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
graph should be undirected where an undirected edge is represented by a
directed edge in both direction. The adjacency list will be computed if
not already present.</p>
</dd>
<dt><strong>ebunch</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs.  If the vertex_pair is not provided then the
current implementation computes the jaccard coefficient for all
adjacent vertices in the graph.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[&lsquo;source&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified)</p>
</dd>
<dt>df[&lsquo;destination&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified)</p>
</dd>
<dt>df[&lsquo;jaccard_coeff&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Jaccard coefficient between the source and destination
vertices</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard_coefficient</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<span class="target" id="module-cugraph.link_prediction.wjaccard"></span><dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_prediction.wjaccard.jaccard_w">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_prediction.wjaccard.</span></span><span class="sig-name descname"><span class="pre">jaccard_w</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_pair</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_prediction/wjaccard.py#L21"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_prediction.wjaccard.jaccard_w" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the weighted Jaccard similarity between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Jaccard similarity is defined between two sets as the ratio of
the volume of their intersection divided by the volume of their union. In
the context of graphs, the neighborhood of a vertex is seen as a set. The
Jaccard similarity weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Specifies the weights to be used for each vertex.
Vertex should be represented by multiple columns for multi-column
vertices.</p>
<dl class="simple">
<dt>weights[&lsquo;vertex&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the vertex identifiers</p>
</dd>
<dt>weights[&lsquo;weight&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>Contains the weights of vertices</p>
</dd>
</dl>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the jaccard coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Jaccard weights. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[&lsquo;source&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[&lsquo;destination&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[&lsquo;jaccard_coeff&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Jaccard coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">jaccard_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.link_prediction.overlap">
<span id="overlap-coefficient"></span><h3>Overlap Coefficient<a class="headerlink" href="#module-cugraph.link_prediction.overlap" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_prediction.overlap.overlap">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_prediction.overlap.</span></span><span class="sig-name descname"><span class="pre">overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_pair</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_prediction/overlap.py#L45"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_prediction.overlap.overlap" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the Overlap Coefficient between each pair of vertices connected by
an edge, or between arbitrary pairs of vertices specified by the user.
Overlap Coefficient is defined between two sets as the ratio of the volume
of their intersection divided by the smaller of their two volumes. In the
context of graphs, the neighborhood of a vertex is seen as a set. The
Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the overlap coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the Overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[&lsquo;source&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID (will be identical to first if specified).</p>
</dd>
<dt>df[&lsquo;destination&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID (will be identical to second if
specified).</p>
</dd>
<dt>df[&lsquo;overlap_coeff&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The computed Overlap coefficient between the source and destination
vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">gdf</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_prediction.overlap.overlap_coefficient">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_prediction.overlap.</span></span><span class="sig-name descname"><span class="pre">overlap_coefficient</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ebunch</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_prediction/overlap.py#L22"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_prediction.overlap.overlap_coefficient" title="Permalink to this definition">&para;</a></dt>
<dd><p>NetworkX similar API.  See &lsquo;jaccard&rsquo; for a description</p>
</dd></dl>

<span class="target" id="module-cugraph.link_prediction.woverlap"></span><dl class="py function">
<dt class="sig sig-object py" id="cugraph.link_prediction.woverlap.overlap_w">
<span class="sig-prename descclassname"><span class="pre">cugraph.link_prediction.woverlap.</span></span><span class="sig-name descname"><span class="pre">overlap_w</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_pair</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/link_prediction/woverlap.py#L20"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.link_prediction.woverlap.overlap_w" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the weighted Overlap Coefficient between each pair of vertices
connected by an edge, or between arbitrary pairs of vertices specified by
the user. Overlap Coefficient is defined between two sets as the ratio of
the volume of their intersection divided by the smaller of their volumes.
In the context of graphs, the neighborhood of a vertex is seen as a set.
The Overlap Coefficient weight of each edge represents the strength of
connection between vertices based on the relative similarity of their
neighbors. If first is specified but second is not, or vice versa, an
exception will be thrown.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>input_graph</strong><span class="classifier">cugraph.Graph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as an edge list (edge weights are not used for this algorithm). The
adjacency list will be computed if not already present.</p>
</dd>
<dt><strong>weights</strong><span class="classifier">cudf.Series</span></dt><dd><p>Specifies the weights to be used for each vertex.</p>
</dd>
<dt><strong>vertex_pair</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>A GPU dataframe consisting of two columns representing pairs of
vertices. If provided, the overlap coefficient is computed for the
given vertex pairs, else, it is computed for all vertex pairs.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>GPU data frame of size E (the default) or the size of the given pairs
(first, second) containing the overlap coefficients. The ordering is
relative to the adjacency list, or that given by the specified vertex
pairs.</p>
<dl class="simple">
<dt>df[&lsquo;source&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The source vertex ID</p>
</dd>
<dt>df[&lsquo;destination&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The destination vertex ID</p>
</dd>
<dt>df[&lsquo;overlap_coeff&rsquo;]<span class="classifier">cudf.Series</span></dt><dd><p>The computed weighted Overlap coefficient between the source and
destination vertices.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">overlap_w</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">M</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>
<section id="sampling">
<h2>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.sampling.random_walks">
<span id="random-walks"></span><h3>Random Walks<a class="headerlink" href="#module-cugraph.sampling.random_walks" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.sampling.random_walks.random_walks">
<span class="sig-prename descclassname"><span class="pre">cugraph.sampling.random_walks.</span></span><span class="sig-name descname"><span class="pre">random_walks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start_vertices</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/sampling/random_walks.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.sampling.random_walks.random_walks" title="Permalink to this definition">&para;</a></dt>
<dd><p>compute random walks for each nodes in &lsquo;start_vertices&rsquo;</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>The graph can be either directed (DiGraph) or undirected (Graph).
Weights in the graph are ignored.
Use weight parameter if weights need to be considered
(currently not supported)</p>
</dd>
<dt><strong>start_vertices</strong><span class="classifier">int or list or cudf.Series or cudf.DataFrame</span></dt><dd><p>A single node or a list or a cudf.Series of nodes from which to run
the random walks. In case of multi-column vertices it should be
a cudf.DataFrame</p>
</dd>
<dt><strong>max_depth</strong><span class="classifier">int</span></dt><dd><p>The maximum depth of the random walks</p>
</dd>
<dt><strong>use_padding</strong><span class="classifier">bool</span></dt><dd><p>If True, padded paths are returned else coalesced paths are returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>vertex_paths</strong><span class="classifier">cudf.Series or cudf.DataFrame</span></dt><dd><p>Series containing the vertices of edges/paths in the random walk.</p>
</dd>
<dt>edge_weight_paths: cudf.Series</dt><dd><p>Series containing the edge weights of edges represented by the
returned vertex_paths</p>
</dd>
<dt>sizes: int</dt><dd><p>The path size in case of coalesced paths.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.sampling.random_walks.rw_path">
<span class="sig-prename descclassname"><span class="pre">cugraph.sampling.random_walks.</span></span><span class="sig-name descname"><span class="pre">rw_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">num_paths</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sizes</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/sampling/random_walks.py#L94"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.sampling.random_walks.rw_path" title="Permalink to this definition">&para;</a></dt>
<dd><p>Retrieve more information on the obtained paths in case use_padding
is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>num_paths: int</strong></dt><dd><p>Number of paths in the random walk output.</p>
</dd>
<dt><strong>sizes: int</strong></dt><dd><p>Path size returned in random walk output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>path_data</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>Dataframe containing vetex path offsets, edge weight offsets and
edge weight sizes for each path.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="traversal">
<h2>Traversal<a class="headerlink" href="#traversal" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.traversal.bfs">
<span id="breadth-first-search"></span><h3>Breadth-first-search<a class="headerlink" href="#module-cugraph.traversal.bfs" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.bfs.bfs">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.bfs.</span></span><span class="sig-name descname"><span class="pre">bfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i_start</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_predecessors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/bfs.py#L99"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.bfs.bfs" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information. Edge weights, if present, should be single or double
precision floating point values.</p>
</dd>
<dt><strong>start</strong><span class="classifier">Integer</span></dt><dd><p>The index of the graph vertex from which the traversal begins</p>
</dd>
<dt><strong>i_start</strong><span class="classifier">Integer, optional</span></dt><dd><p>Identical to start, added for API compatibility. Only start or i_start
can be set, not both.</p>
</dd>
<dt><strong>depth_limit</strong><span class="classifier">Integer or None</span></dt><dd><p>Limit the depth of the search</p>
</dd>
<dt><strong>directed</strong><span class="classifier">bool, optional</span></dt><dd><dl class="simple">
<dt>NOTE</dt><dd><p>For non-Graph-type (eg. sparse matrix) values of G only. Raises
TypeError if used with a Graph object.</p>
</dd>
</dl>
<p>If True (default), then convert the input matrix to a cugraph.DiGraph,
otherwise a cugraph.Graph object will be used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>df[&lsquo;vertex&rsquo;] vertex IDs</p>
<p>df[&lsquo;distance&rsquo;] path distance for each vertex from the starting vertex</p>
<p>df[&lsquo;predecessor&rsquo;] for each i&rsquo;th position in the column, the vertex ID
immediately preceding the vertex at position i in the &lsquo;vertex&rsquo; column</p>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>pandas.DataFrame with contents equivalent to the cudf.DataFrame
described above.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>a 2-tuple of CuPy ndarrays (if CuPy matrix input) or Numpy ndarrays (if
SciPy matrix input) representing:</p>
<dl class="simple">
<dt>distance: cupy or numpy ndarray</dt><dd><p>ndarray of shortest distances between source and vertex.</p>
</dd>
<dt>predecessor: cupy or numpy ndarray</dt><dd><p>ndarray of predecessors of a vertex on the path from source, which
can be used to reconstruct the shortest paths.</p>
</dd>
</dl>
<p>&hellip;or if return_sp_counter is True, returns a 3-tuple with the above two
arrays plus:</p>
<dl class="simple">
<dt>sp_counter: cupy or numpy ndarray</dt><dd><p>ndarray of number of shortest paths leading to each vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.bfs.bfs_edges">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.bfs.</span></span><span class="sig-name descname"><span class="pre">bfs_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/bfs.py#L201"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.bfs.bfs_edges" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix</span></dt><dd><p>Graph or matrix object, which should contain the connectivity
information. Edge weights, if present, should be single or double
precision floating point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">Integer</span></dt><dd><p>The starting vertex index</p>
</dd>
<dt><strong>reverse</strong><span class="classifier">boolean</span></dt><dd><p>If a directed graph, then process edges in a reverse direction
Currently not implemented</p>
</dd>
<dt><strong>depth_limit</strong><span class="classifier">Int or None</span></dt><dd><p>Limit the depth of the search</p>
</dd>
<dt><strong>sort_neighbors</strong><span class="classifier">None or Function</span></dt><dd><p>Currently not implemented</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl>
<dt>cudf.DataFrame</dt><dd><p>df[&lsquo;vertex&rsquo;] vertex IDs</p>
<p>df[&lsquo;distance&rsquo;] path distance for each vertex from the starting vertex</p>
<p>df[&lsquo;predecessor&rsquo;] for each i&rsquo;th position in the column, the vertex ID
immediately preceding the vertex at position i in the &lsquo;vertex&rsquo; column</p>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>pandas.DataFrame with contents equivalent to the cudf.DataFrame
described above.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>a 2-tuple of CuPy ndarrays (if CuPy matrix input) or Numpy ndarrays (if
SciPy matrix input) representing:</p>
<dl class="simple">
<dt>distance: cupy or numpy ndarray</dt><dd><p>ndarray of shortest distances between source and vertex.</p>
</dd>
<dt>predecessor: cupy or numpy ndarray</dt><dd><p>ndarray of predecessors of a vertex on the path from source, which
can be used to reconstruct the shortest paths.</p>
</dd>
</dl>
<p>&hellip;or if return_sp_counter is True, returns a 3-tuple with the above two
arrays plus:</p>
<dl class="simple">
<dt>sp_counter: cupy or numpy ndarray</dt><dd><p>ndarray of number of shortest paths leading to each vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">bfs_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.dask.traversal.bfs">
<span id="breadth-first-search-mg"></span><h3>Breadth-first-search (MG)<a class="headerlink" href="#module-cugraph.dask.traversal.bfs" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.traversal.bfs.bfs">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.traversal.bfs.</span></span><span class="sig-name descname"><span class="pre">bfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_distances</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/traversal/bfs.py#L51"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.traversal.bfs.bfs" title="Permalink to this definition">&para;</a></dt>
<dd><p>Find the distances and predecessors for a breadth first traversal of a
graph.
The input graph must contain edge list as  dask-cudf dataframe with
one partition per GPU.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.DiGraph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as dask cudf edge list dataframe(edge weights are not used for this
algorithm). Undirected Graph not currently supported.</p>
</dd>
<dt><strong>start</strong><span class="classifier">Integer</span></dt><dd><p>Specify starting vertex for breadth-first search; this function
iterates over edges in the component reachable from this node.</p>
</dd>
<dt><strong>depth_limit</strong><span class="classifier">Integer or None</span></dt><dd><p>Limit the depth of the search</p>
</dd>
<dt><strong>return_distances</strong><span class="classifier">bool, optional, default=True</span></dt><dd><p>Indicates if distances should be returned</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>df[&lsquo;vertex&rsquo;] gives the vertex id</p>
<p>df[&lsquo;distance&rsquo;] gives the path distance from the
starting vertex (Only if return_distances is True)</p>
<p>df[&lsquo;predecessor&rsquo;] gives the vertex it was
reached from in the traversal</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="n">Init</span> <span class="n">a</span> <span class="n">DASK</span> <span class="n">Cluster</span>
<span class="go">&gt;&gt;    see https://docs.rapids.ai/api/cugraph/stable/dask-cugraph.html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'value'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span><span class="o">.</span><span class="n">from_dask_cudf_edgelist</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="s1">'src'</span><span class="p">,</span> <span class="s1">'dst'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">bfs</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.traversal.bfs.call_bfs">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.traversal.bfs.</span></span><span class="sig-name descname"><span class="pre">call_bfs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sID</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_verts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_partition_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate_segment_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">depth_limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_distances</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/traversal/bfs.py#L25"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.traversal.bfs.call_bfs" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

</section>
<section id="module-cugraph.traversal.sssp">
<span id="single-source-shortest-path"></span><h3>Single-source-shortest-path<a class="headerlink" href="#module-cugraph.traversal.sssp" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.sssp.filter_unreachable">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.sssp.</span></span><span class="sig-name descname"><span class="pre">filter_unreachable</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/sssp.py#L235"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.sssp.filter_unreachable" title="Permalink to this definition">&para;</a></dt>
<dd><p>Remove unreachable vertices from the result of SSSP or BFS</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>cudf.DataFrame that is the output of SSSP or BFS</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>df</strong><span class="classifier">filtered cudf.DataFrame with only reachable vertices</span></dt><dd><p>df[&lsquo;vertex&rsquo;][i] gives the vertex id of the i&rsquo;th vertex.
df[&lsquo;distance&rsquo;][i] gives the path distance for the i&rsquo;th vertex from the
starting vertex.
df[&lsquo;predecessor&rsquo;][i] gives the vertex that was reached before the i&rsquo;th
vertex in the traversal.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.sssp.shortest_path">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.sssp.</span></span><span class="sig-name descname"><span class="pre">shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_predecessors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unweighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/sssp.py#L265"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.sssp.shortest_path" title="Permalink to this definition">&para;</a></dt>
<dd><p>Alias for sssp(), provided for API compatibility with NetworkX. See sssp()
for details.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.sssp.shortest_path_length">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.sssp.</span></span><span class="sig-name descname"><span class="pre">shortest_path_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/sssp.py#L281"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.sssp.shortest_path_length" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the distance from a source vertex to one or all vertexes in graph.
Uses Single Source Shortest Path (SSSP).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cuGraph.Graph, NetworkX.Graph, or CuPy sparse COO matrix</span></dt><dd><p>cuGraph graph descriptor with connectivity information. Edge weights,
if present, should be single or double precision floating point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">Dependant on graph type. Index of the source vertex.</span></dt><dd></dd>
<dt><strong>If graph is an instance of cuGraph.Graph or CuPy sparse COO matrix:</strong></dt><dd><p>int</p>
</dd>
<dt><strong>If graph is an instance of a NetworkX.Graph:</strong></dt><dd><p>str</p>
</dd>
<dt><strong>target: Dependant on graph type. Vertex to find distance to.</strong></dt><dd></dd>
<dt><strong>If graph is an instance of cuGraph.Graph or CuPy sparse COO matrix:</strong></dt><dd><p>int</p>
</dd>
<dt><strong>If graph is an instance of a NetworkX.Graph:</strong></dt><dd><p>str</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Return value type is based on the input type.</dt><dd></dd>
<dt>If target is None, returns:</dt><dd><dl class="simple">
<dt>cudf.DataFrame</dt><dd><dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]</dt><dd><p>vertex id</p>
</dd>
<dt>df[&lsquo;distance&rsquo;]</dt><dd><p>gives the path distance from the starting vertex</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If target is not None, returns:</dt><dd><p>Distance from source to target vertex.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.sssp.sssp">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.sssp.</span></span><span class="sig-name descname"><span class="pre">sssp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_predecessors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unweighted</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indices</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/sssp.py#L139"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.sssp.sssp" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the distance and predecessors for shortest paths from the specified
source to all the vertices in the graph. The distances column will store
the distance from the source to each vertex. The predecessors column will
store each vertex&rsquo;s predecessor in the shortest path. Vertices that are
unreachable will have a distance of infinity denoted by the maximum value
of the data type and the predecessor set as -1. The source vertex&rsquo;s
predecessor is also set to -1. Graphs with negative weight cycles are not
supported.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.Graph, networkx.Graph, CuPy or SciPy sparse matrix Graph or</span></dt><dd><p>matrix object, which should contain the connectivity information. Edge
weights, if present, should be single or double precision floating
point values.</p>
</dd>
<dt><strong>source</strong><span class="classifier">int</span></dt><dd><p>Index of the source vertex.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt>Return value type is based on the input type.  If G is a cugraph.Graph,</dt><dd></dd>
<dt>returns:</dt><dd><dl class="simple">
<dt>cudf.DataFrame</dt><dd><dl class="simple">
<dt>df[&lsquo;vertex&rsquo;]</dt><dd><p>vertex id</p>
</dd>
<dt>df[&lsquo;distance&rsquo;]</dt><dd><p>gives the path distance from the starting vertex</p>
</dd>
<dt>df[&lsquo;predecessor&rsquo;]</dt><dd><p>the vertex it was reached from</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>If G is a networkx.Graph, returns:</dt><dd><p>pandas.DataFrame with contents equivalent to the cudf.DataFrame
described above.</p>
</dd>
<dt>If G is a CuPy or SciPy matrix, returns:</dt><dd><p>a 2-tuple of CuPy ndarrays (if CuPy matrix input) or Numpy ndarrays (if
SciPy matrix input) representing:</p>
<dl class="simple">
<dt>distance: cupy or numpy ndarray</dt><dd><p>ndarray of shortest distances between source and vertex.</p>
</dd>
<dt>predecessor: cupy or numpy ndarray</dt><dd><p>ndarray of predecessors of a vertex on the path from source, which
can be used to reconstruct the shortest paths.</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'datasets/karate.csv'</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                  <span class="n">dtype</span><span class="o">=</span><span class="p">[</span><span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'int32'</span><span class="p">,</span> <span class="s1">'float32'</span><span class="p">],</span> <span class="n">header</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span><span class="o">.</span><span class="n">from_cudf_edgelist</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">'0'</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="s1">'1'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.dask.traversal.sssp">
<span id="single-source-shortest-path-mg"></span><h3>Single-source-shortest-path (MG)<a class="headerlink" href="#module-cugraph.dask.traversal.sssp" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.traversal.sssp.call_sssp">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.traversal.sssp.</span></span><span class="sig-name descname"><span class="pre">call_sssp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sID</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_verts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_edges</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vertex_partition_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">aggregate_segment_offsets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">start</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/traversal/sssp.py#L25"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.traversal.sssp.call_sssp" title="Permalink to this definition">&para;</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.traversal.sssp.sssp">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.traversal.sssp.</span></span><span class="sig-name descname"><span class="pre">sssp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">graph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">source</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/traversal/sssp.py#L47"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.traversal.sssp.sssp" title="Permalink to this definition">&para;</a></dt>
<dd><p>Compute the distance and predecessors for shortest paths from the specified
source to all the vertices in the graph. The distances column will store
the distance from the source to each vertex. The predecessors column will
store each vertex&rsquo;s predecessor in the shortest path. Vertices that are
unreachable will have a distance of infinity denoted by the maximum value
of the data type and the predecessor set as -1. The source vertex&rsquo;s
predecessor is also set to -1.
The input graph must contain edge list as dask-cudf dataframe with
one partition per GPU.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>graph</strong><span class="classifier">cugraph.DiGraph</span></dt><dd><p>cuGraph graph descriptor, should contain the connectivity information
as dask cudf edge list dataframe.
Undirected Graph not currently supported.</p>
</dd>
<dt><strong>source</strong><span class="classifier">Integer</span></dt><dd><p>Specify source vertex</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>df</strong><span class="classifier">dask_cudf.DataFrame</span></dt><dd><p>df[&lsquo;vertex&rsquo;] gives the vertex id</p>
<p>df[&lsquo;distance&rsquo;] gives the path distance from the
starting vertex</p>
<p>df[&lsquo;predecessor&rsquo;] gives the vertex id it was
reached from in the traversal</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cugraph.dask</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="o">...</span> <span class="n">Init</span> <span class="n">a</span> <span class="n">DASK</span> <span class="n">Cluster</span>
<span class="go">&gt;&gt;    see https://docs.rapids.ai/api/cugraph/stable/dask-cugraph.html</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ddf</span> <span class="o">=</span> <span class="n">dask_cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">input_data_path</span><span class="p">,</span> <span class="n">chunksize</span><span class="o">=</span><span class="n">chunksize</span><span class="p">,</span>
<span class="go">                             delimiter=' ',</span>
<span class="go">                             names=['src', 'dst', 'value'],</span>
<span class="go">                             dtype=['int32', 'int32', 'float32'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span> <span class="o">=</span> <span class="n">cugraph</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dg</span><span class="o">.</span><span class="n">from_dask_cudf_edgelist</span><span class="p">(</span><span class="n">ddf</span><span class="p">,</span> <span class="s1">'src'</span><span class="p">,</span> <span class="s1">'dst'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">sssp</span><span class="p">(</span><span class="n">dg</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-cugraph.traversal.traveling_salesperson">
<span id="traveling-salesperson-problem"></span><h3>Traveling-salesperson-problem<a class="headerlink" href="#module-cugraph.traversal.traveling_salesperson" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.traversal.traveling_salesperson.traveling_salesperson">
<span class="sig-prename descclassname"><span class="pre">cugraph.traversal.traveling_salesperson.</span></span><span class="sig-name descname"><span class="pre">traveling_salesperson</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pos_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restarts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beam_search</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/traversal/traveling_salesperson.py#L19"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.traversal.traveling_salesperson.traveling_salesperson" title="Permalink to this definition">&para;</a></dt>
<dd><p>Finds an approximate solution to the traveling salesperson problem (TSP).
cuGraph computes an approximation of the TSP problem using hill climbing
optimization.</p>
<p>The current implementation does not support a weighted graph.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pos_list: cudf.DataFrame</strong></dt><dd><p>Data frame with initial vertex positions containing three columns:
&lsquo;vertex&rsquo; ids and &lsquo;x&rsquo;, &lsquo;y&rsquo; positions.</p>
</dd>
<dt><strong>restarts: int</strong></dt><dd><p>Number of starts to try. The more restarts, the better the solution
will be approximated. The number of restarts depends on the problem
size and should be kept low for instances above 2k cities.</p>
</dd>
<dt><strong>beam_search: bool</strong></dt><dd><p>Specify if the initial solution should use KNN for an approximation
solution.</p>
</dd>
<dt><strong>k: int</strong></dt><dd><p>Beam width to use in the search.</p>
</dd>
<dt><strong>nstart: int</strong></dt><dd><p>Vertex id to use as starting position.</p>
</dd>
<dt><strong>verbose: bool</strong></dt><dd><p>Logs configuration and iterative improvement.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>route</strong><span class="classifier">cudf.Series</span></dt><dd><p>cudf.Series of size V containing the ordered list of vertices
than needs to be visited.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="tree">
<h2>Tree<a class="headerlink" href="#tree" title="Permalink to this headline">&para;</a></h2>
<section id="module-cugraph.tree.minimum_spanning_tree">
<span id="minimum-spanning-tree"></span><h3>Minimum Spanning Tree<a class="headerlink" href="#module-cugraph.tree.minimum_spanning_tree" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.tree.minimum_spanning_tree.minimum_spanning_tree">
<span class="sig-prename descclassname"><span class="pre">cugraph.tree.minimum_spanning_tree.</span></span><span class="sig-name descname"><span class="pre">minimum_spanning_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boruvka'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/tree/minimum_spanning_tree.py#L60"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.tree.minimum_spanning_tree.minimum_spanning_tree" title="Permalink to this definition">&para;</a></dt>
<dd><p>Returns a minimum spanning tree (MST) or forest (MSF) on an undirected
graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string</span></dt><dd><p>default to the weights in the graph, if the graph edges do not have a
weight attribute a default weight of 1 will be used.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">string</span></dt><dd><p>Default to &lsquo;boruvka&rsquo;. The parallel algorithm to use when finding a
minimum spanning tree.</p>
</dd>
<dt><strong>ignore_nan</strong><span class="classifier">bool</span></dt><dd><p>Default to False</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_mst</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A graph descriptor with a minimum spanning tree or forest.
The networkx graph will not have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
<section id="maximum-spanning-tree">
<h3>Maximum Spanning Tree<a class="headerlink" href="#maximum-spanning-tree" title="Permalink to this headline">&para;</a></h3>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">cugraph.tree.minimum_spanning_tree.</span></span><span class="sig-name descname"><span class="pre">maximum_spanning_tree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">G</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">algorithm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boruvka'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore_nan</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/tree/minimum_spanning_tree.py#L100"><span class="viewcode-link"><span class="pre">[source]</span></span></a></dt>
<dd><p>Returns a maximum spanning tree (MST) or forest (MSF) on an undirected
graph</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>G</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>cuGraph graph descriptor with connectivity information.</p>
</dd>
<dt><strong>weight</strong><span class="classifier">string</span></dt><dd><p>default to the weights in the graph, if the graph edges do not have a
weight attribute a default weight of 1 will be used.</p>
</dd>
<dt><strong>algorithm</strong><span class="classifier">string</span></dt><dd><p>Default to &lsquo;boruvka&rsquo;. The parallel algorithm to use when finding a
maximum spanning tree.</p>
</dd>
<dt><strong>ignore_nan</strong><span class="classifier">bool</span></dt><dd><p>Default to False</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>G_mst</strong><span class="classifier">cuGraph.Graph or networkx.Graph</span></dt><dd><p>A graph descriptor with a maximum spanning tree or forest.
The networkx graph will not have all attributes copied over</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
<section id="module-cugraph.comms.comms">
<span id="dask-mg-helper-functions"></span><h2>DASK MG Helper functions<a class="headerlink" href="#module-cugraph.comms.comms" title="Permalink to this headline">&para;</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="cugraph.comms.comms.initialize">
<span class="sig-prename descclassname"><span class="pre">cugraph.comms.comms.</span></span><span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p2p</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">partition_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/comms/comms.py#L70"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.comms.comms.initialize" title="Permalink to this definition">&para;</a></dt>
<dd><p>Initialize a communicator for multi-node/multi-gpu communications.  It is
expected to be called right after client initialization for running
multi-GPU algorithms (this wraps raft comms that manages underlying NCCL
and UCX comms handles across the workers of a Dask cluster).</p>
<p>It is recommended to also call <cite>destroy()</cite> when the comms are no longer
needed so the underlying resources can be cleaned up.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>comms</strong><span class="classifier">raft Comms</span></dt><dd><p>A pre-initialized raft communicator. If provided, this is used for mnmg
communications. If not provided, default comms are initialized as per
client information.</p>
</dd>
<dt><strong>p2p</strong><span class="classifier">bool</span></dt><dd><p>Initialize UCX endpoints if True. Default is False.</p>
</dd>
<dt><strong>prows</strong><span class="classifier">int</span></dt><dd><p>Specifies the number of rows when performing a 2D partitioning of the
input graph. If specified, this must be a factor of the total number of
parallel processes. When specified with pcols, prows*pcols should be
equal to the total number of parallel processes.</p>
</dd>
<dt><strong>pcols</strong><span class="classifier">int</span></dt><dd><p>Specifies the number of columns when performing a 2D partitioning of
the input graph. If specified, this must be a factor of the total
number of parallel processes. When specified with prows, prows*pcols
should be equal to the total number of parallel processes.</p>
</dd>
<dt><strong>partition_type</strong><span class="classifier">int</span></dt><dd><p>Valid values are currently 1 or any int other than 1. A value of 1 (the
default) represents a partitioning resulting in prows*pcols
partitions. A non-1 value currently results in a partitioning of
p*pcols partitions, where p is the number of GPUs.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="cugraph.comms.comms.destroy">
<span class="sig-prename descclassname"><span class="pre">cugraph.comms.comms.</span></span><span class="sig-name descname"><span class="pre">destroy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/comms/comms.py#L176"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.comms.comms.destroy" title="Permalink to this definition">&para;</a></dt>
<dd><p>Shuts down initialized comms and cleans up resources.</p>
</dd></dl>

<span class="target" id="module-cugraph.dask.common.read_utils"></span><dl class="py function">
<dt class="sig sig-object py" id="cugraph.dask.common.read_utils.get_chunksize">
<span class="sig-prename descclassname"><span class="pre">cugraph.dask.common.read_utils.</span></span><span class="sig-name descname"><span class="pre">get_chunksize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_path</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/rapidsai/cugraph/blob/7c41bb9/python/cugraph/dask/common/read_utils.py#L22"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#cugraph.dask.common.read_utils.get_chunksize" title="Permalink to this definition">&para;</a></dt>
<dd><p>Calculate the appropriate chunksize for dask_cudf.read_csv
to get a number of partitions equal to the number of GPUs.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">dask_cugraph.pagerank</span> <span class="k">as</span> <span class="nn">dcg</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chunksize</span> <span class="o">=</span> <span class="n">dcg</span><span class="o">.</span><span class="n">get_chunksize</span><span class="p">(</span><span class="n">edge_list</span><span class="o">.</span><span class="n">csv</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
</section>


           </div>
           
          </div>
          <footer>
    <div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
        <a accesskey="n" class="btn btn-neutral float-right" href="dask-cugraph.html" rel="next" title="Multi-GPU with cuGraph">Next <span aria-hidden="true" class="fa fa-arrow-circle-right"></span></a>
        <a accesskey="p" class="btn btn-neutral float-left" href="cugraph_intro.html" rel="prev" title="cuGraph Introduction"><span aria-hidden="true" class="fa fa-arrow-circle-left"></span> Previous</a>
    </div>

  <hr>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019-2020, NVIDIA.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   


<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body></html>