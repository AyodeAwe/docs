
<!DOCTYPE html>

<html class="writer-html5" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>API Reference — cudf 0+untagged.1.g4e5401e documentation</title>
<link href="_static/css/theme.css" rel="stylesheet" type="text/css"/>
<link href="_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="_static/copybutton.css" rel="stylesheet" type="text/css"/>
<link href="_static/params.css" rel="stylesheet" type="text/css"/>
<link href="https://docs.rapids.ai/assets/css/custom.css" rel="stylesheet" type="text/css"/>
<!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
<script data-url_root="./" id="documentation_options" src="_static/documentation_options.js" type="text/javascript"></script>
<script src="_static/jquery.js"></script>
<script src="_static/underscore.js"></script>
<script src="_static/doctools.js"></script>
<script src="_static/language_data.js"></script>
<script src="_static/clipboard.min.js"></script>
<script src="_static/copybutton.js"></script>
<script src="_static/copybutton_pydocs.js"></script>
<script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
<script src="_static/js/theme.js" type="text/javascript"></script>
<link href="genindex.html" rel="index" title="Index"/>
<link href="search.html" rel="search" title="Search"/>
<link href="10min.html" rel="next" title="10 Minutes to cuDF and Dask-cuDF"/>
<link href="index.html" rel="prev" title="Welcome to cuDF’s documentation!"/>
<link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body class="wy-body-for-nav">
<div class="wy-grid-for-nav">
<nav class="wy-nav-side" data-toggle="wy-nav-shift">
<div class="wy-side-scroll">
<div class="wy-side-nav-search"><div id="rapids-sphinx-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">cudf</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">libnvstrings</a><a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">nvstrings</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">nightly (0.15)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/cudf/nightly/api.html">nightly (0.15)</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">stable (0.14)</a><a class="rapids-selector__menu-item" href="/api/cudf/legacy/api.html">legacy (0.13)</a></div></div></div>


<div role="search">
<form action="search.html" class="wy-form" id="rtd-search-form" method="get">
<input name="q" placeholder="Search docs" type="text"/>
<input name="check_keywords" type="hidden" value="yes"/>
<input name="area" type="hidden" value="default"/>
</form>
</div>
</div>
<div aria-label="main navigation" class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation">
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#dataframe">DataFrame</a></li>
<li class="toctree-l2"><a class="reference internal" href="#series">Series</a></li>
<li class="toctree-l2"><a class="reference internal" href="#strings">Strings</a></li>
<li class="toctree-l2"><a class="reference internal" href="#index">Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#rangeindex">RangeIndex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#genericindex">GenericIndex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#int8index">Int8Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#int16index">Int16Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#int32index">Int32Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#int64index">Int64Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uint8index">UInt8Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uint16index">UInt16Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uint32index">UInt32Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#uint64index">UInt64Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#float32index">Float32Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#float64index">Float64Index</a></li>
<li class="toctree-l2"><a class="reference internal" href="#categoricalindex">CategoricalIndex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#stringindex">StringIndex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#datetimeindex">DatetimeIndex</a></li>
<li class="toctree-l2"><a class="reference internal" href="#categories">Categories</a></li>
<li class="toctree-l2"><a class="reference internal" href="#groupby">GroupBy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-cudf.io.csv">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gpuarrowreader">GpuArrowReader</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="10min.html">10 Minutes to cuDF and Dask-cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-cudf.html">Multi-GPU with Dask-cuDF</a></li>
<li class="toctree-l1"><a class="reference internal" href="dask-xgb-10min.html">10 Minutes to Dask-XGBoost</a></li>
<li class="toctree-l1"><a class="reference internal" href="10min-cudf-cupy.html">10 Minutes to cuDF and CuPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="guide-to-udfs.html">Overview of User Defined Functions with cuDF</a></li>
</ul>
</div>
</div>
</nav>
<section class="wy-nav-content-wrap" data-toggle="wy-nav-shift">
<nav aria-label="top navigation" class="wy-nav-top">
<i class="fa fa-bars" data-toggle="wy-nav-top"></i>
<a href="index.html">cudf</a>
</nav>
<div class="wy-nav-content">
<div class="rst-content">
<div aria-label="breadcrumbs navigation" role="navigation">
<ul class="wy-breadcrumbs">
<li><a class="icon icon-home" href="index.html"></a> »</li>
<li>API Reference</li>
<li class="wy-breadcrumbs-aside">
<a href="_sources/api.rst.txt" rel="nofollow"> View page source</a>
</li>
</ul>
<hr/>
</div>
<div class="document" itemscope="itemscope" itemtype="http://schema.org/Article" role="main">
<div itemprop="articleBody">
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="api-reference">
<h1>API Reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dataframe">
<h2>DataFrame<a class="headerlink" href="#dataframe" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.dataframe.DataFrame">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.dataframe.</code><code class="sig-name descname">DataFrame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame" title="Permalink to this definition">¶</a></dt>
<dd><p>A GPU Dataframe object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array-like, Iterable, dict, or DataFrame.</span></dt><dd><p>Dict can contain Series, arrays, constants, or list-like objects.</p>
</dd>
<dt><strong>index</strong><span class="classifier">Index or array-like</span></dt><dd><p>Index to use for resulting frame. Will default to
RangeIndex if no indexing information part of input data and
no index provided.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">Index or array-like</span></dt><dd><p>Column labels to use for resulting frame.
Will default to RangeIndex (0, 1, 2, …, n) if no column
labels are provided.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">dtype, default None</span></dt><dd><p>Data type to force. Only a single dtype is allowed.
If None, infer.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Build dataframe with <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
<p>Build DataFrame via dict of columns:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">timedelta</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">t0</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">'2018-10-07 12:00:00'</span><span class="p">,</span> <span class="s1">'%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'id'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s1">'datetimes'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[(</span><span class="n">t0</span><span class="o">+</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">    id                datetimes</span>
<span class="go">0    0  2018-10-07T12:00:00.000</span>
<span class="go">1    1  2018-10-07T12:00:01.000</span>
<span class="go">2    2  2018-10-07T12:00:02.000</span>
<span class="go">3    3  2018-10-07T12:00:03.000</span>
<span class="go">4    4  2018-10-07T12:00:04.000</span>
</pre></div>
</div>
<p>Build DataFrame via list of rows as tuples:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span>
<span class="go">    (5, "cats", "jump", np.nan),</span>
<span class="go">    (2, "dogs", "dig", 7.5),</span>
<span class="go">    (3, "cows", "moo", -2.1, "occasionally"),</span>
<span class="go">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">0     1     2     3             4</span>
<span class="go">0  5  cats  jump  null          None</span>
<span class="go">1  2  dogs   dig   7.5          None</span>
<span class="go">2  3  cows   moo  -2.1  occasionally</span>
</pre></div>
</div>
<p>Convert from a Pandas DataFrame:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span><span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">a b</span>
<span class="go">0 0 0.1</span>
<span class="go">1 1 0.2</span>
<span class="go">2 2 nan</span>
<span class="go">3 3 0.3</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.T" title="cudf.core.dataframe.DataFrame.T"><code class="xref py py-obj docutils literal notranslate"><span class="pre">T</span></code></a></dt><dd><p>Transpose index and columns.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.at" title="cudf.core.dataframe.DataFrame.at"><code class="xref py py-obj docutils literal notranslate"><span class="pre">at</span></code></a></dt><dd><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.loc</span></code>; provided for compatibility with Pandas.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.columns" title="cudf.core.dataframe.DataFrame.columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">columns</span></code></a></dt><dd><p>Returns a tuple of columns</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.dtypes" title="cudf.core.dataframe.DataFrame.dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtypes</span></code></a></dt><dd><p>Return the dtypes in this object.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.empty" title="cudf.core.dataframe.DataFrame.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Indicator whether DataFrame is empty.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iat" title="cudf.core.dataframe.DataFrame.iat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iat</span></code></a></dt><dd><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code>; provided for compatibility with Pandas.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iloc" title="cudf.core.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>Selecting rows and column by position.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.index" title="cudf.core.dataframe.DataFrame.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>Returns the index of the DataFrame</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.loc" title="cudf.core.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt><dd><p>Selecting rows and columns by label or boolean mask.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.ndim" title="cudf.core.dataframe.DataFrame.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.shape" title="cudf.core.dataframe.DataFrame.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.values" title="cudf.core.dataframe.DataFrame.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a></dt><dd><p>Return a CuPy representation of the DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.add" title="cudf.core.dataframe.DataFrame.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Addition of dataframe and other, element-wise (binary operator <cite>add</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.add_column" title="cudf.core.dataframe.DataFrame.add_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_column</span></code></a>(self, name, data[, forceindex])</p></td>
<td><p>Add a column</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.all" title="cudf.core.dataframe.DataFrame.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a>(self[, axis, bool_only, skipna, level])</p></td>
<td><p>Return whether all elements are True in DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.any" title="cudf.core.dataframe.DataFrame.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>(self[, axis, bool_only, skipna, level])</p></td>
<td><p>Return whether any elements is True in DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.apply_chunks" title="cudf.core.dataframe.DataFrame.apply_chunks"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_chunks</span></code></a>(self, func, incols, outcols[, …])</p></td>
<td><p>Transform user-specified chunks using the user-provided function.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.apply_rows" title="cudf.core.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_rows</span></code></a>(self, func, incols, outcols, kwargs)</p></td>
<td><p>Apply a row-wise user defined function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.argsort" title="cudf.core.dataframe.DataFrame.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>(self[, ascending, na_position])</p></td>
<td><p>Sort by the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.as_gpu_matrix" title="cudf.core.dataframe.DataFrame.as_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_gpu_matrix</span></code></a>(self[, columns, order])</p></td>
<td><p>Convert to a matrix in device memory.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.as_matrix" title="cudf.core.dataframe.DataFrame.as_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_matrix</span></code></a>(self[, columns])</p></td>
<td><p>Convert to a matrix in host memory.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.assign" title="cudf.core.dataframe.DataFrame.assign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">assign</span></code></a>(self, **kwargs)</p></td>
<td><p>Assign columns to DataFrame from keyword arguments.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.astype" title="cudf.core.dataframe.DataFrame.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(self, dtype[, copy, errors])</p></td>
<td><p>Cast the DataFrame to the given dtype</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.copy" title="cudf.core.dataframe.DataFrame.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self[, deep])</p></td>
<td><p>Returns a copy of this dataframe</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.corr" title="cudf.core.dataframe.DataFrame.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">corr</span></code></a>(self)</p></td>
<td><p>Compute the correlation matrix of a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.count" title="cudf.core.dataframe.DataFrame.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(self[, axis, level, numeric_only])</p></td>
<td><p>Count <code class="docutils literal notranslate"><span class="pre">non-NA</span></code> cells for each column or row.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.cov" title="cudf.core.dataframe.DataFrame.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cov</span></code></a>(self, **kwargs)</p></td>
<td><p>Compute the covariance matrix of a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.cummax" title="cudf.core.dataframe.DataFrame.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummax</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative maximum of the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.cummin" title="cudf.core.dataframe.DataFrame.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummin</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative minimum of the DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.cumprod" title="cudf.core.dataframe.DataFrame.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative product of the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.cumsum" title="cudf.core.dataframe.DataFrame.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative sum of the DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.describe" title="cudf.core.dataframe.DataFrame.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></a>(self[, percentiles, include, exclude])</p></td>
<td><p>Compute summary statistics of a DataFrame’s columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.div" title="cudf.core.dataframe.DataFrame.div"><code class="xref py py-obj docutils literal notranslate"><span class="pre">div</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.drop" title="cudf.core.dataframe.DataFrame.drop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop</span></code></a>(self[, labels, axis, columns, errors, …])</p></td>
<td><p>Drop column(s)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.drop_column" title="cudf.core.dataframe.DataFrame.drop_column"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_column</span></code></a>(self, name)</p></td>
<td><p>Drop a column by <em>name</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.drop_duplicates" title="cudf.core.dataframe.DataFrame.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_duplicates</span></code></a>(self[, subset, keep, …])</p></td>
<td><p>Return DataFrame with duplicate rows removed, optionally only considering certain subset of columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.equals" title="cudf.core.dataframe.DataFrame.equals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equals</span></code></a>(self, other)</p></td>
<td><p>Test whether two objects contain the same elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.fillna" title="cudf.core.dataframe.DataFrame.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(self, value[, method, axis, inplace, …])</p></td>
<td><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.floordiv" title="cudf.core.dataframe.DataFrame.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floordiv</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Integer division of dataframe and other, element-wise (binary operator <cite>floordiv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_arrow" title="cudf.core.dataframe.DataFrame.from_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_arrow</span></code></a>(table)</p></td>
<td><p>Convert from a PyArrow Table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_gpu_matrix" title="cudf.core.dataframe.DataFrame.from_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_gpu_matrix</span></code></a>(data[, index, columns, …])</p></td>
<td><p>Convert from a numba gpu ndarray.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_pandas" title="cudf.core.dataframe.DataFrame.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(dataframe[, nan_as_null])</p></td>
<td><p>Convert from a Pandas DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.from_records" title="cudf.core.dataframe.DataFrame.from_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_records</span></code></a>(data[, index, columns, nan_as_null])</p></td>
<td><p>Convert structured or record ndarray to DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.groupby" title="cudf.core.dataframe.DataFrame.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a>(self[, by, axis, level, as_index, …])</p></td>
<td><p>Group DataFrame using a mapper or by a Series of columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.hash_columns" title="cudf.core.dataframe.DataFrame.hash_columns"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_columns</span></code></a>(self[, columns])</p></td>
<td><p>Hash the given <em>columns</em> and return a new device array</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.head" title="cudf.core.dataframe.DataFrame.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">head</span></code></a>(self[, n])</p></td>
<td><p>Returns the first n rows as a new DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.info" title="cudf.core.dataframe.DataFrame.info"><code class="xref py py-obj docutils literal notranslate"><span class="pre">info</span></code></a>(self[, verbose, buf, max_cols, …])</p></td>
<td><p>Print a concise summary of a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.insert" title="cudf.core.dataframe.DataFrame.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(self, loc, name, value)</p></td>
<td><p>Add a column to DataFrame at the index specified by loc.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.isin" title="cudf.core.dataframe.DataFrame.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isin</span></code></a>(self, values)</p></td>
<td><p>Whether each element in the DataFrame is contained in values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iteritems" title="cudf.core.dataframe.DataFrame.iteritems"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iteritems</span></code></a>(self)</p></td>
<td><p>Iterate over column names and series pairs</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.join" title="cudf.core.dataframe.DataFrame.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(self, other[, on, how, lsuffix, …])</p></td>
<td><p>Join columns with other DataFrame on index or on a key column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.kurt" title="cudf.core.dataframe.DataFrame.kurt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurt</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return Fisher’s unbiased kurtosis of a sample.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.kurtosis" title="cudf.core.dataframe.DataFrame.kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis</span></code></a>(self[, axis, skipna, level, …])</p></td>
<td><p>Return Fisher’s unbiased kurtosis of a sample.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.label_encoding" title="cudf.core.dataframe.DataFrame.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(self, column, prefix, cats[, …])</p></td>
<td><p>Encode labels in a column with label encoding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.max" title="cudf.core.dataframe.DataFrame.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return the maximum of the values in the DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.mean" title="cudf.core.dataframe.DataFrame.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return the mean of the values for the requested axis.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.melt" title="cudf.core.dataframe.DataFrame.melt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">melt</span></code></a>(self, **kwargs)</p></td>
<td><p>Unpivots a DataFrame from wide format to long format, optionally leaving identifier variables set.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.memory_usage" title="cudf.core.dataframe.DataFrame.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_usage</span></code></a>(self[, index, deep])</p></td>
<td><p>Return the memory usage of each column in bytes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.merge" title="cudf.core.dataframe.DataFrame.merge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">merge</span></code></a>(self, right[, on, left_on, right_on, …])</p></td>
<td><p>Merge GPU DataFrame objects by performing a database-style join operation by columns or indexes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.min" title="cudf.core.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return the minimum of the values in the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.mod" title="cudf.core.dataframe.DataFrame.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mod</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Modulo division of dataframe and other, element-wise (binary operator <cite>mod</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.mul" title="cudf.core.dataframe.DataFrame.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mul</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Multiplication of dataframe and other, element-wise (binary operator <cite>mul</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.nans_to_nulls" title="cudf.core.dataframe.DataFrame.nans_to_nulls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nans_to_nulls</span></code></a>(self)</p></td>
<td><p>Convert nans (if any) to nulls.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.nlargest" title="cudf.core.dataframe.DataFrame.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(self, n, columns[, keep])</p></td>
<td><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.nsmallest" title="cudf.core.dataframe.DataFrame.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(self, n, columns[, keep])</p></td>
<td><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.one_hot_encoding" title="cudf.core.dataframe.DataFrame.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(self, column, prefix, cats)</p></td>
<td><p>Expand a column with one-hot-encoding.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.partition_by_hash" title="cudf.core.dataframe.DataFrame.partition_by_hash"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition_by_hash</span></code></a>(self, columns, nparts[, …])</p></td>
<td><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.pop" title="cudf.core.dataframe.DataFrame.pop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pop</span></code></a>(self, item)</p></td>
<td><p>Return a column and drop it from the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.pow" title="cudf.core.dataframe.DataFrame.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pow</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Exponential power of dataframe and other, element-wise (binary operator <cite>pow</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.prod" title="cudf.core.dataframe.DataFrame.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return product of the values in the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.product" title="cudf.core.dataframe.DataFrame.product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return product of the values in the DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.quantile" title="cudf.core.dataframe.DataFrame.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(self[, q, axis, numeric_only, …])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.quantiles" title="cudf.core.dataframe.DataFrame.quantiles"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantiles</span></code></a>(self[, q, interpolation])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.query" title="cudf.core.dataframe.DataFrame.query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">query</span></code></a>(self, expr[, local_dict])</p></td>
<td><p>Query with a boolean expression using Numba to compile a GPU kernel.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.radd" title="cudf.core.dataframe.DataFrame.radd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radd</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Addition of dataframe and other, element-wise (binary operator <cite>radd</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rdiv" title="cudf.core.dataframe.DataFrame.rdiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rdiv</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>rtruediv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.reindex" title="cudf.core.dataframe.DataFrame.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(self[, labels, axis, index, …])</p></td>
<td><p>Return a new DataFrame whose axes conform to a new index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rename" title="cudf.core.dataframe.DataFrame.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self[, mapper, index, columns, axis, …])</p></td>
<td><p>Alter column and index labels.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.replace" title="cudf.core.dataframe.DataFrame.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self[, to_replace, value, inplace, …])</p></td>
<td><p>Replace values given in <em>to_replace</em> with <em>replacement</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.reset_index" title="cudf.core.dataframe.DataFrame.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_index</span></code></a>(self[, level, drop, inplace, …])</p></td>
<td><p>Reset the index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rfloordiv" title="cudf.core.dataframe.DataFrame.rfloordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfloordiv</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Integer division of dataframe and other, element-wise (binary operator <cite>rfloordiv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rmod" title="cudf.core.dataframe.DataFrame.rmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmod</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Modulo division of dataframe and other, element-wise (binary operator <cite>rmod</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rmul" title="cudf.core.dataframe.DataFrame.rmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmul</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Multiplication of dataframe and other, element-wise (binary operator <cite>rmul</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rolling" title="cudf.core.dataframe.DataFrame.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling</span></code></a>(self, window[, min_periods, center, …])</p></td>
<td><p>Rolling window calculations.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rpow" title="cudf.core.dataframe.DataFrame.rpow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpow</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Exponential power of dataframe and other, element-wise (binary operator <cite>pow</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rsub" title="cudf.core.dataframe.DataFrame.rsub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsub</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Subtraction of dataframe and other, element-wise (binary operator <cite>rsub</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.rtruediv" title="cudf.core.dataframe.DataFrame.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtruediv</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>rtruediv</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.select_dtypes" title="cudf.core.dataframe.DataFrame.select_dtypes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">select_dtypes</span></code></a>(self[, include, exclude])</p></td>
<td><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.set_index" title="cudf.core.dataframe.DataFrame.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(self, index[, drop])</p></td>
<td><p>Return a new DataFrame with a new index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.skew" title="cudf.core.dataframe.DataFrame.skew"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skew</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return unbiased Fisher-Pearson skew of a sample.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.sort_index" title="cudf.core.dataframe.DataFrame.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>(self[, axis, level, ascending, …])</p></td>
<td><p>Sort object by labels (along an axis).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.sort_values" title="cudf.core.dataframe.DataFrame.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(self, by[, axis, ascending, …])</p></td>
<td><p>Sort by the values row-wise.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.stack" title="cudf.core.dataframe.DataFrame.stack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stack</span></code></a>(self[, level, dropna])</p></td>
<td><p>Stack the prescribed level(s) from columns to index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.std" title="cudf.core.dataframe.DataFrame.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(self[, axis, skipna, level, ddof, …])</p></td>
<td><p>Return sample standard deviation of the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.sub" title="cudf.core.dataframe.DataFrame.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Subtraction of dataframe and other, element-wise (binary operator <cite>sub</cite>).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.sum" title="cudf.core.dataframe.DataFrame.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return sum of the values in the DataFrame.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.tail" title="cudf.core.dataframe.DataFrame.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>(self[, n])</p></td>
<td><p>Returns the last n rows as a new DataFrame</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.take" title="cudf.core.dataframe.DataFrame.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(self, positions[, keep_index])</p></td>
<td><p>Return a new DataFrame containing the rows specified by <em>positions</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_arrow" title="cudf.core.dataframe.DataFrame.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>(self[, preserve_index])</p></td>
<td><p>Convert to a PyArrow Table.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_csv" title="cudf.core.dataframe.DataFrame.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_csv</span></code></a>(self[, path, sep, na_rep, columns, …])</p></td>
<td><p>Write a dataframe to csv file format.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_dlpack" title="cudf.core.dataframe.DataFrame.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_feather" title="cudf.core.dataframe.DataFrame.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_feather</span></code></a>(self, path, *args, **kwargs)</p></td>
<td><p>Write a DataFrame to the feather format.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_gpu_matrix" title="cudf.core.dataframe.DataFrame.to_gpu_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_matrix</span></code></a>(self)</p></td>
<td><p>Convert to a numba gpu ndarray</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_hdf" title="cudf.core.dataframe.DataFrame.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(self, path_or_buf, key, *args, **kwargs)</p></td>
<td><p>Write the contained data to an HDF5 file using HDFStore.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_json" title="cudf.core.dataframe.DataFrame.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(self[, path_or_buf])</p></td>
<td><p>Convert the cuDF object to a JSON string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_orc" title="cudf.core.dataframe.DataFrame.to_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_orc</span></code></a>(self, fname[, compression])</p></td>
<td><p>Write a DataFrame to the ORC format.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_pandas" title="cudf.core.dataframe.DataFrame.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_parquet" title="cudf.core.dataframe.DataFrame.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_parquet</span></code></a>(self, path, *args, **kwargs)</p></td>
<td><p>Write a DataFrame to the parquet format.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_records" title="cudf.core.dataframe.DataFrame.to_records"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_records</span></code></a>(self[, index])</p></td>
<td><p>Convert to a numpy recarray</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.to_string" title="cudf.core.dataframe.DataFrame.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>(self)</p></td>
<td><p>Convert to string</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.transpose" title="cudf.core.dataframe.DataFrame.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(self)</p></td>
<td><p>Transpose index and columns.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.truediv" title="cudf.core.dataframe.DataFrame.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">truediv</span></code></a>(self, other[, axis, level, fill_value])</p></td>
<td><p>Get Floating division of dataframe and other, element-wise (binary operator <cite>truediv</cite>).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.dataframe.DataFrame.var" title="cudf.core.dataframe.DataFrame.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>(self[, axis, skipna, level, ddof, …])</p></td>
<td><p>Return unbiased variance of the DataFrame.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.T">
<em class="property">property </em><code class="sig-name descname">T</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.T" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose index and columns.</p>
<p>Reflect the DataFrame over its main diagonal by writing rows
as columns and vice-versa. The property T is an accessor to
the method transpose().</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>The transposed DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Addition of dataframe and other, element-wise (binary
operator <cite>add</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">+</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>radd</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.add_column">
<code class="sig-name descname">add_column</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">forceindex</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.add_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str</span></dt><dd><p>Name of column to be added.</p>
</dd>
<dt><strong>data</strong><span class="classifier">Series, array-like</span></dt><dd><p>Values to be added.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">bool_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether all elements are True in DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and
skipna is True, then the result will be True, as for an
empty row/column.
If skipna is False, then NA are treated as True, because
these are not equal to zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>bool_only</cite>, <cite>level</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">a     True</span>
<span class="go">b    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">bool_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether any elements is True in DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and
skipna is True, then the result will be False, as for an
empty row/column.
If skipna is False, then NA are treated as True, because
these are not equal to zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>bool_only</cite>, <cite>level</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
<span class="go">a    True</span>
<span class="go">b    True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.apply_chunks">
<code class="sig-name descname">apply_chunks</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">incols</span></em>, <em class="sig-param"><span class="n">outcols</span></em>, <em class="sig-param"><span class="n">kwargs</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">pessimistic_nulls</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">chunks</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">blkct</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tpb</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.apply_chunks" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform user-specified chunks using the user-provided function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>The source dataframe.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list or dict</strong></dt><dd><p>A list of names of input columns that match the function arguments.
Or, a dictionary mapping input column names to their corresponding
function arguments such as {‘col1’: ‘arg1’}.</p>
</dd>
<dt><strong>outcols: dict</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>pessimistic_nulls</strong><span class="classifier">bool</span></dt><dd><p>Whether or not apply_rows output should be null when any corresponding
input is null. If False, all outputs will be non-null, but will be the
result of applying func against the underlying column data, which
may be garbage.</p>
</dd>
<dt><strong>chunks</strong><span class="classifier">int or Series-like</span></dt><dd><p>If it is an <code class="docutils literal notranslate"><span class="pre">int</span></code>, it is the chunksize.
If it is an array, it contains integer offset for the start of each chunk.
The span of a chunk for chunk i-th is <code class="docutils literal notranslate"><span class="pre">data[chunks[i]</span> <span class="pre">:</span> <span class="pre">chunks[i</span> <span class="pre">+</span> <span class="pre">1]]</span></code>
for any <code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">+</span> <span class="pre">1</span> <span class="pre">&lt;</span> <span class="pre">chunks.size</span></code>; or, <code class="docutils literal notranslate"><span class="pre">data[chunks[i]:]</span></code> for the
<code class="docutils literal notranslate"><span class="pre">i</span> <span class="pre">==</span> <span class="pre">len(chunks)</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
</dd>
<dt><strong>tpb</strong><span class="classifier">int; optional</span></dt><dd><p>The threads-per-block for the underlying kernel.
If not specified (Default), uses Numba <code class="docutils literal notranslate"><span class="pre">.forall(...)</span></code> built-in to query
the CUDA Driver API to determine optimal kernel launch configuration.
Specify 1 to emulate serial execution for each chunk.  It is a good
starting point but inefficient.
Its maximum possible value is limited by the available CUDA GPU resources.</p>
</dd>
<dt><strong>blkct</strong><span class="classifier">int; optional</span></dt><dd><p>The number of blocks for the underlying kernel.
If not specified (Default) and <code class="docutils literal notranslate"><span class="pre">tpb</span></code> is not specified (Default), uses
Numba <code class="docutils literal notranslate"><span class="pre">.forall(...)</span></code> built-in to query the CUDA Driver API to determine
optimal kernel launch configuration.
If not specified (Default) and <code class="docutils literal notranslate"><span class="pre">tpb</span></code> is specified, uses <code class="docutils literal notranslate"><span class="pre">chunks</span></code> as the
number of blocks.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.apply_rows" title="cudf.core.dataframe.DataFrame.apply_rows"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.apply_rows</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>For <code class="docutils literal notranslate"><span class="pre">tpb</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">func</span></code> is executed by <code class="docutils literal notranslate"><span class="pre">tpb</span></code> number of threads
concurrently.  To access the thread id and count,
use <code class="docutils literal notranslate"><span class="pre">numba.cuda.threadIdx.x</span></code> and <code class="docutils literal notranslate"><span class="pre">numba.cuda.blockDim.x</span></code>,
respectively (See <a class="reference external" href="http://numba.pydata.org/numba-doc/latest/cuda/kernels.html">numba CUDA kernel documentation</a>).</p>
<p>In the example below, the <em>kernel</em> is invoked concurrently on each
specified chunk. The <em>kernel</em> computes the corresponding output
for the chunk.</p>
<p>By looping over the range
<code class="docutils literal notranslate"><span class="pre">range(cuda.threadIdx.x,</span> <span class="pre">in1.size,</span> <span class="pre">cuda.blockDim.x)</span></code>, the <em>kernel</em>
function can be used with any <em>tpb</em> in an efficient manner.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@cuda</span><span class="o">.</span><span class="n">jit</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">):</span>
<span class="gp">... </span>     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">in1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>         <span class="n">x</span> <span class="o">=</span> <span class="n">in1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">y</span> <span class="o">=</span> <span class="n">in2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">z</span> <span class="o">=</span> <span class="n">in3</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="gp">... </span>         <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.apply_rows">
<code class="sig-name descname">apply_rows</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">func</span></em>, <em class="sig-param"><span class="n">incols</span></em>, <em class="sig-param"><span class="n">outcols</span></em>, <em class="sig-param"><span class="n">kwargs</span></em>, <em class="sig-param"><span class="n">pessimistic_nulls</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">cache_key</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.apply_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a row-wise user defined function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>The source dataframe.</p>
</dd>
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list or dict</strong></dt><dd><p>A list of names of input columns that match the function arguments.
Or, a dictionary mapping input column names to their corresponding
function arguments such as {‘col1’: ‘arg1’}.</p>
</dd>
<dt><strong>outcols: dict</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs: dict</strong></dt><dd><p>name-value of extra arguments.  These values are passed
directly into the function.</p>
</dd>
<dt><strong>pessimistic_nulls</strong><span class="classifier">bool</span></dt><dd><p>Whether or not apply_rows output should be null when any corresponding
input is null. If False, all outputs will be non-null, but will be the
result of applying func against the underlying column data, which
may be garbage.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>The user function should loop over the columns and set the output for
each row. Loop execution order is arbitrary, so each iteration of
the loop <strong>MUST</strong> be independent of each other.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">func</span></code> is invoked, the array args corresponding to the
input/output are strided so as to improve GPU parallelism.
The loop in the function resembles serial code, but executes
concurrently in multiple threads.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nelem</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'in1'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'in2'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'in3'</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nelem</span><span class="p">)</span>
</pre></div>
</div>
<p>Define input columns for the kernel</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">in1</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'in1'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in2</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'in2'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">in3</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'in3'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">,</span> <span class="n">kwarg1</span><span class="p">,</span> <span class="n">kwarg2</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">in1</span><span class="p">,</span> <span class="n">in2</span><span class="p">,</span> <span class="n">in3</span><span class="p">)):</span>
<span class="gp">... </span>        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwarg2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">y</span>
<span class="gp">... </span>        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">kwarg1</span> <span class="o">*</span> <span class="n">z</span>
</pre></div>
</div>
<p>Call <code class="docutils literal notranslate"><span class="pre">.apply_rows</span></code> with the name of the input columns, the name and
dtype of the output columns, and, optionally, a dict of extra
arguments.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">apply_rows</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span>
<span class="gp">... </span>              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">'in1'</span><span class="p">,</span> <span class="s1">'in2'</span><span class="p">,</span> <span class="s1">'in3'</span><span class="p">],</span>
<span class="gp">... </span>              <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">out1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">out2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
<span class="gp">... </span>              <span class="n">kwargs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">kwarg1</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">kwarg2</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
<span class="go">   in1  in2  in3 out1 out2</span>
<span class="go">0    0    0    0  0.0  0.0</span>
<span class="go">1    1    1    1  1.0 -2.0</span>
<span class="go">2    2    2    2  2.0 -4.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.argsort">
<code class="sig-name descname">argsort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">na_position</span><span class="o">=</span><span class="default_value">'last'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool or list of bool, default True</span></dt><dd><p>If True, sort values in ascending order, otherwise descending.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’ or ‘last’}, default ‘last’</span></dt><dd><p>Argument ‘first’ puts NaNs at the beginning, ‘last’ puts NaNs
at the end.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out_column_inds</strong><span class="classifier">cuDF Column of indices sorted based on input</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:</p>
<ul class="simple">
<li><p>Support axis=’index’ only.</p></li>
<li><p>Not supporting: inplace, kind</p></li>
<li><p>Ascending can be a list of bools to control per column</p></li>
</ul>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.as_gpu_matrix">
<code class="sig-name descname">as_gpu_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">order</span><span class="o">=</span><span class="default_value">'F'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.as_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in device memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
<dt><strong>order</strong><span class="classifier">‘F’ or ‘C’</span></dt><dd><p>Optional argument to determine whether to return a column major
(Fortran) matrix or a row major (C) matrix.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A (nrow x ncol) numba device ndarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.as_matrix">
<code class="sig-name descname">as_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.as_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a matrix in host memory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>List of a column names to be extracted.  The order is preserved.
If None is specified, all columns are used.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A (nrow x ncol) numpy ndarray in “F” order.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.assign">
<code class="sig-name descname">assign</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign columns to DataFrame from keyword arguments.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">b</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">0  0  3</span>
<span class="go">1  1  4</span>
<span class="go">2  2  5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'raise'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast the DataFrame to the given dtype</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data type, or dict of column name -&gt; data type</span></dt><dd><p>Use a numpy.dtype or Python type to cast entire DataFrame object to
the same type. Alternatively, use <code class="docutils literal notranslate"><span class="pre">{col:</span> <span class="pre">dtype,</span> <span class="pre">...}</span></code>, where col
is a column label and dtype is a numpy.dtype or Python type
to cast one or more of the DataFrame’s columns to
column-specific types.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default False</span></dt><dd><p>Return a deep-copy when <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>. Note by default
<code class="docutils literal notranslate"><span class="pre">copy=False</span></code> setting is used and hence changes to
values then may propagate to other cudf objects.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘raise’, ‘ignore’, ‘warn’}, default ‘raise’</span></dt><dd><p>Control raising of exceptions on invalid data for provided dtype.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">raise</span></code> : allow exceptions to be raised</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore</span></code> : suppress exceptions. On error return original
object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warn</span></code> : prints last exceptions as warnings and
return original object.</p></li>
</ul>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">extra arguments to pass on to the constructor</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>casted</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.at">
<em class="property">property </em><code class="sig-name descname">at</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.at" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.loc</span></code>; provided for compatibility with Pandas.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.columns">
<em class="property">property </em><code class="sig-name descname">columns</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple of columns</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a copy of this dataframe</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep: bool</strong></dt><dd><p>Make a full copy of Series columns and Index at the GPU level, or
create a new allocation with references.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the correlation matrix of a DataFrame.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count <code class="docutils literal notranslate"><span class="pre">non-NA</span></code> cells for each column or row.</p>
<p>The values <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, <code class="docutils literal notranslate"><span class="pre">NaT</span></code> are considered <code class="docutils literal notranslate"><span class="pre">NA</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series</dt><dd><p>For each column/row the number of non-NA/null entries.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"Person"</span><span class="p">:</span>
<span class="go">           ["John", "Myla", "Lewis", "John", "Myla"],</span>
<span class="go">           "Age": [24., np.nan, 21., 33, 26],</span>
<span class="go">           "Single": [False, True, True, True, False]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="go">Person    5</span>
<span class="go">Age       4</span>
<span class="go">Single    5</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the covariance matrix of a DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>**kwargs</strong></dt><dd><p>Keyword arguments to be passed to cupy.cov</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>cov</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.cummax">
<code class="sig-name descname">cummax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative maximum of the DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummax</span><span class="p">()</span>
<span class="go">   a   b</span>
<span class="go">0  1   7</span>
<span class="go">1  2   8</span>
<span class="go">2  3   9</span>
<span class="go">3  4  10</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.cummin">
<code class="sig-name descname">cummin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative minimum of the DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">cummin</span><span class="p">()</span>
<span class="go">   a  b</span>
<span class="go">0  1  7</span>
<span class="go">1  1  7</span>
<span class="go">2  1  7</span>
<span class="go">3  1  7</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative product of the DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span>
<span class="go">    a     b</span>
<span class="go">0   1     7</span>
<span class="go">1   2    56</span>
<span class="go">2   6   504</span>
<span class="go">3  24  5040</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative sum of the DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
<span class="go">    a   b</span>
<span class="go">0   1   7</span>
<span class="go">1   3  15</span>
<span class="go">2   6  24</span>
<span class="go">3  10  34</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.describe">
<code class="sig-name descname">describe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">percentiles</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">include</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute summary statistics of a DataFrame’s columns. For numeric
data, the output includes the minimum, maximum, mean, median,
standard deviation, and various quantiles. For object data, the output
includes the count, number of unique values, the most common value, and
the number of occurrences of the most common value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like, optional</span></dt><dd><p>The percentiles used to generate the output summary statistics.
If None, the default percentiles used are the 25th, 50th and 75th.
Values should be within the interval [0, 1].</p>
</dd>
<dt><strong>include: str, list-like, optional</strong></dt><dd><p>The dtypes to be included in the output summary statistics. Columns
of dtypes not included in this list will not be part of the output.
If include=’all’, all dtypes are included. Default of None includes
all numeric columns.</p>
</dd>
<dt><strong>exclude: str, list-like, optional</strong></dt><dd><p>The dtypes to be excluded from the output summary statistics.
Columns of dtypes included in this list will not be part of the
output. Default of None excludes no columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output_frame</strong><span class="classifier">DataFrame</span></dt><dd><p>Summary statistics of relevant columns in the original dataframe.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">Series</span></code> containing numeric values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">   stats   values</span>
<span class="go">0  count     10.0</span>
<span class="go">1   mean      5.5</span>
<span class="go">2    std  3.02765</span>
<span class="go">3    min      1.0</span>
<span class="go">4    25%      2.5</span>
<span class="go">5    50%      5.5</span>
<span class="go">6    75%      7.5</span>
<span class="go">7    max     10.0</span>
</pre></div>
</div>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. By default all numeric fields
are returned.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'b'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'c'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'d'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'d'</span><span class="p">]</span> <span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">'d'</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'float32'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">   stats    a    b    d</span>
<span class="go">0  count  3.0  3.0  3.0</span>
<span class="go">1   mean  2.0  2.0  2.0</span>
<span class="go">2    std  1.0  1.0  1.0</span>
<span class="go">3    min  1.0  1.0  1.0</span>
<span class="go">4    25%  1.5  1.5  1.5</span>
<span class="go">5    50%  1.5  1.5  1.5</span>
<span class="go">6    75%  2.5  2.5  2.5</span>
<span class="go">7    max  3.0  3.0  3.0</span>
</pre></div>
</div>
<p>Using the <code class="docutils literal notranslate"><span class="pre">include</span></code> keyword to describe only specific dtypes.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'b'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'c'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'x'</span><span class="p">,</span> <span class="s1">'y'</span><span class="p">,</span> <span class="s1">'z'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">gdf</span><span class="o">.</span><span class="n">describe</span><span class="p">(</span><span class="n">include</span><span class="o">=</span><span class="s1">'int'</span><span class="p">))</span>
<span class="go">   stats    a</span>
<span class="go">0  count  3.0</span>
<span class="go">1   mean  2.0</span>
<span class="go">2    std  1.0</span>
<span class="go">3    min  1.0</span>
<span class="go">4    25%  1.5</span>
<span class="go">5    50%  1.5</span>
<span class="go">6    75%  2.5</span>
<span class="go">7    max  3.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.div">
<code class="sig-name descname">div</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.div" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary
operator <cite>truediv</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rtruediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">truediv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">/</span> <span class="mi">10</span>
<span class="go">            angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.drop">
<code class="sig-name descname">drop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'raise'</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.drop" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop column(s)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">str or sequence of strings</span></dt><dd><p>Name of column(s) to be dropped.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>Only axis=1 is currently supported.</p>
</dd>
<dt><strong>columns</strong></dt><dd><p>array of column names, the same as using labels and axis=1</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘ignore’, ‘raise’}, default ‘raise’</span></dt><dd><p>This parameter is currently ignored.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, do operation inplace and return <cite>self</cite>.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A dataframe without dropped column(s)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_new</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">'val'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_new</span><span class="p">)</span>
<span class="go">   key</span>
<span class="go">0    0</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.drop_column">
<code class="sig-name descname">drop_column</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.drop_column" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop a column by <em>name</em></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.drop_duplicates">
<code class="sig-name descname">drop_duplicates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">subset</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">'first'</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.drop_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return DataFrame with duplicate rows removed, optionally only
considering certain subset of columns.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.dtypes">
<em class="property">property </em><code class="sig-name descname">dtypes</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the dtypes in this object.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.empty">
<em class="property">property </em><code class="sig-name descname">empty</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator whether DataFrame is empty.</p>
<p>True if DataFrame is entirely empty (no items), meaning any
of the axes are of length 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd><p>If DataFrame is empty, return True, if not return False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether two objects contain the same elements.
This function allows two Series or DataFrames to be compared against
each other to see if they have the same shape and elements. NaNs in
the same location are considered equal. The column headers do not
need to have the same type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or DataFrame</span></dt><dd><p>The other Series or DataFrame to be compared with the first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if all elements are the same in both objects, False
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">    1   2</span>
<span class="go">0  10  20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exactly_equal</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exactly_equal</span>
<span class="go">    1   2</span>
<span class="go">0  10  20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">exactly_equal</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">different_column_type</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="mf">1.0</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="mf">2.0</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">different_column_type</span>
<span class="go">   1.0  2.0</span>
<span class="go">0   10   20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">different_column_type</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.fillna">
<code class="sig-name descname">fillna</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar, Series-like or dict</span></dt><dd><p>Value to use to fill nulls. If Series-like, null values
are filled with values in corresponding indices.
A dict can be used to provide different values to fill nulls
in different columns.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd><p>Copy with nulls filled.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  4  5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">fillna</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">:</span> <span class="mi">4</span><span class="p">})</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
<span class="go">2  3  5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.floordiv">
<code class="sig-name descname">floordiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.floordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Integer division of dataframe and other, element-wise (binary
operator <cite>floordiv</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">//</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rfloordiv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">floordiv</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0      180</span>
<span class="go">triangle        1       90</span>
<span class="go">rectangle       2      180</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">//</span> <span class="mi">2</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0      180</span>
<span class="go">triangle        1       90</span>
<span class="go">rectangle       2      180</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.from_arrow">
<em class="property">classmethod </em><code class="sig-name descname">from_arrow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">table</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a PyArrow Table.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>table</strong><span class="classifier">PyArrow Table Object</span></dt><dd><p>PyArrow Table Object which has to be converted to cudf DataFrame.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Does not support automatically setting index column(s) similar
to how <code class="docutils literal notranslate"><span class="pre">to_pandas</span></code> works for PyArrow Tables.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">])]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">batch</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">RecordBatch</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">[</span><span class="s1">'f0'</span><span class="p">,</span> <span class="s1">'f1'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">table</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">from_batches</span><span class="p">([</span><span class="n">batch</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_arrow</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
<span class="go">    f0  f1</span>
<span class="go">0   1   4</span>
<span class="go">1   2   5</span>
<span class="go">2   3   6</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.from_gpu_matrix">
<em class="property">classmethod </em><code class="sig-name descname">from_gpu_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nan_as_null</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a numba gpu ndarray.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numba gpu ndarray</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">str, Index</span></dt><dd><p>The name of the index column in <cite>data</cite> or an Index itself.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.from_pandas">
<em class="property">classmethod </em><code class="sig-name descname">from_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">dataframe</span></em>, <em class="sig-param"><span class="n">nan_as_null</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dataframe</strong><span class="classifier">Pandas DataFrame object</span></dt><dd><p>A Pandads DataFrame object which has to be converted
to cuDF DataFrame.</p>
</dd>
<dt><strong>nan_as_null</strong><span class="classifier">bool, Default True</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, converts <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values to <code class="docutils literal notranslate"><span class="pre">null</span></code> values.
If <code class="docutils literal notranslate"><span class="pre">False</span></code>, leaves <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values as is.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">0  0  1</span>
<span class="go">1  1  2</span>
<span class="go">2  3  4</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.from_records">
<em class="property">classmethod </em><code class="sig-name descname">from_records</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nan_as_null</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.from_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert structured or record ndarray to DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">numpy structured dtype or recarray of ndim=2</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">str, array-like</span></dt><dd><p>The name of the index column in <em>data</em>.
If None, the default index is used.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.groupby">
<code class="sig-name descname">groupby</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">by</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">as_index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">group_keys</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">squeeze</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">observed</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Group DataFrame using a mapper or by a Series of columns.</p>
<p>A groupby operation involves some combination of splitting the object,
applying a function, and combining the results. This can be used to
group large amounts of data and compute operations on these groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">mapping, function, label, or list of labels</span></dt><dd><p>Used to determine the groups for the groupby. If by is a
function, it’s called on each value of the object’s index.
If a dict or Series is passed, the Series or dict VALUES will
be used to determine the groups (the Series’ values are first
aligned; see .align() method). If a cupy array is passed, the
values are used as-is determine the groups. A label or list
of labels may be passed to group by the columns in self.
Notice that a tuple is interpreted as a (single) key.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, level name, or sequence of such, default None</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), group by a particular
level or levels.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool, default True</span></dt><dd><p>For aggregated output, return object with group labels as
the index. Only relevant for DataFrame input.
as_index=False is effectively “SQL-style” grouped output.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True</span></dt><dd><p>Sort group keys. Get better performance by turning this off.
Note this does not influence the order of observations within each
group. Groupby preserves the order of rows within each group.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), do not include the “null” group.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrameGroupBy</dt><dd><p>Returns a groupby object that contains information
about the groups.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'Animal'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'Falcon'</span><span class="p">,</span> <span class="s1">'Falcon'</span><span class="p">,</span>
<span class="gp">... </span>                              <span class="s1">'Parrot'</span><span class="p">,</span> <span class="s1">'Parrot'</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'Max Speed'</span><span class="p">:</span> <span class="p">[</span><span class="mf">380.</span><span class="p">,</span> <span class="mf">370.</span><span class="p">,</span> <span class="mf">24.</span><span class="p">,</span> <span class="mf">26.</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">Animal  Max Speed</span>
<span class="go">0  Falcon      380.0</span>
<span class="go">1  Falcon      370.0</span>
<span class="go">2  Parrot       24.0</span>
<span class="go">3  Parrot       26.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">'Animal'</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">        Max Speed</span>
<span class="go">Animal</span>
<span class="go">Falcon      375.0</span>
<span class="go">Parrot       25.0</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">arrays</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">'Falcon'</span><span class="p">,</span> <span class="s1">'Falcon'</span><span class="p">,</span> <span class="s1">'Parrot'</span><span class="p">,</span> <span class="s1">'Parrot'</span><span class="p">],</span>
<span class="go">['Captive', 'Wild', 'Captive', 'Wild']]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_arrays</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="p">(</span><span class="s1">'Animal'</span><span class="p">,</span> <span class="s1">'Type'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'Max Speed'</span><span class="p">:</span> <span class="p">[</span><span class="mf">390.</span><span class="p">,</span> <span class="mf">350.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">]},</span>
<span class="go">        index=index)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">                Max Speed</span>
<span class="go">Animal Type</span>
<span class="go">Falcon Captive      390.0</span>
<span class="go">    Wild         350.0</span>
<span class="go">Parrot Captive       30.0</span>
<span class="go">    Wild          20.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">        Max Speed</span>
<span class="go">Animal</span>
<span class="go">Falcon      370.0</span>
<span class="go">Parrot       25.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s2">"Type"</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">        Max Speed</span>
<span class="go">Type</span>
<span class="go">Captive      210.0</span>
<span class="go">Wild         185.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.hash_columns">
<code class="sig-name descname">hash_columns</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.hash_columns" title="Permalink to this definition">¶</a></dt>
<dd><p>Hash the given <em>columns</em> and return a new device array</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str; optional</span></dt><dd><p>Sequence of column names. If columns is <em>None</em> (unspecified),
all columns in the frame are used.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the first n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.iat">
<em class="property">property </em><code class="sig-name descname">iat</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.iat" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for <code class="docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code>; provided for compatibility with Pandas.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.iloc">
<em class="property">property </em><code class="sig-name descname">iloc</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Selecting rows and column by position.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.loc" title="cudf.core.dataframe.DataFrame.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.loc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>One notable difference from Pandas is when DataFrame is of
mixed types and result is expected to be a Series in case of Pandas.
cuDF will return a DataFrame as it doesn’t support mixed types
under Series yet.</p>
<p>Mixed dtype single row output as a dataframe (pandas results in Series)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">   a  b</span>
<span class="go">0  1  a</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="s1">'b'</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<span class="gp">... </span>                     <span class="s1">'c'</span><span class="p">:</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">)})</span>
</pre></div>
</div>
<p>Select a single row using an integer index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">a    1</span>
<span class="go">b    1</span>
<span class="go">c    1</span>
</pre></div>
</div>
<p>Select multiple rows using a list of integers.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">18</span><span class="p">]])</span>
<span class="go">      a    b    c</span>
<span class="go"> 0    0    0    0</span>
<span class="go"> 2    2    2    2</span>
<span class="go"> 9    9    9    9</span>
<span class="go">18   18   18   18</span>
</pre></div>
</div>
<p>Select rows using a slice.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
<span class="go">     a    b    c</span>
<span class="go">3    3    3    3</span>
<span class="go">5    5    5    5</span>
<span class="go">7    7    7    7</span>
<span class="go">9    9    9    9</span>
</pre></div>
</div>
<p>Select both rows and columns.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">1    1</span>
<span class="go">3    3</span>
<span class="go">5    5</span>
<span class="go">7    7</span>
<span class="go">Name: c, dtype: int64</span>
</pre></div>
</div>
<p>Setting values in a column using iloc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b  c</span>
<span class="go">0  0  0  0</span>
<span class="go">1  0  0  0</span>
<span class="go">2  0  0  0</span>
<span class="go">3  0  0  0</span>
<span class="go">4  4  4  4</span>
<span class="go">5  5  5  5</span>
<span class="go">6  6  6  6</span>
<span class="go">7  7  7  7</span>
<span class="go">8  8  8  8</span>
<span class="go">9  9  9  9</span>
<span class="go">[10 more rows]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of the DataFrame</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.info">
<code class="sig-name descname">info</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">verbose</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">buf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">max_cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">memory_usage</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">null_counts</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.info" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a concise summary of a DataFrame.</p>
<p>This method prints information about a DataFrame including
the index dtype and column dtypes, non-null values and memory usage.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>verbose</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to print the full summary. By default, the setting in
<code class="docutils literal notranslate"><span class="pre">pandas.options.display.max_info_columns</span></code> is followed.</p>
</dd>
<dt><strong>buf</strong><span class="classifier">writable buffer, defaults to sys.stdout</span></dt><dd><p>Where to send the output. By default, the output is printed to
sys.stdout. Pass a writable buffer if you need to further process
the output.</p>
</dd>
<dt><strong>max_cols</strong><span class="classifier">int, optional</span></dt><dd><p>When to switch from the verbose to the truncated output. If the
DataFrame has more than <cite>max_cols</cite> columns, the truncated output
is used. By default, the setting in
<code class="docutils literal notranslate"><span class="pre">pandas.options.display.max_info_columns</span></code> is used.</p>
</dd>
<dt><strong>memory_usage</strong><span class="classifier">bool, str, optional</span></dt><dd><p>Specifies whether total memory usage of the DataFrame
elements (including the index) should be displayed. By default,
this follows the <code class="docutils literal notranslate"><span class="pre">pandas.options.display.memory_usage</span></code> setting.
True always show memory usage. False never shows memory usage.
A value of ‘deep’ is equivalent to “True with deep introspection”.
Memory usage is shown in human-readable units (base-2
representation). Without deep introspection a memory estimation is
made based in column dtype and number of rows assuming values
consume the same memory amount for corresponding dtypes. With deep
memory introspection, a real memory usage calculation is performed
at the cost of computational resources.</p>
</dd>
<dt><strong>null_counts</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether to show the non-null counts. By default, this is shown
only if the frame is smaller than
<code class="docutils literal notranslate"><span class="pre">pandas.options.display.max_info_rows</span></code> and
<code class="docutils literal notranslate"><span class="pre">pandas.options.display.max_info_columns</span></code>. A value of True always
shows the counts, and False never shows the counts.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>None</dt><dd><p>This method prints a summary of a DataFrame and returns None.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.describe" title="cudf.core.dataframe.DataFrame.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.describe</span></code></a></dt><dd><p>Generate descriptive statistics of DataFrame columns.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.memory_usage" title="cudf.core.dataframe.DataFrame.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.memory_usage</span></code></a></dt><dd><p>Memory usage of DataFrame columns.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text_values</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'alpha'</span><span class="p">,</span> <span class="s1">'beta'</span><span class="p">,</span> <span class="s1">'gamma'</span><span class="p">,</span> <span class="s1">'delta'</span><span class="p">,</span> <span class="s1">'epsilon'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">float_values</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"int_col"</span><span class="p">:</span> <span class="n">int_values</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="s2">"text_col"</span><span class="p">:</span> <span class="n">text_values</span><span class="p">,</span>
<span class="gp">... </span>                    <span class="s2">"float_col"</span><span class="p">:</span> <span class="n">float_values</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">   int_col text_col  float_col</span>
<span class="go">0        1    alpha       0.00</span>
<span class="go">1        2     beta       0.25</span>
<span class="go">2        3    gamma       0.50</span>
<span class="go">3        4    delta       0.75</span>
<span class="go">4        5  epsilon       1.00</span>
</pre></div>
</div>
<p>Prints information of all columns:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.dataframe.DataFrame'&gt;</span>
<span class="go">RangeIndex: 5 entries, 0 to 4</span>
<span class="go">Data columns (total 3 columns):</span>
<span class="go"> #   Column     Non-Null Count  Dtype</span>
<span class="go">---  ------     --------------  -----</span>
<span class="go"> 0   int_col    5 non-null      int64</span>
<span class="go"> 1   text_col   5 non-null      object</span>
<span class="go"> 2   float_col  5 non-null      float64</span>
<span class="go">dtypes: float64(1), int64(1), object(1)</span>
<span class="go">memory usage: 130.0+ bytes</span>
</pre></div>
</div>
<p>Prints a summary of columns count and its dtypes but not per column
information:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.dataframe.DataFrame'&gt;</span>
<span class="go">RangeIndex: 5 entries, 0 to 4</span>
<span class="go">Columns: 3 entries, int_col to float_col</span>
<span class="go">dtypes: float64(1), int64(1), object(1)</span>
<span class="go">memory usage: 130.0+ bytes</span>
</pre></div>
</div>
<p>Pipe output of DataFrame.info to buffer instead of sys.stdout,
get buffer content and writes to a text file:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">io</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">buffer</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">buf</span><span class="o">=</span><span class="n">buffer</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">buffer</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">"df_info.txt"</span><span class="p">,</span> <span class="s2">"w"</span><span class="p">,</span>
<span class="gp">... </span>          <span class="n">encoding</span><span class="o">=</span><span class="s2">"utf-8"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">369</span>
</pre></div>
</div>
<p>The <cite>memory_usage</cite> parameter allows deep introspection mode, specially
useful for big DataFrames and fine-tune memory optimization:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">random_strings_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">],</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
<span class="gp">... </span>    <span class="s1">'column_1'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">],</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">'column_2'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">],</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">'column_3'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">],</span> <span class="mi">10</span> <span class="o">**</span> <span class="mi">6</span><span class="p">)</span>
<span class="gp">... </span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">memory_usage</span><span class="o">=</span><span class="s1">'deep'</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.dataframe.DataFrame'&gt;</span>
<span class="go">RangeIndex: 1000000 entries, 0 to 999999</span>
<span class="go">Data columns (total 3 columns):</span>
<span class="go"> #   Column    Non-Null Count    Dtype</span>
<span class="go">---  ------    --------------    -----</span>
<span class="go"> 0   column_1  1000000 non-null  object</span>
<span class="go"> 1   column_2  1000000 non-null  object</span>
<span class="go"> 2   column_3  1000000 non-null  object</span>
<span class="go">dtypes: object(3)</span>
<span class="go">memory usage: 14.3 MB</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">loc</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">value</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a column to DataFrame at the index specified by loc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>loc</strong><span class="classifier">int</span></dt><dd><p>location to insert by index, cannot be greater then num columns + 1</p>
</dd>
<dt><strong>name</strong><span class="classifier">number or string</span></dt><dd><p>name or label of column to be inserted</p>
</dd>
<dt><strong>value</strong><span class="classifier">Series or array-like</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.isin">
<code class="sig-name descname">isin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether each element in the DataFrame is contained in values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">iterable, Series, DataFrame or dict</span></dt><dd><p>The result will only be true at a location if all
the labels match. If values is a Series, that’s the index.
If values is a dict, the keys must be the column names,
which must match. If values is a DataFrame, then both the
index and column labels must match.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame:</dt><dd><p>DataFrame of booleans showing whether each element in
the DataFrame is contained in values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.iteritems">
<code class="sig-name descname">iteritems</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.iteritems" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over column names and series pairs</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">on</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">how</span><span class="o">=</span><span class="default_value">'left'</span></em>, <em class="sig-param"><span class="n">lsuffix</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">rsuffix</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'hash'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join columns with other DataFrame on index or on a key column.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>how</strong><span class="classifier">str</span></dt><dd><p>Only accepts “left”, “right”, “inner”, “outer”</p>
</dd>
<dt><strong>lsuffix, rsuffix</strong><span class="classifier">str</span></dt><dd><p>The suffices to add to the left (<em>lsuffix</em>) and right (<em>rsuffix</em>)
column names when avoiding conflicts.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool</span></dt><dd><p>Set to True to ensure sorted ordering.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>joined</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:</p>
<ul class="simple">
<li><p><em>other</em> must be a single DataFrame for now.</p></li>
<li><p><em>on</em> is not supported yet due to lack of multi-index support.</p></li>
</ul>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.kurt">
<code class="sig-name descname">kurt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.kurt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Fisher’s unbiased kurtosis of a sample.</p>
<p>Kurtosis obtained using Fisher’s definition of
kurtosis (kurtosis of normal == 0.0). Normalized by N-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">kurt</span><span class="p">()</span>
<span class="go">a   -1.2</span>
<span class="go">b   -1.2</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.kurtosis">
<code class="sig-name descname">kurtosis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Fisher’s unbiased kurtosis of a sample.</p>
<p>Kurtosis obtained using Fisher’s definition of
kurtosis (kurtosis of normal == 0.0). Normalized by N-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">kurt</span><span class="p">()</span>
<span class="go">a   -1.2</span>
<span class="go">b   -1.2</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.label_encoding">
<code class="sig-name descname">label_encoding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">column</span></em>, <em class="sig-param"><span class="n">prefix</span></em>, <em class="sig-param"><span class="n">cats</span></em>, <em class="sig-param"><span class="n">prefix_sep</span><span class="o">=</span><span class="default_value">'_'</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">na_sentinel</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode labels in a column with label encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str</span></dt><dd><p>the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>the new column name prefix.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">sequence of ints</span></dt><dd><p>the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str</span></dt><dd><p>the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt><dd><p>the dtype for the outputs; see Series.label_encoding</p>
</dd>
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a new dataframe with a new column append for the coded values.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.loc">
<em class="property">property </em><code class="sig-name descname">loc</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Selecting rows and columns by label or boolean mask.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.iloc" title="cudf.core.dataframe.DataFrame.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.iloc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>One notable difference from Pandas is when DataFrame is of
mixed types and result is expected to be a Series in case of Pandas.
cuDF will return a DataFrame as it doesn’t support mixed types
under Series yet.</p>
<p>Mixed dtype single row output as a dataframe (pandas results in Series)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">,</span> <span class="s2">"c"</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">   a  b</span>
<span class="go">0  1  a</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<p>DataFrame with string index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">a  0  5</span>
<span class="go">b  1  6</span>
<span class="go">c  2  7</span>
<span class="go">d  3  8</span>
<span class="go">e  4  9</span>
</pre></div>
</div>
<p>Select a single row by label.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s1">'a'</span><span class="p">])</span>
<span class="go">a    0</span>
<span class="go">b    5</span>
<span class="go">Name: a, dtype: int64</span>
</pre></div>
</div>
<p>Select multiple rows and a single column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">])</span>
<span class="go">a    5</span>
<span class="go">c    7</span>
<span class="go">e    9</span>
<span class="go">Name: b, dtype: int64</span>
</pre></div>
</div>
<p>Selection by boolean mask.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">   a  b</span>
<span class="go">d  3  8</span>
<span class="go">e  4  9</span>
</pre></div>
</div>
<p>Setting values using loc.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'c'</span><span class="p">,</span> <span class="s1">'e'</span><span class="p">],</span> <span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">a  0  5</span>
<span class="go">b  1  6</span>
<span class="go">c  0  7</span>
<span class="go">d  3  8</span>
<span class="go">e  0  9</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of the values in the DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype: data type</strong></dt><dd><p>Data type to cast the result to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">a     4</span>
<span class="go">b    10</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the values for the requested axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}</span></dt><dd><p>Axis for the function to be applied on.</p>
</dd>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), count along a
particular level, collapsing into a Series.</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">bool, default None</span></dt><dd><p>Include only float, int, boolean columns. If None, will attempt to
use everything, then use only numeric data. Not implemented for
Series.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments to be passed to the function.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>mean</strong><span class="classifier">Series or DataFrame (if level specified)</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">a    2.5</span>
<span class="go">b    8.5</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.melt">
<code class="sig-name descname">melt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>Melted result</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.memory_usage">
<code class="sig-name descname">memory_usage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory usage of each column in bytes.
The memory usage can optionally include the contribution of
the index and elements of <cite>object</cite> dtype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Specifies whether to include the memory usage of the DataFrame’s
index in returned Series. If <code class="docutils literal notranslate"><span class="pre">index=True</span></code>, the memory usage of
the index is the first item in the output.</p>
</dd>
<dt><strong>deep</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, introspect the data deeply by interrogating
<cite>object</cite> dtypes for system-level memory consumption, and include
it in the returned values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd><p>A Series whose index is the original column names and whose values
is the memory usage of each column in bytes.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dtypes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'int64'</span><span class="p">,</span> <span class="s1">'float64'</span><span class="p">,</span> <span class="s1">'object'</span><span class="p">,</span> <span class="s1">'bool'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">t</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">5000</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="gp">... </span>             <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">    int64  float64  object  bool</span>
<span class="go">0      1      1.0     1.0  True</span>
<span class="go">1      1      1.0     1.0  True</span>
<span class="go">2      1      1.0     1.0  True</span>
<span class="go">3      1      1.0     1.0  True</span>
<span class="go">4      1      1.0     1.0  True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">int64      40000</span>
<span class="go">float64    40000</span>
<span class="go">object     40000</span>
<span class="go">bool        5000</span>
<span class="go">dtype: int64</span>
<span class="go">Use a Categorical for efficient storage of an object-dtype column with</span>
<span class="go">many repeated values.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'object'</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'category'</span><span class="p">)</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">5048</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.merge">
<code class="sig-name descname">merge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">right</span></em>, <em class="sig-param"><span class="n">on</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">left_on</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">right_on</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">left_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">right_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">how</span><span class="o">=</span><span class="default_value">'inner'</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">lsuffix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">rsuffix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">type</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'hash'</span></em>, <em class="sig-param"><span class="n">indicator</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">suffixes</span><span class="o">=</span><span class="default_value">'_x', '_y'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.merge" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge GPU DataFrame objects by performing a database-style join
operation by columns or indexes.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>right</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>on</strong><span class="classifier">label or list; defaults to None</span></dt><dd><p>Column or index level names to join on. These must be found in
both DataFrames.</p>
<p>If on is None and not merging on indexes then
this defaults to the intersection of the columns
in both DataFrames.</p>
</dd>
<dt><strong>how</strong><span class="classifier">{‘left’, ‘outer’, ‘inner’}, default ‘inner’</span></dt><dd><p>Type of merge to be performed.</p>
<ul class="simple">
<li><p>left : use only keys from left frame, similar to a SQL left
outer join.</p></li>
<li><p>right : not supported.</p></li>
<li><p>outer : use union of keys from both frames, similar to a SQL
full outer join.</p></li>
<li><p>inner: use intersection of keys from both frames, similar to
a SQL inner join.</p></li>
</ul>
</dd>
<dt><strong>left_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the left DataFrame.
Can also be an array or list of arrays of the length of the
left DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>right_on</strong><span class="classifier">label or list, or array-like</span></dt><dd><p>Column or index level names to join on in the right DataFrame.
Can also be an array or list of arrays of the length of the
right DataFrame. These arrays are treated as if they are columns.</p>
</dd>
<dt><strong>left_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the left DataFrame as the join key(s).</p>
</dd>
<dt><strong>right_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use the index from the right DataFrame as the join key.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default False</span></dt><dd><p>Sort the resulting dataframe by the columns that were merged on,
starting from the left.</p>
</dd>
<dt><strong>suffixes: Tuple[str, str], defaults to (‘_x’, ‘_y’)</strong></dt><dd><p>Suffixes applied to overlapping column names on the left and right
sides</p>
</dd>
<dt><strong>method</strong><span class="classifier">{‘hash’, ‘sort’}, default ‘hash’</span></dt><dd><p>The implementation method to be used for the operation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>merged</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>DataFrames merges in cuDF result in non-deterministic row ordering.</strong></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_a</span><span class="p">[</span><span class="s1">'vals_a'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_b</span><span class="p">[</span><span class="s1">'vals_b'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span> <span class="o">=</span> <span class="n">df_a</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_b</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="p">[</span><span class="s1">'key'</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s1">'left'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_merged</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">'key'</span><span class="p">)</span>  
<span class="go">   key  vals_a  vals_b</span>
<span class="go">3    0    10.0</span>
<span class="go">0    1    11.0    10.0</span>
<span class="go">1    2    12.0    11.0</span>
<span class="go">4    3    13.0</span>
<span class="go">2    4    14.0    12.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of the values in the DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype: data type</strong></dt><dd><p>Data type to cast the result to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">a    1</span>
<span class="go">b    7</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.mod">
<code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Modulo division of dataframe and other, element-wise (binary
operator <cite>mod</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">%</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rmod</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">%</span> <span class="mi">100</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0       60</span>
<span class="go">triangle        3       80</span>
<span class="go">rectangle       4       60</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0       60</span>
<span class="go">triangle        3       80</span>
<span class="go">rectangle       4       60</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.mul">
<code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Multiplication of dataframe and other, element-wise (binary
operator <cite>mul</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">*</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rmul</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">*</span> <span class="n">other</span>
<span class="go">        angles degrees</span>
<span class="go">circle          0    null</span>
<span class="go">triangle        9    null</span>
<span class="go">rectangle      16    null</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0        0</span>
<span class="go">triangle        9        0</span>
<span class="go">rectangle      16        0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.nans_to_nulls">
<code class="sig-name descname">nans_to_nulls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.nans_to_nulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert nans (if any) to nulls.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. DataFrame ndim is always 2.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.nlargest">
<code class="sig-name descname">nlargest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">columns</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">'first'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n largest value of <em>columns</em></p>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Only a single column is supported in <em>columns</em></p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.nsmallest">
<code class="sig-name descname">nsmallest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em>, <em class="sig-param"><span class="n">columns</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">'first'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the rows of the DataFrame sorted by the n smallest value of <em>columns</em></p>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Only a single column is supported in <em>columns</em></p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.one_hot_encoding">
<code class="sig-name descname">one_hot_encoding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">column</span></em>, <em class="sig-param"><span class="n">prefix</span></em>, <em class="sig-param"><span class="n">cats</span></em>, <em class="sig-param"><span class="n">prefix_sep</span><span class="o">=</span><span class="default_value">'_'</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">'float64'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand a column with one-hot-encoding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>column</strong><span class="classifier">str</span></dt><dd><p>the source column with binary encoding for the data.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str</span></dt><dd><p>the new column name prefix.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">sequence of ints</span></dt><dd><p>the sequence of categories as integers.</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str</span></dt><dd><p>the separator between the prefix and the category.</p>
</dd>
<dt><strong>dtype :</strong></dt><dd><p>the dtype for the outputs; defaults to float64.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>a new dataframe with new columns append for each category.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_owner</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pet_type</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'bird'</span><span class="p">,</span> <span class="s1">'fish'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'pet_owner'</span><span class="p">:</span> <span class="n">pet_owner</span><span class="p">,</span> <span class="s1">'pet_type'</span><span class="p">:</span> <span class="n">pet_type</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">pet_type</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">'category'</span><span class="p">)</span>
</pre></div>
</div>
<p>Create a column with numerically encoded category values</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'pet_codes'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">pet_type</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">codes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
<p>Create the list of category codes to use in the encoding</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">codes</span> <span class="o">=</span> <span class="n">gdf</span><span class="o">.</span><span class="n">pet_codes</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="o">.</span><span class="n">one_hot_encoding</span><span class="p">(</span><span class="s1">'pet_codes'</span><span class="p">,</span> <span class="s1">'pet_dummy'</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">  pet_owner  pet_type  pet_codes  pet_dummy_0  pet_dummy_1  pet_dummy_2</span>
<span class="go">0         1      fish          2          0.0          0.0          1.0</span>
<span class="go">1         2       dog          1          0.0          1.0          0.0</span>
<span class="go">2         3      fish          2          0.0          0.0          1.0</span>
<span class="go">3         4      bird          0          1.0          0.0          0.0</span>
<span class="go">4         5      fish          2          0.0          0.0          1.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.partition_by_hash">
<code class="sig-name descname">partition_by_hash</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">columns</span></em>, <em class="sig-param"><span class="n">nparts</span></em>, <em class="sig-param"><span class="n">keep_index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.partition_by_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Partition the dataframe by the hashed value of data in <em>columns</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>columns</strong><span class="classifier">sequence of str</span></dt><dd><p>The names of the columns to be hashed.
Must have at least one name.</p>
</dd>
<dt><strong>nparts</strong><span class="classifier">int</span></dt><dd><p>Number of output partitions</p>
</dd>
<dt><strong>keep_index</strong><span class="classifier">boolean</span></dt><dd><p>Whether to keep the index or drop it</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>partitioned: list of DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.pop">
<code class="sig-name descname">pop</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">item</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a column and drop it from the DataFrame.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.pow">
<code class="sig-name descname">pow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Exponential power of dataframe and other, element-wise (binary
operator <cite>pow</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">**</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rpow</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">**</span> <span class="mi">2</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0   129600</span>
<span class="go">triangle        9    32400</span>
<span class="go">rectangle      16   129600</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0   129600</span>
<span class="go">triangle        9    32400</span>
<span class="go">rectangle      16   129600</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return product of the values in the DataFrame.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype: data type</strong></dt><dd><p>Data type to cast the result to.</p>
</dd>
<dt><strong>min_count: int, default 0</strong></dt><dd><p>The required number of valid values to perform the operation.
If fewer than min_count non-NA values are present the result
will be NA.</p>
<p>The default being 0. This means the sum of an all-NA or empty
Series is 0, and the product of an all-NA or empty Series is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
<span class="go">a      24</span>
<span class="go">b    5040</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.product">
<code class="sig-name descname">product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return product of the values in the DataFrame.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype: data type</strong></dt><dd><p>Data type to cast the result to.</p>
</dd>
<dt><strong>min_count: int, default 0</strong></dt><dd><p>The required number of valid values to perform the operation.
If fewer than min_count non-NA values are present the result
will be NA.</p>
<p>The default being 0. This means the sum of an all-NA or empty
Series is 0, and the product of an all-NA or empty Series is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">product</span><span class="p">()</span>
<span class="go">a      24</span>
<span class="go">b    5040</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exact</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>q</strong><span class="classifier">float or array-like</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int</span></dt><dd><p>axis is a NON-FUNCTIONAL parameter</p>
</dd>
<dt><strong>numeric_only</strong><span class="classifier">boolean</span></dt><dd><p>numeric_only is a NON-FUNCTIONAL parameter</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{<cite>linear</cite>, <cite>lower</cite>, <cite>higher</cite>, <cite>midpoint</cite>, <cite>nearest</cite>}</span></dt><dd><p>This parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j.
Default <code class="docutils literal notranslate"><span class="pre">linear</span></code>.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use approximate or exact quantile algorithm.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.quantiles">
<code class="sig-name descname">quantiles</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'nearest'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.quantiles" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>q</strong><span class="classifier">float or array-like</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{<cite>lower</cite>, <cite>higher</cite>, <cite>nearest</cite>}</span></dt><dd><p>This parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j.
Default ‘nearest’.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.query">
<code class="sig-name descname">query</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">expr</span></em>, <em class="sig-param"><span class="n">local_dict</span><span class="o">=</span><span class="default_value">{}</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.query" title="Permalink to this definition">¶</a></dt>
<dd><p>Query with a boolean expression using Numba to compile a GPU kernel.</p>
<p>See pandas.DataFrame.query.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>expr</strong><span class="classifier">str</span></dt><dd><p>A boolean expression. Names in expression refer to columns.
<cite>index</cite> can be used instead of index name, but this is not
supported for MultiIndex.</p>
<p>Names starting with <cite>@</cite> refer to Python variables.</p>
<p>An output value will be <cite>null</cite> if any of the input values are
<cite>null</cite> regardless of expression.</p>
</dd>
<dt><strong>local_dict</strong><span class="classifier">dict</span></dt><dd><p>Containing the local variable to be used in query.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>filtered</strong><span class="classifier">DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="s2">"(a == 2 and b == 4) or (b == 3)"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  1  3</span>
<span class="go">1  2  4</span>
</pre></div>
</div>
<p>DateTime conditionals:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">'2018-10-07'</span><span class="p">,</span> <span class="s1">'2018-10-08'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'datetimes'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">'2018-10-08'</span><span class="p">,</span> <span class="s1">'%Y-%m-</span><span class="si">%d</span><span class="s1">'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">'datetimes==@search_date'</span><span class="p">))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
<p>Using local_dict:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">datetime</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">'2018-10-07'</span><span class="p">,</span> <span class="s1">'2018-10-08'</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'datetime64'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'datetimes'</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">search_date2</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="s1">'2018-10-08'</span><span class="p">,</span> <span class="s1">'%Y-%m-</span><span class="si">%d</span><span class="s1">'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s1">'datetimes==@search_date'</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">local_dict</span><span class="o">=</span><span class="p">{</span><span class="s1">'search_date'</span><span class="p">:</span><span class="n">search_date2</span><span class="p">}))</span>
<span class="go">                datetimes</span>
<span class="go">1 2018-10-08T00:00:00.000</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.radd">
<code class="sig-name descname">radd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.radd" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Addition of dataframe and other, element-wise (binary
operator <cite>radd</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">+</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>add</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">+</span> <span class="mi">1</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">radd</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1      361</span>
<span class="go">triangle        4      181</span>
<span class="go">rectangle       5      361</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rdiv">
<code class="sig-name descname">rdiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rdiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary
operator <cite>rtruediv</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">/</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>truediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rtruediv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="o">/</span> <span class="n">df</span>
<span class="go">            angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">labels</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame whose axes conform to a new index</p>
<dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">DataFrame.reindex</span></code> supports two calling conventions:</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">(index=index_labels,</span> <span class="pre">columns=column_names)</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">(labels,</span> <span class="pre">axis={0</span> <span class="pre">or</span> <span class="pre">'index',</span> <span class="pre">1</span> <span class="pre">or</span> <span class="pre">'columns'})</span></code></p></li>
</ul>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>labels</strong><span class="classifier">Index, Series-convertible, optional, default None</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, optional, default 0</span></dt><dd></dd>
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, optional, default None</span></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">df.reindex(labels=index_labels,</span> <span class="pre">axis=0)</span></code></p>
</dd>
<dt><strong>columns</strong><span class="classifier">array-like, optional, default None</span></dt><dd><p>Shorthand for <code class="docutils literal notranslate"><span class="pre">df.reindex(labels=column_names,</span> <span class="pre">axis=1)</span></code></p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, optional, default True</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A DataFrame whose axes conform to the new index(es)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df_new</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
<span class="go">                        columns=['key', 'val', 'sum'])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="go">   key   val</span>
<span class="go">0    0  10.0</span>
<span class="go">1    1  11.0</span>
<span class="go">2    2  12.0</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df_new</span><span class="p">)</span>
<span class="go">   key   val  sum</span>
<span class="go">0    0  10.0  NaN</span>
<span class="go">3    3  13.0  NaN</span>
<span class="go">4    4  14.0  NaN</span>
<span class="go">5   -1   NaN  NaN</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">mapper</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'ignore'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter column and index labels.</p>
<p>Function / dict values must be unique (1-to-1). Labels not contained in
a dict / Series will be left as-is. Extra labels listed don’t throw an
error.</p>
<p>DataFrame.rename supports two calling conventions</p>
<p><code class="docutils literal notranslate"><span class="pre">(index=index_mapper,</span> <span class="pre">columns=columns_mapper,</span> <span class="pre">...)</span></code>
<code class="docutils literal notranslate"><span class="pre">(mapper,</span> <span class="pre">axis={0/'index'</span> <span class="pre">or</span> <span class="pre">1/'column'},</span> <span class="pre">...)</span></code></p>
<p>We highly recommend using keyword arguments to clarify your intent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>mapper</strong><span class="classifier">dict-like or function, default None</span></dt><dd><p>optional dict-like or functions transformations to apply to
the index/column values depending on selected <code class="docutils literal notranslate"><span class="pre">axis</span></code>.</p>
</dd>
<dt><strong>index</strong><span class="classifier">dict-like, default None</span></dt><dd><p>Optional dict-like transformations to apply to the index axis’
values. Does not support functions for axis 0 yet.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">dict-like or function, default None</span></dt><dd><p>optional dict-like or functions transformations to apply to
the columns axis’ values.</p>
</dd>
<dt><strong>axis</strong><span class="classifier">int, default 0</span></dt><dd><p>Axis to rename with mapper.
0 or ‘index’ for index
1  or ‘columns’ for columns</p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd><p>Also copy underlying data</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">boolean, default False</span></dt><dd><p>Return new DataFrame.  If True, assign columns without copy</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name, default None</span></dt><dd><p>In case of a MultiIndex, only rename labels in the specified level.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘raise’, ‘ignore’, ‘warn’}, default ‘ignore’</span></dt><dd><p><em>Only ‘ignore’ supported</em>
Control raising of exceptions on invalid data for provided dtype.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">raise</span></code> : allow exceptions to be raised</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ignore</span></code> : suppress exceptions. On error return original
object.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">warn</span></code> : prints last exceptions as warnings and
return original object.</p></li>
</ul>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Not supporting: level</p></li>
</ul>
</dd>
</dl>
<p>Rename will not overwite column names. If a list with duplicates is
passed, column names will be postfixed with a number.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">to_replace</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">limit</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">regex</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <em>to_replace</em> with <em>replacement</em>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>to_replace</strong><span class="classifier">numeric, str, list-like or dict</span></dt><dd><p>Value(s) to replace.</p>
<ul>
<li><p>numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>values equal to <em>to_replace</em> will be replaced
with <em>replacement</em></p></li>
</ul>
</div></blockquote>
</li>
<li><p>list of numeric or str:</p>
<blockquote>
<div><ul class="simple">
<li><p>If <em>replacement</em> is also list-like,
<em>to_replace</em> and <em>replacement</em> must be of same length.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>dict:</p>
<blockquote>
<div><ul class="simple">
<li><p>Dicts can be used to replace different values in different
columns. For example, <cite>{‘a’: 1, ‘z’: 2}</cite> specifies that the
value 1 in column <cite>a</cite> and the value 2 in column <cite>z</cite> should be
replaced with replacement*.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</dd>
<dt><strong>value</strong><span class="classifier">numeric, str, list-like, or dict</span></dt><dd><p>Value(s) to replace <cite>to_replace</cite> with. If a dict is provided, then
its keys must match the keys in <em>to_replace</em>, and corresponding
values must be compatible (e.g., if they are lists, then they must
match in length).</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, in place.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame after replacement.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters that are currently not supported are: <cite>limit</cite>, <cite>regex</cite>,
<cite>method</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">=</span> <span class="n">gdf</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gdf</span>
<span class="go">     id</span>
<span class="go">0     0</span>
<span class="go">1     1</span>
<span class="go">2     2</span>
<span class="go">3  null</span>
<span class="go">4     4</span>
<span class="go">5  null</span>
<span class="go">6     6</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.reset_index">
<code class="sig-name descname">reset_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">col_level</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">col_fill</span><span class="o">=</span><span class="default_value">''</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the index.</p>
<p>Reset the index of the DataFrame, and use the default one instead.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>drop</strong><span class="classifier">bool, default False</span></dt><dd><p>Do not try to insert index into dataframe columns. This resets
the index to the default integer index.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Modify the DataFrame in place (do not create a new object).</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame or None</dt><dd><p>DataFrame with the new index or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([(</span><span class="s1">'bird'</span><span class="p">,</span> <span class="mf">389.0</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">'bird'</span><span class="p">,</span> <span class="mf">24.0</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">'mammal'</span><span class="p">,</span> <span class="mf">80.5</span><span class="p">),</span>
<span class="gp">... </span>                   <span class="p">(</span><span class="s1">'mammal'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)],</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'falcon'</span><span class="p">,</span> <span class="s1">'parrot'</span><span class="p">,</span> <span class="s1">'lion'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">],</span>
<span class="gp">... </span>                  <span class="n">columns</span><span class="o">=</span><span class="p">(</span><span class="s1">'class'</span><span class="p">,</span> <span class="s1">'max_speed'</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">        class max_speed</span>
<span class="go">falcon    bird     389.0</span>
<span class="go">parrot    bird      24.0</span>
<span class="go">lion    mammal      80.5</span>
<span class="go">monkey  mammal      null</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
<span class="go">    index   class max_speed</span>
<span class="go">0  falcon    bird     389.0</span>
<span class="go">1  parrot    bird      24.0</span>
<span class="go">2    lion  mammal      80.5</span>
<span class="go">3  monkey  mammal      null</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">    class max_speed</span>
<span class="go">0    bird     389.0</span>
<span class="go">1    bird      24.0</span>
<span class="go">2  mammal      80.5</span>
<span class="go">3  mammal      null</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rfloordiv">
<code class="sig-name descname">rfloordiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rfloordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Integer division of dataframe and other, element-wise (binary
operator <cite>rfloordiv</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">//</span> <span class="pre">dataframe</span></code>, but with support to substitute
a fill_value for missing data in one of the inputs. With reverse
version, <cite>floordiv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO: Add emaples</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rmod">
<code class="sig-name descname">rmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Modulo division of dataframe and other, element-wise (binary
operator <cite>rmod</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">%</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>mod</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">100</span> <span class="o">%</span> <span class="n">df</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0      100</span>
<span class="go">triangle        1      100</span>
<span class="go">rectangle       0      100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rmod</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0      100</span>
<span class="go">triangle        1      100</span>
<span class="go">rectangle       0      100</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rmul">
<code class="sig-name descname">rmul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Multiplication of dataframe and other, element-wise (binary
operator <cite>rmul</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">*</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>mul</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]},</span>
<span class="gp">... </span>                     <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">*</span> <span class="n">df</span>
<span class="go">        angles degrees</span>
<span class="go">circle          0    null</span>
<span class="go">triangle        9    null</span>
<span class="go">rectangle      16    null</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rmul</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          0        0</span>
<span class="go">triangle        9        0</span>
<span class="go">rectangle      16        0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">window</span></em>, <em class="sig-param"><span class="n">min_periods</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">win_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolling window calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window</strong><span class="classifier">int or offset</span></dt><dd><p>Size of the window, i.e., the number of observations used
to calculate the statistic.
For datetime indexes, an offset can be provided instead
of an int. The offset must be convertible to a timedelta.
As opposed to a fixed window size, each window will be
sized to accommodate observations within the time period
specified by the offset.</p>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>The minimum number of observations in the window that are
required to be non-null, so that the result is non-null.
If not provided or <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> is equal to
the window size.</p>
</dd>
<dt><strong>center</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result is set at the center of the window.
If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), the result is set at the right edge
of the window.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Rolling</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Rolling sum with window size 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling sum with window size 2 and min_periods 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    2</span>
<span class="go">4    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3, but with the result set at the
center of the window.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    2</span>
<span class="go">1    3</span>
<span class="go">2    2</span>
<span class="go">3    2</span>
<span class="go">4    1 dtype: int64</span>
</pre></div>
</div>
<p>Rolling max with variable window size specified by an offset;
only valid for datetime index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:00'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:01'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:02'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:04'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:07'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:08'</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">'2s'</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="go">2019-01-01T09:00:00.000    1</span>
<span class="go">2019-01-01T09:00:01.000    9</span>
<span class="go">2019-01-01T09:00:02.000    9</span>
<span class="go">2019-01-01T09:00:04.000    4</span>
<span class="go">2019-01-01T09:00:07.000</span>
<span class="go">2019-01-01T09:00:08.000    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Apply custom function on the window with the <em>apply</em> method</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">0     4.0</span>
<span class="go">1     9.0</span>
<span class="go">2    15.0</span>
<span class="go">3    18.0</span>
<span class="go">4    21.0</span>
<span class="go">5    24.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>And this also works for window rolling set by an offset</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:00'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:01'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:02'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:04'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:07'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:08'</span><span class="p">)</span>
<span class="gp">... </span>     <span class="p">],</span>
<span class="gp">... </span>    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">'2s'</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">2019-01-01T09:00:00.000     4.0</span>
<span class="go">2019-01-01T09:00:01.000     9.0</span>
<span class="go">2019-01-01T09:00:02.000    11.0</span>
<span class="go">2019-01-01T09:00:04.000     7.0</span>
<span class="go">2019-01-01T09:00:07.000     8.0</span>
<span class="go">2019-01-01T09:00:08.000    17.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rpow">
<code class="sig-name descname">rpow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Exponential power of dataframe and other, element-wise (binary
operator <cite>pow</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">**</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>pow</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">1</span> <span class="o">**</span> <span class="n">df</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1        1</span>
<span class="go">triangle        1        1</span>
<span class="go">rectangle       1        1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rpow</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1        1</span>
<span class="go">triangle        1        1</span>
<span class="go">rectangle       1        1</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rsub">
<code class="sig-name descname">rsub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Subtraction of dataframe and other, element-wise (binary
operator <cite>rsub</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">-</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>sub</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rsub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1     -359</span>
<span class="go">triangle       -2     -179</span>
<span class="go">rectangle      -3     -359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rsub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">        angles  degrees</span>
<span class="go">circle          1     -358</span>
<span class="go">triangle       -2     -178</span>
<span class="go">rectangle      -3     -358</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.rtruediv">
<code class="sig-name descname">rtruediv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.rtruediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary
operator <cite>rtruediv</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">/</span> <span class="pre">dataframe</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>truediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rtruediv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">rdiv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
<span class="gp">&gt;&gt;&gt; </span><span class="mi">10</span> <span class="o">/</span> <span class="n">df</span>
<span class="go">            angles   degrees</span>
<span class="go">circle          inf  0.027778</span>
<span class="go">triangle   3.333333  0.055556</span>
<span class="go">rectangle  2.500000  0.027778</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.select_dtypes">
<code class="sig-name descname">select_dtypes</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">include</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.select_dtypes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a subset of the DataFrame’s columns based on the column dtypes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>include</strong><span class="classifier">str or list</span></dt><dd><p>which columns to include based on dtypes</p>
</dd>
<dt><strong>exclude</strong><span class="classifier">str or list</span></dt><dd><p>which columns to exclude based on dtypes</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.set_index">
<code class="sig-name descname">set_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame with a new index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, str, or list of str</span></dt><dd><p>Index : the new index.
Series-convertible : values for the new index.
str : name of column to be used as series
list of str : name of columns to be converted to a MultiIndex</p>
</dd>
<dt><strong>drop</strong><span class="classifier">boolean</span></dt><dd><p>whether to drop corresponding column for str index argument</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the DataFrame.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.skew">
<code class="sig-name descname">skew</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased Fisher-Pearson skew of a sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">skew</span><span class="p">()</span>
<span class="go">a    0.00000</span>
<span class="go">b   -0.37037</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.sort_index">
<code class="sig-name descname">sort_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">na_position</span><span class="o">=</span><span class="default_value">'last'</span></em>, <em class="sig-param"><span class="n">sort_remaining</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort object by labels (along an axis).</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>axis</strong><span class="classifier">{0 or ‘index’, 1 or ‘columns’}, default 0</span></dt><dd><p>The axis along which to sort. The value 0 identifies the rows,
and 1 identifies the columns.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int or level name or list of ints or list of level names</span></dt><dd><p>If not None, sort on values in specified index level(s).
This is only useful in the case of MultiIndex.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool, default True</span></dt><dd><p>Sort ascending vs. descending.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, perform operation in-place.</p>
</dd>
<dt><strong>kind</strong><span class="classifier">sorting method such as <cite>quick sort</cite> and others.</span></dt><dd><p>Not yet supported.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>Puts NaNs at the beginning if first; last puts NaNs at the end.</p>
</dd>
<dt><strong>sort_remaining</strong><span class="classifier">bool, default True</span></dt><dd><p>Not yet supported</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False</span></dt><dd><p>if True, index will be replaced with RangeIndex.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame or None</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
<span class="gp">... </span><span class="p">{</span><span class="s2">"b"</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">"a"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="go">   b  a</span>
<span class="go">1  3  2</span>
<span class="go">2  1  3</span>
<span class="go">3  2  1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">   a  b</span>
<span class="go">1  2  3</span>
<span class="go">3  1  2</span>
<span class="go">2  3  1</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.sort_values">
<code class="sig-name descname">sort_values</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">by</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'quicksort'</span></em>, <em class="sig-param"><span class="n">na_position</span><span class="o">=</span><span class="default_value">'last'</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values row-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">str or list of str</span></dt><dd><p>Name or list of names to sort by.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool or list of bool, default True</span></dt><dd><p>Sort ascending vs. descending. Specify list for multiple sort
orders. If this is a list of bools, must match the length of the
by.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, index will not be sorted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sorted_obj</strong><span class="classifier">cuDF DataFrame</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Support axis=’index’ only.</p></li>
<li><p>Not supporting: inplace, kind</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">'b'</span><span class="p">))</span>
<span class="go">   a  b</span>
<span class="go">0  0 -3</span>
<span class="go">2  2  0</span>
<span class="go">1  1  2</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.stack">
<code class="sig-name descname">stack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.stack" title="Permalink to this definition">¶</a></dt>
<dd><p>Stack the prescribed level(s) from columns to index</p>
<p>Return a reshaped Series</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dropna</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to drop rows in the resulting Series with missing values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>The stacked cudf.Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">stack</span><span class="p">()</span>
<span class="go">0  a    0</span>
<span class="go">   b    1</span>
<span class="go">1  a    1</span>
<span class="go">   b    2</span>
<span class="go">2  a    3</span>
<span class="go">   b    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sample standard deviation of the DataFrame.</p>
<p>Normalized by N-1 by default. This can be changed using
the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>ddof: int, default 1</strong></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations
is N - ddof, where N represents the number of elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>
<span class="go">a    1.290994</span>
<span class="go">b    1.290994</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Subtraction of dataframe and other, element-wise (binary
operator <cite>sub</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">-</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rsub</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">        angles  degrees</span>
<span class="go">circle         -1      359</span>
<span class="go">triangle        2      179</span>
<span class="go">rectangle       3      359</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sub</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">        angles  degrees</span>
<span class="go">circle         -1      358</span>
<span class="go">triangle        2      178</span>
<span class="go">rectangle       3      358</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sum of the values in the DataFrame.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype: data type</strong></dt><dd><p>Data type to cast the result to.</p>
</dd>
<dt><strong>min_count: int, default 0</strong></dt><dd><p>The required number of valid values to perform the operation.
If fewer than min_count non-NA values are present the result
will be NA.</p>
<p>The default being 0. This means the sum of an all-NA or empty
Series is 0, and the product of an all-NA or empty Series is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">a    10</span>
<span class="go">b    34</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new DataFrame</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">)]</span>  <span class="c1"># insert column</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">   key   val</span>
<span class="go">3    3  13.0</span>
<span class="go">4    4  14.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">positions</span></em>, <em class="sig-param"><span class="n">keep_index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a new DataFrame containing the rows specified by <em>positions</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>positions</strong><span class="classifier">array-like</span></dt><dd><p>Integer or boolean array-like specifying the rows of the output.
If integer, each element represents the integer index of a row.
If boolean, <em>positions</em> must be of the same length as <em>self</em>,
and represents a boolean mask.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>New DataFrame</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
<span class="go">                        'b': pd.Series(['a', 'b', 'c'])})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">     a  b</span>
<span class="go">0  1.0  a</span>
<span class="go">2  3.0  c</span>
<span class="go">2  3.0  c</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">take</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">])</span>
<span class="go">     a  b</span>
<span class="go">0  1.0  a</span>
<span class="go">2  3.0  c</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_arrow">
<code class="sig-name descname">to_arrow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">preserve_index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a PyArrow Table.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
<span class="go">pyarrow.Table</span>
<span class="go">None: int64</span>
<span class="go">a: int64</span>
<span class="go">b: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_csv">
<code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">','</span></em>, <em class="sig-param"><span class="n">na_rep</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">line_terminator</span><span class="o">=</span><span class="default_value">'\n'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a dataframe to csv file format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame object to be written to csv</p>
</dd>
<dt><strong>path</strong><span class="classifier">str, default None</span></dt><dd><p>Path of file where DataFrame will be written</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, default ‘’</span></dt><dd><p>String to use for null entries</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the column names</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the index as a column</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">char, default ‘n’</span></dt><dd></dd>
<dt><strong>chunksize</strong><span class="classifier">int or None, default None</span></dt><dd><p>Rows to write at a time</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.read_csv</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Follows the standard of Pandas csv.QUOTE_NONNUMERIC for all output.</p></li>
<li><p>If <cite>to_csv</cite> leads to memory errors consider setting the <cite>chunksize</cite> argument.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Write a dataframe to csv.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">'foo.csv'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'x'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="go">                         'y': [1.0, 3.3, 2.2, 4.4],</span>
<span class="go">                         'z': ['a', 'b', 'c', 'd']})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_dlpack">
<code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_feather">
<code class="sig-name descname">to_feather</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_gpu_matrix">
<code class="sig-name descname">to_gpu_matrix</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_gpu_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numba gpu ndarray</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>numba gpu ndarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_hdf">
<code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path_or_buf</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,
nor searchable.</p></li>
<li><p>‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p></li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path_or_buf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Series</dt><dd><ul>
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>DataFrame</dt><dd><ul>
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:
{‘split’,’records’,’index’,’columns’,’values’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The format of the JSON string</dt><dd><ul>
<li><p>‘split’ : dict like {‘index’ -&gt; [index],
‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}</p></li>
<li><p>‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]</p></li>
<li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p></li>
<li><p>‘columns’ : dict like {column -&gt; {index -&gt; value}}</p></li>
<li><p>‘values’ : just the values array</p></li>
<li><p>‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serializable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_orc">
<code class="sig-name descname">to_orc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the ORC format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fname</strong><span class="classifier">str</span></dt><dd><p>File path or object where the ORC dataset will be stored.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{{ ‘snappy’, None }}, default None</span></dt><dd><p>Name of the compression to use. Use None for no compression.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas DataFrame.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdf</span>
<span class="go">   a  b</span>
<span class="go">0  0 -3</span>
<span class="go">1  1  2</span>
<span class="go">2  2  0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">pdf</span><span class="p">)</span>
<span class="go">&lt;class 'pandas.core.frame.DataFrame'&gt;</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_parquet">
<code class="sig-name descname">to_parquet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt><dd><p>Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list, optional, default None</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_records">
<code class="sig-name descname">to_records</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_records" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a numpy recarray</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool</span></dt><dd><p>Whether to include the index in the output.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>numpy recarray</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.to_string">
<code class="sig-name descname">to_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<p>cuDF uses Pandas internals for efficient string formatting.
Set formatting options using pandas string formatting options and
cuDF objects will print identically to Pandas objects.</p>
<p>cuDF supports <cite>null/None</cite> as a value in any column type, which
is transparently supported during this output process.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
<span class="go">'   key   val\n0    0  10.0\n1    1  11.0\n2    2  12.0'</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.transpose">
<code class="sig-name descname">transpose</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose index and columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>a new (ncol x nrow) dataframe. self is (nrow x ncol)</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Difference from pandas:
Not supporting <em>copy</em> because default and only behavior is copy=True</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.truediv">
<code class="sig-name descname">truediv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">'columns'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.truediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Get Floating division of dataframe and other, element-wise (binary
operator <cite>truediv</cite>).</p>
<p>Equivalent to <code class="docutils literal notranslate"><span class="pre">dataframe</span> <span class="pre">/</span> <span class="pre">other</span></code>, but with support to substitute a
fill_value for missing data in one of the inputs. With reverse
version, <cite>rtruediv</cite>.</p>
<p>Among flexible wrappers (<cite>add</cite>, <cite>sub</cite>, <cite>mul</cite>, <cite>div</cite>, <cite>mod</cite>, <cite>pow</cite>) to
arithmetic operators: <cite>+</cite>, <cite>-</cite>, <cite>*</cite>, <cite>/</cite>, <cite>//</cite>, <cite>%</cite>, <cite>**</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">scalar, sequence, Series, or DataFrame</span></dt><dd><p>Any single or multiple element data structure, or list-like object.</p>
</dd>
<dt><strong>fill_value</strong><span class="classifier">float or None, default None</span></dt><dd><p>Fill existing missing (NaN) values, and any new element needed
for successful DataFrame alignment, with this value before
computation. If data in both corresponding DataFrame locations
is missing the result will be missing.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Result of the arithmetic operation.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'angles'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>
<span class="gp">... </span>                   <span class="s1">'degrees'</span><span class="p">:</span> <span class="p">[</span><span class="mi">360</span><span class="p">,</span> <span class="mi">180</span><span class="p">,</span> <span class="mi">360</span><span class="p">]},</span>
<span class="gp">... </span>                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'circle'</span><span class="p">,</span> <span class="s1">'triangle'</span><span class="p">,</span> <span class="s1">'rectangle'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">truediv</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">            angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">/</span> <span class="mi">10</span>
<span class="go">            angles  degrees</span>
<span class="go">circle        0.0     36.0</span>
<span class="go">triangle      0.3     18.0</span>
<span class="go">rectangle     0.4     36.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#cudf.core.dataframe.DataFrame.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a CuPy representation of the DataFrame.</p>
<p>Only the values in the DataFrame will be returned, the axes labels will
be removed.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>out: cupy.ndarray</dt><dd><p>The values of the DataFrame.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.dataframe.DataFrame.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.dataframe.DataFrame.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased variance of the DataFrame.</p>
<p>Normalized by N-1 by default. This can be changed using the
ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna: bool, default True</strong></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>ddof: int, default 1</strong></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is
N - ddof, where N represents the number of elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">var</span><span class="p">()</span>
<span class="go">a    1.666667</span>
<span class="go">b    1.666667</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
</dd></dl>
<span class="target" id="module-cudf.core.reshape"></span><dl class="py function">
<dt id="cudf.core.reshape.concat">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">concat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">objs</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.concat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate DataFrames, Series, or Indices row-wise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>objs</strong><span class="classifier">list of DataFrame, Series, or Index</span></dt><dd></dd>
<dt><strong>axis</strong><span class="classifier">{0/’index’, 1/’columns’}, default 0</span></dt><dd><p>The axis to concatenate along.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Set True to ignore the index of the <em>objs</em> and provide a
default range index instead.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new object of like type with rows from each object in <code class="docutils literal notranslate"><span class="pre">objs</span></code>.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cudf.core.reshape.get_dummies">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">get_dummies</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">prefix_sep</span><span class="o">=</span><span class="default_value">'_'</span></em>, <em class="sig-param"><span class="n">dummy_na</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">cats</span><span class="o">=</span><span class="default_value">{}</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">drop_first</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">'int8'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.get_dummies" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dataframe whose columns are the one hot encodings of all
columns in <cite>df</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd><p>dataframe to encode</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str, dict, or sequence, optional</span></dt><dd><p>prefix to append. Either a str (to apply a constant prefix), dict
mapping column names to prefixes, or sequence of prefixes to apply with
the same length as the number of columns. If not supplied, defaults
to the empty string</p>
</dd>
<dt><strong>prefix_sep</strong><span class="classifier">str, dict, or sequence, optional, default ‘_’</span></dt><dd><p>separator to use when appending prefixes</p>
</dd>
<dt><strong>dummy_na</strong><span class="classifier">boolean, optional</span></dt><dd><p>Right now this is NON-FUNCTIONAL argument in rapids.</p>
</dd>
<dt><strong>cats</strong><span class="classifier">dict, optional</span></dt><dd><p>dictionary mapping column names to sequences of integers representing
that column’s category. See <cite>cudf.DataFrame.one_hot_encoding</cite> for more
information. if not supplied, it will be computed</p>
</dd>
<dt><strong>sparse</strong><span class="classifier">boolean, optional</span></dt><dd><p>Right now this is NON-FUNCTIONAL argument in rapids.</p>
</dd>
<dt><strong>drop_first</strong><span class="classifier">boolean, optional</span></dt><dd><p>Right now this is NON-FUNCTIONAL argument in rapids.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">sequence of str, optional</span></dt><dd><p>Names of columns to encode. If not provided, will attempt to encode all
columns. Note this is different from pandas default behavior, which
encodes all columns with dtype object or categorical</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">str, optional</span></dt><dd><p>output dtype, default ‘int8’</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cudf.core.reshape.melt">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">melt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">frame</span></em>, <em class="sig-param"><span class="n">id_vars</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value_vars</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">var_name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value_name</span><span class="o">=</span><span class="default_value">'value'</span></em>, <em class="sig-param"><span class="n">col_level</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.melt" title="Permalink to this definition">¶</a></dt>
<dd><p>Unpivots a DataFrame from wide format to long format,
optionally leaving identifier variables set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>frame</strong><span class="classifier">DataFrame</span></dt><dd></dd>
<dt><strong>id_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to use as identifier variables.
default: None</p>
</dd>
<dt><strong>value_vars</strong><span class="classifier">tuple, list, or ndarray, optional</span></dt><dd><p>Column(s) to unpivot.
default: all columns that are not set as <cite>id_vars</cite>.</p>
</dd>
<dt><strong>var_name</strong><span class="classifier">scalar</span></dt><dd><p>Name to use for the <cite>variable</cite> column.
default: frame.columns.name or ‘variable’</p>
</dd>
<dt><strong>value_name</strong><span class="classifier">str</span></dt><dd><p>Name to use for the <cite>value</cite> column.
default: ‘value’</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">DataFrame</span></dt><dd><p>Melted result</p>
</dd>
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Does not support ‘col_level’ because cuDF does not have multi-index</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'A'</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">5</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">'B'</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">6</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">'C'</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">4.0</span><span class="p">},</span>
<span class="gp">... </span>                     <span class="s1">'D'</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">6.0</span><span class="p">}})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">melt</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">id_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">],</span> <span class="n">value_vars</span><span class="o">=</span><span class="p">[</span><span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">])</span>
<span class="go">     A    B variable value</span>
<span class="go">0    1    1        C   1.0</span>
<span class="go">1    1    3        C</span>
<span class="go">2    5    6        C   4.0</span>
<span class="go">3    1    1        D   2.0</span>
<span class="go">4    1    3        D   5.0</span>
<span class="go">5    5    6        D   6.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.core.reshape.merge_sorted">
<code class="sig-prename descclassname">cudf.core.reshape.</code><code class="sig-name descname">merge_sorted</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">objs</span></em>, <em class="sig-param"><span class="n">keys</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">by_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">na_position</span><span class="o">=</span><span class="default_value">'last'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.reshape.merge_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge a list of sorted DataFrame or Series objects.</p>
<p>Dataframes/Series in objs list MUST be pre-sorted by columns
listed in <cite>keys</cite>, or by the index (if <cite>by_index=True</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>objs</strong><span class="classifier">list of DataFrame, Series, or Index</span></dt><dd></dd>
<dt><strong>keys</strong><span class="classifier">list, default None</span></dt><dd><p>List of Column names to sort by. If None, all columns used
(Ignored if <cite>index=True</cite>)</p>
</dd>
<dt><strong>by_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Use index for sorting. <cite>keys</cite> input will be ignored if True</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Drop and ignore index during merge. Default range index will
be used in the output dataframe.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool, default True</span></dt><dd><p>Sorting is in ascending order, otherwise it is descending</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ nulls at the beginning, ‘last’ nulls at the end</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new, lexicographically sorted, DataFrame/Series.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.series.Series">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.series.</code><code class="sig-name descname">Series</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nan_as_null</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series" title="Permalink to this definition">¶</a></dt>
<dd><p>One-dimensional GPU array (including time series).</p>
<p>Labels need not be unique but must be a hashable type. The object
supports both integer- and label-based indexing and provides a
host of methods for performing operations involving the index.
Statistical methods from ndarray have been overridden to
automatically exclude missing data (currently represented
as null/NaN).</p>
<p>Operations between Series (+, -, /, , <a href="#id1"><span class="problematic" id="id2">*</span></a>) align values based on their
associated index values– they need not be the same length. The
result index will be the sorted union of the two indexes.</p>
<p><code class="docutils literal notranslate"><span class="pre">Series</span></code> objects are used as columns of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">array-like, Iterable, dict, or scalar value</span></dt><dd><p>Contains data stored in Series.</p>
</dd>
<dt><strong>index</strong><span class="classifier">array-like or Index (1d)</span></dt><dd><p>Values must be hashable and have the same length
as data. Non-unique index values are allowed. Will
default to RangeIndex (0, 1, 2, …, n) if not provided.
If both a dict and index sequence are used, the index will
override the keys found in the dict.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">str, numpy.dtype, or ExtensionDtype, optional</span></dt><dd><p>Data type for the output Series. If not specified,
this will be inferred from data.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>The name to give to the Series.</p>
</dd>
<dt><strong>nan_as_null</strong><span class="classifier">bool, Default True</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>/<code class="docutils literal notranslate"><span class="pre">True</span></code>, converts <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values to
<code class="docutils literal notranslate"><span class="pre">null</span></code> values.
If <code class="docutils literal notranslate"><span class="pre">False</span></code>, leaves <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values as is.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Attributes</dt>
<dd class="field-even"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.series.Series.cat" title="cudf.core.series.Series.cat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat</span></code></a></dt><dd><p>Accessor object for categorical properties of the Series values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.data" title="cudf.core.series.Series.data"><code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code></a></dt><dd><p>The gpu buffer for the data</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.dt" title="cudf.core.series.Series.dt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dt</span></code></a></dt><dd><p>Accessor object for datetimelike properties of the Series values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.dtype" title="cudf.core.series.Series.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p>dtype of the Series</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.empty" title="cudf.core.series.Series.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a></dt><dd><p>Indicator whether Series is empty.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.has_nulls" title="cudf.core.series.Series.has_nulls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">has_nulls</span></code></a></dt><dd><p>Indicator whether Series contains null values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.iloc" title="cudf.core.series.Series.iloc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iloc</span></code></a></dt><dd><p>Select values by position.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.index" title="cudf.core.series.Series.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a></dt><dd><p>The index object</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.is_monotonic" title="cudf.core.series.Series.is_monotonic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic</span></code></a></dt><dd><p>Return boolean if values in the object are monotonic_increasing.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.is_monotonic_decreasing" title="cudf.core.series.Series.is_monotonic_decreasing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic_decreasing</span></code></a></dt><dd><p>Return boolean if values in the object are monotonic_decreasing.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.is_monotonic_increasing" title="cudf.core.series.Series.is_monotonic_increasing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic_increasing</span></code></a></dt><dd><p>Return boolean if values in the object are monotonic_increasing.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.is_unique" title="cudf.core.series.Series.is_unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_unique</span></code></a></dt><dd><p>Return boolean if values in the object are unique.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.loc" title="cudf.core.series.Series.loc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">loc</span></code></a></dt><dd><p>Select values by label.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.name" title="cudf.core.series.Series.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>Returns name of the Series.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.ndim" title="cudf.core.series.Series.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.null_count" title="cudf.core.series.Series.null_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">null_count</span></code></a></dt><dd><p>Number of null values</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.nullable" title="cudf.core.series.Series.nullable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullable</span></code></a></dt><dd><p>A boolean indicating whether a null-mask is needed</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.nullmask" title="cudf.core.series.Series.nullmask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nullmask</span></code></a></dt><dd><p>The gpu buffer for the null-mask</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.shape" title="cudf.core.series.Series.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></dt><dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.str" title="cudf.core.series.Series.str"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></dt><dd><p>Vectorized string functions for Series and Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.valid_count" title="cudf.core.series.Series.valid_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">valid_count</span></code></a></dt><dd><p>Number of non-null values</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.values" title="cudf.core.series.Series.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a></dt><dd><p>Return a CuPy representation of the Series.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.values_host" title="cudf.core.series.Series.values_host"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values_host</span></code></a></dt><dd><p>Return a numpy representation of the Series.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.abs" title="cudf.core.series.Series.abs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">abs</span></code></a>(self)</p></td>
<td><p>Absolute value of each element of the series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.add" title="cudf.core.series.Series.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Addition of series and other, element-wise (binary operator add).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.all" title="cudf.core.series.Series.all"><code class="xref py py-obj docutils literal notranslate"><span class="pre">all</span></code></a>(self[, axis, bool_only, skipna, level])</p></td>
<td><p>Return whether all elements are True in Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.any" title="cudf.core.series.Series.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>(self[, axis, bool_only, skipna, level])</p></td>
<td><p>Return whether any elements is True in Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.append" title="cudf.core.series.Series.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(self, other[, ignore_index])</p></td>
<td><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.applymap" title="cudf.core.series.Series.applymap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">applymap</span></code></a>(self, udf[, out_dtype])</p></td>
<td><p>Apply an elementwise function to transform the values in the Column.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.argsort" title="cudf.core.series.Series.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>(self[, ascending, na_position])</p></td>
<td><p>Returns a Series of int64 index that will sort the series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.as_index" title="cudf.core.series.Series.as_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_index</span></code></a>(self)</p></td>
<td><p>Returns a new Series with a RangeIndex.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.as_mask" title="cudf.core.series.Series.as_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_mask</span></code></a>(self)</p></td>
<td><p>Convert booleans to bitmask</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.astype" title="cudf.core.series.Series.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(self, dtype[, copy, errors])</p></td>
<td><p>Cast the Series to the given dtype</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.ceil" title="cudf.core.series.Series.ceil"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ceil</span></code></a>(self)</p></td>
<td><p>Rounds each value upward to the smallest integral value not less than the original.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.copy" title="cudf.core.series.Series.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self[, deep])</p></td>
<td><p>Make a copy of this object’s indices and data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.corr" title="cudf.core.series.Series.corr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">corr</span></code></a>(self, other[, method, min_periods])</p></td>
<td><p>Calculates the sample correlation between two Series, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.count" title="cudf.core.series.Series.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(self[, level])</p></td>
<td><p>Return number of non-NA/null observations in the Series</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.cov" title="cudf.core.series.Series.cov"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cov</span></code></a>(self, other[, min_periods])</p></td>
<td><p>Compute covariance with Series, excluding missing values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.cummax" title="cudf.core.series.Series.cummax"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummax</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative maximum of the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.cummin" title="cudf.core.series.Series.cummin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cummin</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative minimum of the Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.cumprod" title="cudf.core.series.Series.cumprod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumprod</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative product of the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.cumsum" title="cudf.core.series.Series.cumsum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cumsum</span></code></a>(self[, axis, skipna])</p></td>
<td><p>Return cumulative sum of the Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.describe" title="cudf.core.series.Series.describe"><code class="xref py py-obj docutils literal notranslate"><span class="pre">describe</span></code></a>(self[, percentiles, include, exclude])</p></td>
<td><p>Compute summary statistics of a Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.diff" title="cudf.core.series.Series.diff"><code class="xref py py-obj docutils literal notranslate"><span class="pre">diff</span></code></a>(self[, periods])</p></td>
<td><p>Calculate the difference between values at positions i and i - N in an array and store the output in a new array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.digitize" title="cudf.core.series.Series.digitize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">digitize</span></code></a>(self, bins[, right])</p></td>
<td><p>Return the indices of the bins to which each value in series belongs.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.drop_duplicates" title="cudf.core.series.Series.drop_duplicates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">drop_duplicates</span></code></a>(self[, keep, inplace, …])</p></td>
<td><p>Return Series with duplicate values removed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.dropna" title="cudf.core.series.Series.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropna</span></code></a>(self)</p></td>
<td><p>Return a Series with null values removed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.eq" title="cudf.core.series.Series.eq"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eq</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Equal to of series and other, element-wise (binary operator eq).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.equals" title="cudf.core.series.Series.equals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equals</span></code></a>(self, other)</p></td>
<td><p>Test whether two objects contain the same elements.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.factorize" title="cudf.core.series.Series.factorize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">factorize</span></code></a>(self[, na_sentinel])</p></td>
<td><p>Encode the input values as integer labels</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.fillna" title="cudf.core.series.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fillna</span></code></a>(self, value[, method, axis, inplace, …])</p></td>
<td><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code> without changing the series’ type.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.floor" title="cudf.core.series.Series.floor"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floor</span></code></a>(self)</p></td>
<td><p>Rounds each value downward to the largest integral value not greater than the original.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.floordiv" title="cudf.core.series.Series.floordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">floordiv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Integer division of series and other, element-wise (binary operator floordiv).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.from_arrow" title="cudf.core.series.Series.from_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_arrow</span></code></a>(s)</p></td>
<td><p>Convert from a PyArrow Array.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.from_categorical" title="cudf.core.series.Series.from_categorical"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_categorical</span></code></a>(categorical[, codes])</p></td>
<td><p>Creates from a pandas.Categorical</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.from_masked_array" title="cudf.core.series.Series.from_masked_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_masked_array</span></code></a>(data, mask[, null_count])</p></td>
<td><p>Create a Series with null-mask.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.from_pandas" title="cudf.core.series.Series.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(s[, nan_as_null])</p></td>
<td><p>Convert from a Pandas Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.ge" title="cudf.core.series.Series.ge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ge</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Greater than or equal to of series and other, element-wise (binary operator ge).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.groupby" title="cudf.core.series.Series.groupby"><code class="xref py py-obj docutils literal notranslate"><span class="pre">groupby</span></code></a>(self[, by, group_series, level, …])</p></td>
<td><p>Group Series using a mapper or by a Series of columns.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.gt" title="cudf.core.series.Series.gt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gt</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Greater than of series and other, element-wise (binary operator gt).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.hash_encode" title="cudf.core.series.Series.hash_encode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_encode</span></code></a>(self, stop[, use_name])</p></td>
<td><p>Encode column values as ints in [0, stop) using hash function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.hash_values" title="cudf.core.series.Series.hash_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">hash_values</span></code></a>(self)</p></td>
<td><p>Compute the hash of values in this column.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.head" title="cudf.core.series.Series.head"><code class="xref py py-obj docutils literal notranslate"><span class="pre">head</span></code></a>(self[, n])</p></td>
<td><p>Return the first <cite>n</cite> rows.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.isin" title="cudf.core.series.Series.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isin</span></code></a>(self, values)</p></td>
<td><p>Check whether values are contained in Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.kurt" title="cudf.core.series.Series.kurt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurt</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return Fisher’s unbiased kurtosis of a sample.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.kurtosis" title="cudf.core.series.Series.kurtosis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">kurtosis</span></code></a>(self[, axis, skipna, level, …])</p></td>
<td><p>Return Fisher’s unbiased kurtosis of a sample.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.label_encoding" title="cudf.core.series.Series.label_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">label_encoding</span></code></a>(self, cats[, dtype, na_sentinel])</p></td>
<td><p>Perform label encoding</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.le" title="cudf.core.series.Series.le"><code class="xref py py-obj docutils literal notranslate"><span class="pre">le</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Less than or equal to of series and other, element-wise (binary operator le).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.lt" title="cudf.core.series.Series.lt"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lt</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Less than of series and other, element-wise (binary operator lt).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.max" title="cudf.core.series.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return the maximum of the values in the Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.mean" title="cudf.core.series.Series.mean"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mean</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return the mean of the values in the series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.median" title="cudf.core.series.Series.median"><code class="xref py py-obj docutils literal notranslate"><span class="pre">median</span></code></a>(self[, skipna])</p></td>
<td><p>Compute the median of the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.memory_usage" title="cudf.core.series.Series.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_usage</span></code></a>(self[, index, deep])</p></td>
<td><p>Return the memory usage of the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.min" title="cudf.core.series.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return the minimum of the values in the Series.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.mod" title="cudf.core.series.Series.mod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mod</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Modulo of series and other, element-wise (binary operator mod).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.mul" title="cudf.core.series.Series.mul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mul</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Multiplication of series and other, element-wise (binary operator mul).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.nans_to_nulls" title="cudf.core.series.Series.nans_to_nulls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nans_to_nulls</span></code></a>(self)</p></td>
<td><p>Convert nans (if any) to nulls</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.ne" title="cudf.core.series.Series.ne"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ne</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Not equal to of series and other, element-wise (binary operator ne).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.nlargest" title="cudf.core.series.Series.nlargest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nlargest</span></code></a>(self[, n, keep])</p></td>
<td><p>Returns a new Series of the <em>n</em> largest element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.nsmallest" title="cudf.core.series.Series.nsmallest"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsmallest</span></code></a>(self[, n, keep])</p></td>
<td><p>Returns a new Series of the <em>n</em> smallest element.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.nunique" title="cudf.core.series.Series.nunique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nunique</span></code></a>(self[, method, dropna])</p></td>
<td><p>Returns the number of unique values of the Series: approximate version, and exact version to be moved to libgdf</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.one_hot_encoding" title="cudf.core.series.Series.one_hot_encoding"><code class="xref py py-obj docutils literal notranslate"><span class="pre">one_hot_encoding</span></code></a>(self, cats[, dtype])</p></td>
<td><p>Perform one-hot-encoding</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.pow" title="cudf.core.series.Series.pow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pow</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Exponential power of series and other, element-wise (binary operator pow).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.prod" title="cudf.core.series.Series.prod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prod</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return product of the values in the series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.product" title="cudf.core.series.Series.product"><code class="xref py py-obj docutils literal notranslate"><span class="pre">product</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return product of the values in the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.quantile" title="cudf.core.series.Series.quantile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">quantile</span></code></a>(self[, q, interpolation, exact, …])</p></td>
<td><p>Return values at the given quantile.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.radd" title="cudf.core.series.Series.radd"><code class="xref py py-obj docutils literal notranslate"><span class="pre">radd</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Addition of series and other, element-wise (binary operator radd).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.reindex" title="cudf.core.series.Series.reindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reindex</span></code></a>(self[, index, copy])</p></td>
<td><p>Return a Series that conforms to a new index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rename" title="cudf.core.series.Series.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self[, index, copy])</p></td>
<td><p>Alter Series name</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.replace" title="cudf.core.series.Series.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self[, to_replace, value, inplace, …])</p></td>
<td><p>Replace values given in <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.reset_index" title="cudf.core.series.Series.reset_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset_index</span></code></a>(self[, drop, inplace])</p></td>
<td><p>Reset index to RangeIndex</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.reverse" title="cudf.core.series.Series.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>(self)</p></td>
<td><p>Reverse the Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rfloordiv" title="cudf.core.series.Series.rfloordiv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfloordiv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Integer division of series and other, element-wise (binary operator rfloordiv).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rmod" title="cudf.core.series.Series.rmod"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmod</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Modulo of series and other, element-wise (binary operator rmod).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rmul" title="cudf.core.series.Series.rmul"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rmul</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Multiplication of series and other, element-wise (binary operator rmul).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rolling" title="cudf.core.series.Series.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling</span></code></a>(self, window[, min_periods, center, …])</p></td>
<td><p>Rolling window calculations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.round" title="cudf.core.series.Series.round"><code class="xref py py-obj docutils literal notranslate"><span class="pre">round</span></code></a>(self[, decimals])</p></td>
<td><p>Round a Series to a configurable number of decimal places.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rpow" title="cudf.core.series.Series.rpow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpow</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Exponential power of series and other, element-wise (binary operator rpow).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.rsub" title="cudf.core.series.Series.rsub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsub</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Subtraction of series and other, element-wise (binary operator rsub).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.rtruediv" title="cudf.core.series.Series.rtruediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rtruediv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Floating division of series and other, element-wise (binary operator rtruediv).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.scale" title="cudf.core.series.Series.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>(self)</p></td>
<td><p>Scale values to [0, 1] in float64</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.set_index" title="cudf.core.series.Series.set_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_index</span></code></a>(self, index)</p></td>
<td><p>Returns a new Series with a different index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.set_mask" title="cudf.core.series.Series.set_mask"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_mask</span></code></a>(self, mask[, null_count])</p></td>
<td><p>Create new Series by setting a mask array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.skew" title="cudf.core.series.Series.skew"><code class="xref py py-obj docutils literal notranslate"><span class="pre">skew</span></code></a>(self[, axis, skipna, level, numeric_only])</p></td>
<td><p>Return unbiased Fisher-Pearson skew of a sample.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.sort_index" title="cudf.core.series.Series.sort_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_index</span></code></a>(self[, ascending])</p></td>
<td><p>Sort by the index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.sort_values" title="cudf.core.series.Series.sort_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort_values</span></code></a>(self[, axis, ascending, …])</p></td>
<td><p>Sort by the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.std" title="cudf.core.series.Series.std"><code class="xref py py-obj docutils literal notranslate"><span class="pre">std</span></code></a>(self[, axis, skipna, level, ddof, …])</p></td>
<td><p>Return sample standard deviation of the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.sub" title="cudf.core.series.Series.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Subtraction of series and other, element-wise (binary operator sub).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.sum" title="cudf.core.series.Series.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(self[, axis, skipna, dtype, level, …])</p></td>
<td><p>Return sum of the values in the Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.tail" title="cudf.core.series.Series.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tail</span></code></a>(self[, n])</p></td>
<td><p>Returns the last n rows as a new Series</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.take" title="cudf.core.series.Series.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(self, indices[, keep_index])</p></td>
<td><p>Return Series by taking values from the corresponding <em>indices</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_array" title="cudf.core.series.Series.to_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numpy array for the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_arrow" title="cudf.core.series.Series.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>(self)</p></td>
<td><p>Convert Series to a PyArrow Array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_dlpack" title="cudf.core.series.Series.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_frame" title="cudf.core.series.Series.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_frame</span></code></a>(self[, name])</p></td>
<td><p>Convert Series into a DataFrame</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_gpu_array" title="cudf.core.series.Series.to_gpu_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numba device array for the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_hdf" title="cudf.core.series.Series.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_hdf</span></code></a>(self, path_or_buf, key, *args, **kwargs)</p></td>
<td><p>Write the contained data to an HDF5 file using HDFStore.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_json" title="cudf.core.series.Series.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_json</span></code></a>(self[, path_or_buf])</p></td>
<td><p>Convert the cuDF object to a JSON string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_pandas" title="cudf.core.series.Series.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self[, index])</p></td>
<td><p>Convert to a Pandas Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.to_string" title="cudf.core.series.Series.to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_string</span></code></a>(self)</p></td>
<td><p>Convert to string</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.tolist" title="cudf.core.series.Series.tolist"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tolist</span></code></a>(self)</p></td>
<td><p>Return a list type from series data.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.truediv" title="cudf.core.series.Series.truediv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">truediv</span></code></a>(self, other[, fill_value, axis])</p></td>
<td><p>Floating division of series and other, element-wise (binary operator truediv).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.unique" title="cudf.core.series.Series.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(self)</p></td>
<td><p>Returns unique values of this Series.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.value_counts" title="cudf.core.series.Series.value_counts"><code class="xref py py-obj docutils literal notranslate"><span class="pre">value_counts</span></code></a>(self[, normalize, sort, …])</p></td>
<td><p>Return a Series containing counts of unique values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.series.Series.values_to_string" title="cudf.core.series.Series.values_to_string"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values_to_string</span></code></a>(self[, nrows])</p></td>
<td><p>Returns a list of string for each element.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.series.Series.var" title="cudf.core.series.Series.var"><code class="xref py py-obj docutils literal notranslate"><span class="pre">var</span></code></a>(self[, axis, skipna, level, ddof, …])</p></td>
<td><p>Return unbiased variance of the Series.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.series.Series.abs">
<code class="sig-name descname">abs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.abs" title="Permalink to this definition">¶</a></dt>
<dd><p>Absolute value of each element of the series.</p>
<p>Returns a new Series.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of series and other, element-wise
(binary operator add).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.all">
<code class="sig-name descname">all</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">bool_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.all" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether all elements are True in Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and
skipna is True, then the result will be True, as for an
empty row/column.
If skipna is False, then NA are treated as True, because
these are not equal to zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>bool_only</cite>, <cite>level</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">bool_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether any elements is True in Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If the entire row/column is NA and
skipna is True, then the result will be False, as for an
empty row/column.
If skipna is False, then NA are treated as True, because
these are not equal to zero.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>bool_only</cite>, <cite>level</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">any</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.append">
<code class="sig-name descname">append</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.append" title="Permalink to this definition">¶</a></dt>
<dd><p>Append values from another <code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object.
If <code class="docutils literal notranslate"><span class="pre">ignore_index=True</span></code>, the index is reset.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>other</strong><span class="classifier"><code class="docutils literal notranslate"><span class="pre">Series</span></code> or array-like object</span></dt><dd></dd>
<dt><strong>ignore_index</strong><span class="classifier">boolean, default False. If true, the index is reset.</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series equivalent to self concatenated with other</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.applymap">
<code class="sig-name descname">applymap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">udf</span></em>, <em class="sig-param"><span class="n">out_dtype</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.applymap" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply an elementwise function to transform the values in the Column.</p>
<p>The user function is expected to take one argument and return the
result, which will be stored to the output Series.  The function
cannot reference globals except for other simple scalar objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>udf</strong><span class="classifier">function</span></dt><dd><p>Either a callable python function or a python function already
decorated by <code class="docutils literal notranslate"><span class="pre">numba.cuda.jit</span></code> for call on the GPU as a device</p>
</dd>
<dt><strong>out_dtype</strong><span class="classifier">numpy.dtype; optional</span></dt><dd><p>The dtype for use in the output.
Only used for <code class="docutils literal notranslate"><span class="pre">numba.cuda.jit</span></code> decorated udf.
By default, the result will have the same dtype as the source.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>The mask and index are preserved.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The supported Python features are listed in</p>
<blockquote>
<div><p><a class="reference external" href="https://numba.pydata.org/numba-doc/dev/cuda/cudapysupported.html">https://numba.pydata.org/numba-doc/dev/cuda/cudapysupported.html</a></p>
</div></blockquote>
<p>with these exceptions:</p>
<ul class="simple">
<li><p>Math functions in <cite>cmath</cite> are not supported since <cite>libcudf</cite> does not
have complex number support and output of <cite>cmath</cite> functions are most
likely complex numbers.</p></li>
<li><p>These five functions in <cite>math</cite> are not supported since numba
generates multiple PTX functions from them</p>
<ul>
<li><p>math.sin()</p></li>
<li><p>math.cos()</p></li>
<li><p>math.tan()</p></li>
<li><p>math.gamma()</p></li>
<li><p>math.lgamma()</p></li>
</ul>
</li>
<li><p>Series with string dtypes are not supported in <cite>applymap</cite> method.</p></li>
<li><p>Global variables need to be re-defined explicitly inside
the udf, as numba considers them to be compile-time constants
and there is no known way to obtain value of the global variable.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Returning a Series of booleans using only a literal pattern.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">100</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>
<span class="go">0      1</span>
<span class="go">1     10</span>
<span class="go">2    -10</span>
<span class="go">3    200</span>
<span class="go">4    100</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">59</span><span class="p">])</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">4     True</span>
<span class="go">dtype: bool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="go">0        1</span>
<span class="go">1      100</span>
<span class="go">2      100</span>
<span class="go">3    40000</span>
<span class="go">4    10000</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span>
<span class="go">0        1.5</span>
<span class="go">1      105.0</span>
<span class="go">2       95.0</span>
<span class="go">3    40100.0</span>
<span class="go">4    10050.0</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cube_function</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">a</span> <span class="o">**</span> <span class="mi">3</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="n">cube_function</span><span class="p">)</span>
<span class="go">0          1</span>
<span class="go">1       1000</span>
<span class="go">2      -1000</span>
<span class="go">3    8000000</span>
<span class="go">4    1000000</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">custom_udf</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">5</span>
<span class="gp">... </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">... </span>        <span class="k">return</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">5</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">applymap</span><span class="p">(</span><span class="n">custom_udf</span><span class="p">)</span>
<span class="go">0      6</span>
<span class="go">1     15</span>
<span class="go">2    -15</span>
<span class="go">3    205</span>
<span class="go">4    105</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.argsort">
<code class="sig-name descname">argsort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">na_position</span><span class="o">=</span><span class="default_value">'last'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Series of int64 index that will sort the series.</p>
<p>Uses Thrust sort.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>result: Series</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.as_index">
<code class="sig-name descname">as_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.as_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series with a RangeIndex.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">,</span><span class="s1">'c'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">a    1</span>
<span class="go">b    2</span>
<span class="go">c    3</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">as_index</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.as_mask">
<code class="sig-name descname">as_mask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.as_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert booleans to bitmask</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>device array</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">errors</span><span class="o">=</span><span class="default_value">'raise'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Cast the Series to the given dtype</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">data type, or dict of column name -&gt; data type</span></dt><dd><p>Use a numpy.dtype or Python type to cast Series object to
the same type. Alternatively, use {col: dtype, …}, where col is a
series name and dtype is a numpy.dtype or Python type to cast to.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default False</span></dt><dd><p>Return a deep-copy when <code class="docutils literal notranslate"><span class="pre">copy=True</span></code>. Note by default
<code class="docutils literal notranslate"><span class="pre">copy=False</span></code> setting is used and hence changes to
values then may propagate to other cudf objects.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">{‘raise’, ‘ignore’, ‘warn’}, default ‘raise’</span></dt><dd><p>Control raising of exceptions on invalid data for provided dtype.
- <code class="docutils literal notranslate"><span class="pre">raise</span></code> : allow exceptions to be raised
- <code class="docutils literal notranslate"><span class="pre">ignore</span></code> : suppress exceptions. On error return original
object.
- <code class="docutils literal notranslate"><span class="pre">warn</span></code> : prints last exceptions as warnings and
return original object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>out</strong><span class="classifier">Series</span></dt><dd><p>Returns <code class="docutils literal notranslate"><span class="pre">self.copy(deep=copy)</span></code> if <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is the same
as <code class="docutils literal notranslate"><span class="pre">self.dtype</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.cat">
<em class="property">property </em><code class="sig-name descname">cat</code><a class="headerlink" href="#cudf.core.series.Series.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor object for categorical properties of the Series values.
Be aware that assigning to <cite>categories</cite> is a inplace operation,
while all methods return new categorical data per default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">Series or CategoricalIndex</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'category'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>
<span class="go">Int64Index([1, 2, 3], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">reorder_categories</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [3, 2, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">remove_categories</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0   null</span>
<span class="go">1      2</span>
<span class="go">2      3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">'abcde'</span><span class="p">))</span>
<span class="go">0   null</span>
<span class="go">1   null</span>
<span class="go">2   null</span>
<span class="go">dtype: category</span>
<span class="go">Categories (5, object): [a, b, c, d, e]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_ordered</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1 &lt; 2 &lt; 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_unordered</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.ceil">
<code class="sig-name descname">ceil</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.ceil" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value upward to the smallest integral value not less
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of this object’s indices and data.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">deep=True</span></code> (default), a new object will be created with a
copy of the calling object’s data and indices. Modifications to
the data or indices of the copy will not be reflected in the
original object (see notes below).
When <code class="docutils literal notranslate"><span class="pre">deep=False</span></code>, a new object will be created without copying
the calling object’s data or index (only references to the data
and index are copied). Any changes to the data of the original
will be reflected in the shallow copy (and vice versa).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep</strong><span class="classifier">bool, default True</span></dt><dd><p>Make a deep copy, including a copy of the data and the indices.
With <code class="docutils literal notranslate"><span class="pre">deep=False</span></code> neither the indices nor the data are copied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>copy</strong><span class="classifier">Series or DataFrame</span></dt><dd><p>Object type matches caller.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">a    1</span>
<span class="go">b    2</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_copy</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s_copy</span>
<span class="go">a    1</span>
<span class="go">b    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p><strong>Shallow copy versus default (deep) copy:</strong></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"b"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deep</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shallow</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Shallow copy shares data and index with original.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="ow">is</span> <span class="n">shallow</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">_column</span> <span class="ow">is</span> <span class="n">shallow</span><span class="o">.</span><span class="n">_column</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="n">shallow</span><span class="o">.</span><span class="n">index</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Deep copy has own copy of data and index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="ow">is</span> <span class="n">deep</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">values</span> <span class="ow">is</span> <span class="n">deep</span><span class="o">.</span><span class="n">values</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">index</span> <span class="ow">is</span> <span class="n">deep</span><span class="o">.</span><span class="n">index</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Updates to the data shared by shallow copy and original is reflected
in both; deep copy remains unchanged.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="p">[</span><span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shallow</span><span class="p">[</span><span class="s1">'b'</span><span class="p">]</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">a    3</span>
<span class="go">b    4</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shallow</span>
<span class="go">a    3</span>
<span class="go">b    4</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">deep</span>
<span class="go">a    1</span>
<span class="go">b    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.corr">
<code class="sig-name descname">corr</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'pearson'</span></em>, <em class="sig-param"><span class="n">min_periods</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.corr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the sample correlation between two Series,
excluding missing values.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser1</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="mf">0.62</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser2</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">,</span> <span class="mf">0.51</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser1</span><span class="o">.</span><span class="n">corr</span><span class="p">(</span><span class="n">ser2</span><span class="p">)</span>
<span class="go">-0.20454263717316112</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of non-NA/null observations in the Series</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>int</dt><dd><p>Number of non-null values in the Series.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>level</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.cov">
<code class="sig-name descname">cov</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">min_periods</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cov" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute covariance with Series, excluding missing values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series</span></dt><dd><p>Series with which to compute the covariance.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>float</dt><dd><p>Covariance between Series and other normalized by N-1
(unbiased estimator).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>min_periods</cite> parameter is not yet supported.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser1</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.13</span><span class="p">,</span> <span class="mf">0.62</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser2</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">0.12</span><span class="p">,</span> <span class="mf">0.26</span><span class="p">,</span> <span class="mf">0.51</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser1</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">ser2</span><span class="p">)</span>
<span class="go">-0.015750000000000004</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.cummax">
<code class="sig-name descname">cummax</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cummax" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative maximum of the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">cummax</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    5</span>
<span class="go">2    5</span>
<span class="go">3    5</span>
<span class="go">4    5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.cummin">
<code class="sig-name descname">cummin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cummin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative minimum of the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">cummin</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    1</span>
<span class="go">2    1</span>
<span class="go">3    1</span>
<span class="go">4    1</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.cumprod">
<code class="sig-name descname">cumprod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cumprod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative product of the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">cumprod</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    5</span>
<span class="go">2    10</span>
<span class="go">3    40</span>
<span class="go">4    120</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.cumsum">
<code class="sig-name descname">cumsum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.cumsum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return cumulative sum of the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA,
the result will be NA.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported is <cite>axis</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    6</span>
<span class="go">2    8</span>
<span class="go">3    12</span>
<span class="go">4    15</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.data">
<em class="property">property </em><code class="sig-name descname">data</code><a class="headerlink" href="#cudf.core.series.Series.data" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the data</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.describe">
<code class="sig-name descname">describe</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">percentiles</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">include</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">exclude</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.describe" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute summary statistics of a Series. For numeric
data, the output includes the minimum, maximum, mean, median,
standard deviation, and various quantiles. For object data, the output
includes the count, number of unique values, the most common value, and
the number of occurrences of the most common value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>percentiles</strong><span class="classifier">list-like, optional</span></dt><dd><p>The percentiles used to generate the output summary statistics.
If None, the default percentiles used are the 25th, 50th and 75th.
Values should be within the interval [0, 1].</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A DataFrame containing summary statistics of relevant columns from</dt><dd></dd>
<dt>the input DataFrame.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Describing a <code class="docutils literal notranslate"><span class="pre">Series</span></code> containing numeric values.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">describe</span><span class="p">())</span>
<span class="go">   stats   values</span>
<span class="go">0  count     10.0</span>
<span class="go">1   mean      5.5</span>
<span class="go">2    std  3.02765</span>
<span class="go">3    min      1.0</span>
<span class="go">4    25%      2.5</span>
<span class="go">5    50%      5.5</span>
<span class="go">6    75%      7.5</span>
<span class="go">7    max     10.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.diff">
<code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">periods</span><span class="o">=</span><span class="default_value">1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the difference between values at positions i and i - N in
an array and store the output in a new array.</p>
<p class="rubric">Notes</p>
<p>Diff currently only supports float and integer dtype columns with
no null values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.digitize">
<code class="sig-name descname">digitize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">bins</span></em>, <em class="sig-param"><span class="n">right</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.digitize" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the bins to which each value in series belongs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bins</strong><span class="classifier">np.array</span></dt><dd><p>1-D monotonically, increasing array with same type as this series.</p>
</dd>
<dt><strong>right</strong><span class="classifier">bool</span></dt><dd><p>Indicates whether interval contains the right or left bin edge.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series containing the indices.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Monotonicity of bins is assumed and not checked.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.drop_duplicates">
<code class="sig-name descname">drop_duplicates</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">'first'</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.drop_duplicates" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series with duplicate values removed</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series with null values removed.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.dt">
<em class="property">property </em><code class="sig-name descname">dt</code><a class="headerlink" href="#cudf.core.series.Series.dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor object for datetimelike properties of the Series values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>A Series indexed like the original Series.</dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError if the Series does not contain datetimelike values.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">hour</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">second</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">dt</span><span class="o">.</span><span class="n">day</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#cudf.core.series.Series.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p>dtype of the Series</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.empty">
<em class="property">property </em><code class="sig-name descname">empty</code><a class="headerlink" href="#cudf.core.series.Series.empty" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator whether Series is empty.</p>
<p>True if Series is entirely empty (no items).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd><p>If Series is empty, return True, if not return False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.eq">
<code class="sig-name descname">eq</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.eq" title="Permalink to this definition">¶</a></dt>
<dd><p>Equal to of series and other, element-wise
(binary operator eq).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Test whether two objects contain the same elements.
This function allows two Series or DataFrames to be compared against
each other to see if they have the same shape and elements. NaNs in
the same location are considered equal. The column headers do not
need to have the same type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or DataFrame</span></dt><dd><p>The other Series or DataFrame to be compared with the first.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bool</dt><dd><p>True if all elements are the same in both objects, False
otherwise.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">other</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">different</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">1.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">different</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.factorize">
<code class="sig-name descname">factorize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">na_sentinel</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.factorize" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode the input values as integer labels</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>(labels, cats)</strong><span class="classifier">(Series, Series)</span></dt><dd><ul class="simple">
<li><p><em>labels</em> contains the encoded values</p></li>
<li><p><em>cats</em> contains the categories in order that the N-th
item corresponds to the (N-1) code.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.fillna">
<code class="sig-name descname">fillna</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">limit</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.fillna" title="Permalink to this definition">¶</a></dt>
<dd><p>Fill null values with <code class="docutils literal notranslate"><span class="pre">value</span></code> without changing the series’ type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>value</strong><span class="classifier">scalar or Series-like</span></dt><dd><p>Value to use to fill nulls. If <cite>value</cite>’s dtype differs from the
series, the fill value will be cast to the column’s dtype before
applying the fill. If Series-like, null values are filled with the
values in corresponding indices of the given Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Copy with nulls filled.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.floor">
<code class="sig-name descname">floor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.floor" title="Permalink to this definition">¶</a></dt>
<dd><p>Rounds each value downward to the largest integral value not greater
than the original.</p>
<p>Returns a new Series.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.floordiv">
<code class="sig-name descname">floordiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.floordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer division of series and other, element-wise
(binary operator floordiv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.from_arrow">
<em class="property">classmethod </em><code class="sig-name descname">from_arrow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.from_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a PyArrow Array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">PyArrow Object</span></dt><dd><p>PyArrow Object which has to be converted to cudf Series.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pyarrow</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span>
<span class="go">&lt;pyarrow.lib.Int64Array object at 0x7f67007e07c0&gt;</span>
<span class="go">[</span>
<span class="go">1,</span>
<span class="go">2,</span>
<span class="go">3</span>
<span class="go">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">from_arrow</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.from_categorical">
<em class="property">classmethod </em><code class="sig-name descname">from_categorical</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">categorical</span></em>, <em class="sig-param"><span class="n">codes</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.from_categorical" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates from a pandas.Categorical</p>
<p>If <code class="docutils literal notranslate"><span class="pre">codes</span></code> is defined, use it instead of <code class="docutils literal notranslate"><span class="pre">categorical.codes</span></code></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.from_masked_array">
<em class="property">classmethod </em><code class="sig-name descname">from_masked_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">null_count</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.from_masked_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Series with null-mask.
This is equivalent to:</p>
<blockquote>
<div><p>Series(data).set_mask(mask, null_count=null_count)</p>
</div></blockquote>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>data</strong><span class="classifier">1D array-like</span></dt><dd><p>The values.  Null values must not be skipped.  They can appear
as garbage values.</p>
</dd>
<dt><strong>mask</strong><span class="classifier">1D array-like</span></dt><dd><p>The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong><span class="classifier">int, optional</span></dt><dd><p>The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.from_pandas">
<em class="property">classmethod </em><code class="sig-name descname">from_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">s</span></em>, <em class="sig-param"><span class="n">nan_as_null</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>s</strong><span class="classifier">Pandas Series object</span></dt><dd><p>A Pandas Series object which has to be converted
to cuDF Series.</p>
</dd>
<dt><strong>nan_as_null</strong><span class="classifier">bool, Default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>/<code class="docutils literal notranslate"><span class="pre">True</span></code>, converts <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values to
<code class="docutils literal notranslate"><span class="pre">null</span></code> values.
If <code class="docutils literal notranslate"><span class="pre">False</span></code>, leaves <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values as is.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pds</span><span class="p">)</span>
<span class="go">0    10.0</span>
<span class="go">1    20.0</span>
<span class="go">2    30.0</span>
<span class="go">3    null</span>
<span class="go">dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pds</span><span class="p">,</span> <span class="n">nan_as_null</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">0    10.0</span>
<span class="go">1    20.0</span>
<span class="go">2    30.0</span>
<span class="go">3     NaN</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.ge">
<code class="sig-name descname">ge</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.ge" title="Permalink to this definition">¶</a></dt>
<dd><p>Greater than or equal to of series and other, element-wise
(binary operator ge).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.groupby">
<code class="sig-name descname">groupby</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">by</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">group_series</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">group_keys</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">as_index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.groupby" title="Permalink to this definition">¶</a></dt>
<dd><p>Group Series using a mapper or by a Series of columns.</p>
<p>A groupby operation involves some combination of splitting the object,
applying a function, and combining the results. This can be used to
group large amounts of data and compute operations on these groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">mapping, function, label, or list of labels</span></dt><dd><p>Used to determine the groups for the groupby. If by is a
function, it’s called on each value of the object’s index.
If a dict or Series is passed, the Series or dict VALUES will
be used to determine the groups (the Series’ values are first
aligned; see .align() method). If an cupy array is passed, the
values are used as-is determine the groups. A label or list
of labels may be passed to group by the columns in self.
Notice that a tuple is interpreted as a (single) key.</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, level name, or sequence of such, default None</span></dt><dd><p>If the axis is a MultiIndex (hierarchical), group by a particular
level or levels.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool, default True</span></dt><dd><p>For aggregated output, return object with group labels as
the index. Only relevant for DataFrame input.
as_index=False is effectively “SQL-style” grouped output.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True</span></dt><dd><p>Sort group keys. Get better performance by turning this off.
Note this does not influence the order of observations within each
group. Groupby preserves the order of rows within each group.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>SeriesGroupBy</dt><dd><p>Returns a groupby object that contains information
about the groups.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">390.</span><span class="p">,</span> <span class="mf">350.</span><span class="p">,</span> <span class="mf">30.</span><span class="p">,</span> <span class="mf">20.</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'Falcon'</span><span class="p">,</span> <span class="s1">'Falcon'</span><span class="p">,</span> <span class="s1">'Parrot'</span><span class="p">,</span> <span class="s1">'Parrot'</span><span class="p">],</span>
<span class="gp">... </span>                <span class="n">name</span><span class="o">=</span><span class="s2">"Max Speed"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>
<span class="go">Falcon    390.0</span>
<span class="go">Falcon    350.0</span>
<span class="go">Parrot     30.0</span>
<span class="go">Parrot     20.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">Falcon    370.0</span>
<span class="go">Parrot     25.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">ser</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">Max Speed</span>
<span class="go">False     25.0</span>
<span class="go">True     370.0</span>
<span class="go">Name: Max Speed, dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.gt">
<code class="sig-name descname">gt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.gt" title="Permalink to this definition">¶</a></dt>
<dd><p>Greater than of series and other, element-wise
(binary operator gt).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.has_nulls">
<em class="property">property </em><code class="sig-name descname">has_nulls</code><a class="headerlink" href="#cudf.core.series.Series.has_nulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Indicator whether Series contains null values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd><p>If Series has atleast one null value, return True, if not
return False.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.hash_encode">
<code class="sig-name descname">hash_encode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">stop</span></em>, <em class="sig-param"><span class="n">use_name</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.hash_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Encode column values as ints in [0, stop) using hash function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>stop</strong><span class="classifier">int</span></dt><dd><p>The upper bound on the encoding range.</p>
</dd>
<dt><strong>use_name</strong><span class="classifier">bool</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> then combine hashed column values
with hashed column name. This is useful for when the same
values in different columns should be encoded
with different hashed values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>The encoded Series.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.hash_values">
<code class="sig-name descname">hash_values</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.hash_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the hash of values in this column.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.head">
<code class="sig-name descname">head</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.head" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the first <cite>n</cite> rows.
This function returns the first <cite>n</cite> rows for the object based
on position. It is useful for quickly testing if your object
has the right type of data in it.
For negative values of <cite>n</cite>, this function returns all rows except
the last <cite>n</cite> rows, equivalent to <code class="docutils literal notranslate"><span class="pre">df[:-n]</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, default 5</span></dt><dd><p>Number of rows to select.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>same type as caller</dt><dd><p>The first <cite>n</cite> rows of the caller object.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.series.Series.tail" title="cudf.core.series.Series.tail"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.tail</span></code></a></dt><dd><p>Returns the last <cite>n</cite> rows.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'alligator'</span><span class="p">,</span> <span class="s1">'bee'</span><span class="p">,</span> <span class="s1">'falcon'</span><span class="p">,</span> <span class="s1">'lion'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">,</span> <span class="s1">'parrot'</span><span class="p">,</span> <span class="s1">'shark'</span><span class="p">,</span> <span class="s1">'whale'</span><span class="p">,</span> <span class="s1">'zebra'</span><span class="p">])</span>        <span class="c1"># noqa E501</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span>
<span class="go">0    alligator</span>
<span class="go">1          bee</span>
<span class="go">2       falcon</span>
<span class="go">3         lion</span>
<span class="go">4       monkey</span>
<span class="go">5       parrot</span>
<span class="go">6        shark</span>
<span class="go">7        whale</span>
<span class="go">8        zebra</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Viewing the first 5 lines</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="go">0    alligator</span>
<span class="go">1          bee</span>
<span class="go">2       falcon</span>
<span class="go">3         lion</span>
<span class="go">4       monkey</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Viewing the first <cite>n</cite> lines (three in this case)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0    alligator</span>
<span class="go">1          bee</span>
<span class="go">2       falcon</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>For negative values of <cite>n</cite></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0    alligator</span>
<span class="go">1          bee</span>
<span class="go">2       falcon</span>
<span class="go">3         lion</span>
<span class="go">4       monkey</span>
<span class="go">5       parrot</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.iloc">
<em class="property">property </em><code class="sig-name descname">iloc</code><a class="headerlink" href="#cudf.core.series.Series.iloc" title="Permalink to this definition">¶</a></dt>
<dd><p>Select values by position.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.dataframe.Dataframe.iloc</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.index">
<em class="property">property </em><code class="sig-name descname">index</code><a class="headerlink" href="#cudf.core.series.Series.index" title="Permalink to this definition">¶</a></dt>
<dd><p>The index object</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.is_monotonic">
<em class="property">property </em><code class="sig-name descname">is_monotonic</code><a class="headerlink" href="#cudf.core.series.Series.is_monotonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean if values in the object are monotonic_increasing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.is_monotonic_decreasing">
<em class="property">property </em><code class="sig-name descname">is_monotonic_decreasing</code><a class="headerlink" href="#cudf.core.series.Series.is_monotonic_decreasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean if values in the object are monotonic_decreasing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.is_monotonic_increasing">
<em class="property">property </em><code class="sig-name descname">is_monotonic_increasing</code><a class="headerlink" href="#cudf.core.series.Series.is_monotonic_increasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean if values in the object are monotonic_increasing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.is_unique">
<em class="property">property </em><code class="sig-name descname">is_unique</code><a class="headerlink" href="#cudf.core.series.Series.is_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean if values in the object are unique.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">bool</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.isin">
<code class="sig-name descname">isin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether values are contained in Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">set or list-like</span></dt><dd><p>The sequence of values to test. Passing in a single string will
raise a TypeError. Instead, turn a single string into a list
of one element.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Series of booleans indicating if each element is in values.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>TypeError</dt><dd><p>If values is a string</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.kurt">
<code class="sig-name descname">kurt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.kurt" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Fisher’s unbiased kurtosis of a sample.</p>
<p>Kurtosis obtained using Fisher’s definition of
kurtosis (kurtosis of normal == 0.0). Normalized by N-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.kurtosis">
<code class="sig-name descname">kurtosis</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.kurtosis" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Fisher’s unbiased kurtosis of a sample.</p>
<p>Kurtosis obtained using Fisher’s definition of
kurtosis (kurtosis of normal == 0.0). Normalized by N-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.label_encoding">
<code class="sig-name descname">label_encoding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">cats</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">na_sentinel</span><span class="o">=</span><span class="default_value">- 1</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.label_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform label encoding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">sequence of input values</span></dt><dd></dd>
<dt><strong>dtype: numpy.dtype; optional</strong></dt><dd><p>Specifies the output dtype.  If <cite>None</cite> is given, the
smallest possible integer dtype (starting with np.int8)
is used.</p>
</dd>
<dt><strong>na_sentinel</strong><span class="classifier">number</span></dt><dd><p>Value to indicate missing category.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A sequence of encoded labels with value between 0 and n-1 classes(cats)</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.le">
<code class="sig-name descname">le</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.le" title="Permalink to this definition">¶</a></dt>
<dd><p>Less than or equal to of series and other, element-wise
(binary operator le).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.loc">
<em class="property">property </em><code class="sig-name descname">loc</code><a class="headerlink" href="#cudf.core.series.Series.loc" title="Permalink to this definition">¶</a></dt>
<dd><p>Select values by label.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.dataframe.Dataframe.loc</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.lt">
<code class="sig-name descname">lt</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.lt" title="Permalink to this definition">¶</a></dt>
<dd><p>Less than of series and other, element-wise
(binary operator lt).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum of the values in the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data type</span></dt><dd><p>Data type to cast the result to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.mean">
<code class="sig-name descname">mean</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean of the values in the series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">6</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="go">15.5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.median">
<code class="sig-name descname">median</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of the series</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.memory_usage">
<code class="sig-name descname">memory_usage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the memory usage of the Series.</p>
<p>The memory usage can optionally include the contribution of
the index and of elements of <cite>object</cite> dtype.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Specifies whether to include the memory usage of the Series index.</p>
</dd>
<dt><strong>deep</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, introspect the data deeply by interrogating
<cite>object</cite> dtypes for system-level memory consumption, and include
it in the returned value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Bytes of memory consumed.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.DataFrame.memory_usage</span></code></dt><dd><p>Bytes consumed by a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">'a'</span><span class="p">,</span><span class="s1">'b'</span><span class="p">,</span><span class="s1">'c'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">()</span>
<span class="go">48</span>
</pre></div>
</div>
<p>Not including the index gives the size of the rest of the data, which
is necessarily smaller:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">memory_usage</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">24</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum of the values in the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data type</span></dt><dd><p>Data type to cast the result to.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.mod">
<code class="sig-name descname">mod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.mod" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo of series and other, element-wise
(binary operator mod).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.mul">
<code class="sig-name descname">mul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication of series and other, element-wise
(binary operator mul).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#cudf.core.series.Series.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns name of the Series.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.nans_to_nulls">
<code class="sig-name descname">nans_to_nulls</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nans_to_nulls" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert nans (if any) to nulls</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#cudf.core.series.Series.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. Series ndim is always 1.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.ne">
<code class="sig-name descname">ne</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.ne" title="Permalink to this definition">¶</a></dt>
<dd><p>Not equal to of series and other, element-wise
(binary operator ne).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.nlargest">
<code class="sig-name descname">nlargest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">'first'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nlargest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> largest element.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.nsmallest">
<code class="sig-name descname">nsmallest</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">5</span></em>, <em class="sig-param"><span class="n">keep</span><span class="o">=</span><span class="default_value">'first'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nsmallest" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series of the <em>n</em> smallest element.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.null_count">
<em class="property">property </em><code class="sig-name descname">null_count</code><a class="headerlink" href="#cudf.core.series.Series.null_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of null values</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.nullable">
<em class="property">property </em><code class="sig-name descname">nullable</code><a class="headerlink" href="#cudf.core.series.Series.nullable" title="Permalink to this definition">¶</a></dt>
<dd><p>A boolean indicating whether a null-mask is needed</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.nullmask">
<em class="property">property </em><code class="sig-name descname">nullmask</code><a class="headerlink" href="#cudf.core.series.Series.nullmask" title="Permalink to this definition">¶</a></dt>
<dd><p>The gpu buffer for the null-mask</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.nunique">
<code class="sig-name descname">nunique</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'sort'</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of unique values of the Series: approximate version,
and exact version to be moved to libgdf</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.one_hot_encoding">
<code class="sig-name descname">one_hot_encoding</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">cats</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">'float64'</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.one_hot_encoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform one-hot-encoding</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cats</strong><span class="classifier">sequence of values</span></dt><dd><p>values representing each category.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">numpy.dtype</span></dt><dd><p>specifies the output dtype.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Sequence</dt><dd><p>A sequence of new series for each category. Its length is
determined by the length of <code class="docutils literal notranslate"><span class="pre">cats</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.pow">
<code class="sig-name descname">pow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.pow" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential power of series and other, element-wise
(binary operator pow).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.prod">
<code class="sig-name descname">prod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.prod" title="Permalink to this definition">¶</a></dt>
<dd><p>Return product of the values in the series</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data type</span></dt><dd><p>Data type to cast the result to.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation.
If fewer than min_count non-NA values are present the result
will be NA.</p>
<p>The default being 0. This means the sum of an all-NA or empty
Series is 0, and the product of an all-NA or empty Series is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
<span class="go">120</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.product">
<code class="sig-name descname">product</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.product" title="Permalink to this definition">¶</a></dt>
<dd><p>Return product of the values in the Series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data type</span></dt><dd><p>Data type to cast the result to.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation.
If fewer than min_count non-NA values are present the result
will be NA.</p>
<p>The default being 0. This means the sum of an all-NA or empty
Series is 0, and the product of an all-NA or empty Series is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">product</span><span class="p">()</span>
<span class="go">120</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.quantile">
<code class="sig-name descname">quantile</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">q</span><span class="o">=</span><span class="default_value">0.5</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">exact</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">quant_index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.quantile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return values at the given quantile.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>q</strong><span class="classifier">float or array-like, default 0.5 (50% quantile)</span></dt><dd><p>0 &lt;= q &lt;= 1, the quantile(s) to compute</p>
</dd>
<dt><strong>interpolation</strong><span class="classifier">{’linear’, ‘lower’, ‘higher’, ‘midpoint’, ‘nearest’}</span></dt><dd><p>This optional parameter specifies the interpolation method to use,
when the desired quantile lies between two data points i and j:</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str</span></dt><dd><p>List of column names to include.</p>
</dd>
<dt><strong>exact</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use approximate or exact quantile algorithm.</p>
</dd>
<dt><strong>quant_index</strong><span class="classifier">boolean</span></dt><dd><p>Whether to use the list of quantiles as index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.radd">
<code class="sig-name descname">radd</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.radd" title="Permalink to this definition">¶</a></dt>
<dd><p>Addition of series and other, element-wise
(binary operator radd).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.reindex">
<code class="sig-name descname">reindex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series that conforms to a new index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible, default None</span></dt><dd></dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A new Series that conforms to the supplied index</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter Series name</p>
<p>Change Series.name with a scalar value</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Scalar, optional</span></dt><dd><p>Scalar to alter the Series.name attribute</p>
</dd>
<dt><strong>copy</strong><span class="classifier">boolean, default True</span></dt><dd><p>Also copy underlying data</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Supports scalar values only for changing name attribute</p></li>
<li><p>Not supporting : inplace, level</p></li>
</ul>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">to_replace</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">limit</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">regex</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values given in <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> with <code class="docutils literal notranslate"><span class="pre">value</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>to_replace</strong><span class="classifier">numeric, str or list-like</span></dt><dd><p>Value(s) to replace.</p>
<ul class="simple">
<li><dl class="simple">
<dt>numeric or str:</dt><dd><ul>
<li><p>values equal to <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> will be replaced
with <code class="docutils literal notranslate"><span class="pre">value</span></code></p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>list of numeric or str:</dt><dd><ul>
<li><p>If <code class="docutils literal notranslate"><span class="pre">value</span></code> is also list-like, <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> and
<code class="docutils literal notranslate"><span class="pre">value</span></code> must be of same length.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>value</strong><span class="classifier">numeric, str, list-like, or dict</span></dt><dd><p>Value(s) to replace <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> with.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, in place.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series</span></dt><dd><p>Series after replacement. The mask and index are preserved.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.series.Series.fillna" title="cudf.core.series.Series.fillna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Series.fillna</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Parameters that are currently not supported are: <cite>limit</cite>, <cite>regex</cite>,
<cite>method</cite></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.reset_index">
<code class="sig-name descname">reset_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">drop</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.reset_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset index to RangeIndex</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.reverse">
<code class="sig-name descname">reverse</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse the Series</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rfloordiv">
<code class="sig-name descname">rfloordiv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rfloordiv" title="Permalink to this definition">¶</a></dt>
<dd><p>Integer division of series and other, element-wise
(binary operator rfloordiv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rmod">
<code class="sig-name descname">rmod</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rmod" title="Permalink to this definition">¶</a></dt>
<dd><p>Modulo of series and other, element-wise
(binary operator rmod).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rmul">
<code class="sig-name descname">rmul</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplication of series and other, element-wise
(binary operator rmul).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">window</span></em>, <em class="sig-param"><span class="n">min_periods</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">center</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">win_type</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Rolling window calculations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>window</strong><span class="classifier">int or offset</span></dt><dd><p>Size of the window, i.e., the number of observations used
to calculate the statistic.
For datetime indexes, an offset can be provided instead
of an int. The offset must be convertible to a timedelta.
As opposed to a fixed window size, each window will be
sized to accommodate observations within the time period
specified by the offset.</p>
</dd>
<dt><strong>min_periods</strong><span class="classifier">int, optional</span></dt><dd><p>The minimum number of observations in the window that are
required to be non-null, so that the result is non-null.
If not provided or <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">min_periods</span></code> is equal to
the window size.</p>
</dd>
<dt><strong>center</strong><span class="classifier">bool, optional</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the result is set at the center of the window.
If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), the result is set at the right edge
of the window.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">Rolling</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
</pre></div>
</div>
<p>Rolling sum with window size 2.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3</span>
<span class="go">4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling sum with window size 2 and min_periods 1.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    3</span>
<span class="go">2    5</span>
<span class="go">3    3</span>
<span class="go">4    4</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">3    2</span>
<span class="go">4    2</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Rolling count with window size 3, but with the result set at the
center of the window.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
<span class="go">0    2</span>
<span class="go">1    3</span>
<span class="go">2    2</span>
<span class="go">3    2</span>
<span class="go">4    1 dtype: int64</span>
</pre></div>
</div>
<p>Rolling max with variable window size specified by an offset;
only valid for datetime index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:00'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:01'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:02'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:04'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:07'</span><span class="p">),</span>
<span class="gp">... </span>        <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:08'</span><span class="p">)</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">'2s'</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
<span class="go">2019-01-01T09:00:00.000    1</span>
<span class="go">2019-01-01T09:00:01.000    9</span>
<span class="go">2019-01-01T09:00:02.000    9</span>
<span class="go">2019-01-01T09:00:04.000    4</span>
<span class="go">2019-01-01T09:00:07.000</span>
<span class="go">2019-01-01T09:00:08.000    1</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Apply custom function on the window with the <em>apply</em> method</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">math</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">some_func</span><span class="p">(</span><span class="n">A</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">A</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">b</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_periods</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">0     4.0</span>
<span class="go">1     9.0</span>
<span class="go">2    15.0</span>
<span class="go">3    18.0</span>
<span class="go">4    21.0</span>
<span class="go">5    24.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
<p>And this also works for window rolling set by an offset</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">],</span>
<span class="gp">... </span>    <span class="n">index</span><span class="o">=</span><span class="p">[</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:00'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:01'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:02'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:04'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:07'</span><span class="p">),</span>
<span class="gp">... </span>         <span class="n">pd</span><span class="o">.</span><span class="n">Timestamp</span><span class="p">(</span><span class="s1">'20190101 09:00:08'</span><span class="p">)</span>
<span class="gp">... </span>     <span class="p">],</span>
<span class="gp">... </span>    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="s1">'2s'</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">some_func</span><span class="p">))</span>
<span class="go">2019-01-01T09:00:00.000     4.0</span>
<span class="go">2019-01-01T09:00:01.000     9.0</span>
<span class="go">2019-01-01T09:00:02.000    11.0</span>
<span class="go">2019-01-01T09:00:04.000     7.0</span>
<span class="go">2019-01-01T09:00:07.000     8.0</span>
<span class="go">2019-01-01T09:00:08.000    17.0</span>
<span class="go">dtype: float64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.round">
<code class="sig-name descname">round</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">decimals</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.round" title="Permalink to this definition">¶</a></dt>
<dd><p>Round a Series to a configurable number of decimal places.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rpow">
<code class="sig-name descname">rpow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rpow" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential power of series and other, element-wise
(binary operator rpow).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rsub">
<code class="sig-name descname">rsub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rsub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction of series and other, element-wise
(binary operator rsub).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.rtruediv">
<code class="sig-name descname">rtruediv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.rtruediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Floating division of series and other, element-wise
(binary operator rtruediv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.scale">
<code class="sig-name descname">scale</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.scale" title="Permalink to this definition">¶</a></dt>
<dd><p>Scale values to [0, 1] in float64</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.set_index">
<code class="sig-name descname">set_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.set_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new Series with a different index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, Series-convertible</span></dt><dd><p>the new index or values for the new index</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.set_mask">
<code class="sig-name descname">set_mask</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">mask</span></em>, <em class="sig-param"><span class="n">null_count</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.set_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Create new Series by setting a mask array.</p>
<p>This will override the existing mask.  The returned Series will
reference the same data buffer as this Series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>mask</strong><span class="classifier">1D array-like</span></dt><dd><p>The null-mask.  Valid values are marked as <code class="docutils literal notranslate"><span class="pre">1</span></code>; otherwise <code class="docutils literal notranslate"><span class="pre">0</span></code>.
The mask bit given the data index <code class="docutils literal notranslate"><span class="pre">idx</span></code> is computed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">idx</span> <span class="o">//</span> <span class="mi">8</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mi">1</span>
</pre></div>
</div>
</dd>
<dt><strong>null_count</strong><span class="classifier">int, optional</span></dt><dd><p>The number of null values.
If None, it is calculated automatically.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.shape">
<em class="property">property </em><code class="sig-name descname">shape</code><a class="headerlink" href="#cudf.core.series.Series.shape" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple representing the dimensionality of the Series.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.skew">
<code class="sig-name descname">skew</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.skew" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased Fisher-Pearson skew of a sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.sort_index">
<code class="sig-name descname">sort_index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sort_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the index.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.sort_values">
<code class="sig-name descname">sort_values</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">kind</span><span class="o">=</span><span class="default_value">'quicksort'</span></em>, <em class="sig-param"><span class="n">na_position</span><span class="o">=</span><span class="default_value">'last'</span></em>, <em class="sig-param"><span class="n">ignore_index</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sort_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Sort by the values.</p>
<p>Sort a Series in ascending or descending order by some criterion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, sort values in ascending order, otherwise descending.</p>
</dd>
<dt><strong>na_position</strong><span class="classifier">{‘first’, ‘last’}, default ‘last’</span></dt><dd><p>‘first’ puts nulls at the beginning, ‘last’ puts nulls at the end.</p>
</dd>
<dt><strong>ignore_index</strong><span class="classifier">bool, default False</span></dt><dd><p>If True, index will not be sorted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>sorted_obj</strong><span class="classifier">cuDF Series</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<dl class="simple">
<dt>Difference from pandas:</dt><dd><ul class="simple">
<li><p>Not supporting: <cite>inplace</cite>, <cite>kind</cite></p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">sort_values</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">2    2</span>
<span class="go">4    3</span>
<span class="go">3    4</span>
<span class="go">1    5</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.std">
<code class="sig-name descname">std</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.std" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sample standard deviation of the Series.</p>
<p>Normalized by N-1 by default. This can be changed using
the ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations
is N - ddof, where N represents the number of elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.str">
<em class="property">property </em><code class="sig-name descname">str</code><a class="headerlink" href="#cudf.core.series.Series.str" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized string functions for Series and Index.</p>
<p>This mimics pandas <code class="docutils literal notranslate"><span class="pre">df.str</span></code> interface. nulls stay null
unless handled otherwise by a particular method.
Patterned after Python’s string methods, with some
inspiration from R’s stringr package.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.sub">
<code class="sig-name descname">sub</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sub" title="Permalink to this definition">¶</a></dt>
<dd><p>Subtraction of series and other, element-wise
(binary operator sub).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">min_count</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return sum of the values in the Series.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values when computing the result.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">data type</span></dt><dd><p>Data type to cast the result to.</p>
</dd>
<dt><strong>min_count</strong><span class="classifier">int, default 0</span></dt><dd><p>The required number of valid values to perform the operation.
If fewer than min_count non-NA values are present the result
will be NA.</p>
<p>The default being 0. This means the sum of an all-NA or empty
Series is 0, and the product of an all-NA or empty Series is 1.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite>, <cite>numeric_only</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">15</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.tail">
<code class="sig-name descname">tail</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">5</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.tail" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the last n rows as a new Series</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">3    1</span>
<span class="go">4    0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">indices</span></em>, <em class="sig-param"><span class="n">keep_index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series by taking values from the corresponding <em>indices</em>.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_array">
<code class="sig-name descname">to_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fillna</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numpy array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>Defaults to None, which will skip null values.
If it equals “pandas”, null values are filled with NaNs.
Non integral dtype is promoted to np.float64.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_arrow">
<code class="sig-name descname">to_arrow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series to a PyArrow Array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
<span class="go">&lt;pyarrow.lib.Int64Array object at 0x7f5e769499f0&gt;</span>
<span class="go">[</span>
<span class="go">-3,</span>
<span class="go">10,</span>
<span class="go">15,</span>
<span class="go">20</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_dlpack">
<code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_frame">
<code class="sig-name descname">to_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Series into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">str, default None</span></dt><dd><p>Name to be used for the column</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>cudf DataFrame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_gpu_array">
<code class="sig-name descname">to_gpu_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fillna</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_gpu_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numba device array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>See <em>fillna</em> in <code class="docutils literal notranslate"><span class="pre">.to_array</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_hdf">
<code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path_or_buf</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,
nor searchable.</p></li>
<li><p>‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p></li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_json">
<code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">path_or_buf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Series</dt><dd><ul>
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>DataFrame</dt><dd><ul>
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:
{‘split’,’records’,’index’,’columns’,’values’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The format of the JSON string</dt><dd><ul>
<li><p>‘split’ : dict like {‘index’ -&gt; [index],
‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}</p></li>
<li><p>‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]</p></li>
<li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p></li>
<li><p>‘columns’ : dict like {column -&gt; {index -&gt; value}}</p></li>
<li><p>‘values’ : just the values array</p></li>
<li><p>‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serializable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Boolean, Default True</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">index</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, converts the index of cudf.Series
and sets it to the pandas.Series. If <code class="docutils literal notranslate"><span class="pre">index</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>,
no index conversion is performed and pandas.Series will assign
a default index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span> <span class="o">=</span> <span class="n">ser</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pds</span>
<span class="go">0   -3</span>
<span class="go">1    2</span>
<span class="go">2    0</span>
<span class="go">dtype: int64</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">pds</span><span class="p">)</span>
<span class="go">&lt;class 'pandas.core.series.Series'&gt;</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.to_string">
<code class="sig-name descname">to_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to string</p>
<p>Uses Pandas formatting internals to produce output identical to Pandas.
Use the Pandas formatting settings directly in Pandas to control cuDF
output.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.tolist">
<code class="sig-name descname">tolist</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.tolist" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list type from series data.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>list</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.truediv">
<code class="sig-name descname">truediv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">fill_value</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">0</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.truediv" title="Permalink to this definition">¶</a></dt>
<dd><p>Floating division of series and other, element-wise
(binary operator truediv).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Series or scalar value</span></dt><dd></dd>
<dt><strong>fill_value</strong><span class="classifier">None or value</span></dt><dd><p>Value to fill nulls with before computation. If data in both
corresponding Series locations is null the result will be null</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns unique values of this Series.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.valid_count">
<em class="property">property </em><code class="sig-name descname">valid_count</code><a class="headerlink" href="#cudf.core.series.Series.valid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of non-null values</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.value_counts">
<code class="sig-name descname">value_counts</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">bins</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.value_counts" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series containing counts of unique values.</p>
<p>The resulting object will be in descending order so that
the first element is the most frequently-occurring element.
Excludes NA values by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>normalize</strong><span class="classifier">bool, default False</span></dt><dd><p>If True then the object returned will contain the
relative frequencies of the unique values. normalize == True
is not supported.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">bool, default True</span></dt><dd><p>Sort by frequencies.</p>
</dd>
<dt><strong>ascending</strong><span class="classifier">bool, default False</span></dt><dd><p>Sort in ascending order.</p>
</dd>
<dt><strong>bins</strong><span class="classifier">int, optional</span></dt><dd><p>Rather than count values, group them into half-open bins,
works with numeric data. Not yet supported.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default True</span></dt><dd><p>Don’t include counts of NaN and None.
dropna == False is not supported</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>result</strong><span class="classifier">Series contanining counts of unique values.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">value_counts</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">1.0    1</span>
<span class="go">2.0    2</span>
<span class="go">3.0    3</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#cudf.core.series.Series.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a CuPy representation of the Series.</p>
<p>Only the values in the Series will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">cupy.ndarray</span></dt><dd><p>The values of the Series.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">values</span>
<span class="go">array([  1, -10, 100,  20])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="go">&lt;class 'cupy.core.core.ndarray'&gt;</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.values_host">
<em class="property">property </em><code class="sig-name descname">values_host</code><a class="headerlink" href="#cudf.core.series.Series.values_host" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a numpy representation of the Series.</p>
<p>Only the values in the Series will be returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>out</strong><span class="classifier">numpy.ndarray</span></dt><dd><p>The values of the Series.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">values_host</span>
<span class="go">array([  1, -10, 100,  20])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">ser</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
<span class="go">&lt;class 'numpy.ndarray'&gt;</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.values_to_string">
<code class="sig-name descname">values_to_string</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">nrows</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.values_to_string" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of string for each element.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.series.Series.var">
<code class="sig-name descname">var</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipna</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ddof</span><span class="o">=</span><span class="default_value">1</span></em>, <em class="sig-param"><span class="n">numeric_only</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.series.Series.var" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unbiased variance of the Series.</p>
<p>Normalized by N-1 by default. This can be changed using the
ddof argument</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>skipna</strong><span class="classifier">bool, default True</span></dt><dd><p>Exclude NA/null values. If an entire row/column is NA, the result
will be NA.</p>
</dd>
<dt><strong>ddof</strong><span class="classifier">int, default 1</span></dt><dd><p>Delta Degrees of Freedom. The divisor used in calculations is
N - ddof, where N represents the number of elements.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>scalar</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are <cite>axis</cite>, <cite>level</cite> and
<cite>numeric_only</cite></p>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="strings">
<h2>Strings<a class="headerlink" href="#strings" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.column.string.StringMethods">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.column.string.</code><code class="sig-name descname">StringMethods</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">column</span></em>, <em class="sig-param"><span class="n">parent</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized string functions for Series and Index.</p>
<p>This mimics pandas <code class="docutils literal notranslate"><span class="pre">df.str</span></code> interface. nulls stay null
unless handled otherwise by a particular method.
Patterned after Python’s string methods, with some
inspiration from R’s stringr package.</p>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.byte_count" title="cudf.core.column.string.StringMethods.byte_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">byte_count</span></code></a>(self, **kwargs)</p></td>
<td><p>Computes the number of bytes of each string in the Series/Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.capitalize" title="cudf.core.column.string.StringMethods.capitalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">capitalize</span></code></a>(self, **kwargs)</p></td>
<td><p>Convert strings in the Series/Index to be capitalized.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.cat" title="cudf.core.column.string.StringMethods.cat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cat</span></code></a>(self[, others, sep, na_rep])</p></td>
<td><p>Concatenate strings in the Series/Index with given separator.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.center" title="cudf.core.column.string.StringMethods.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a>(self, width[, fillchar])</p></td>
<td><p>Filling left and right side of strings in the Series/Index with an additional character.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.character_ngrams" title="cudf.core.column.string.StringMethods.character_ngrams"><code class="xref py py-obj docutils literal notranslate"><span class="pre">character_ngrams</span></code></a>(self[, n])</p></td>
<td><p>Generate the n-grams from characters in a column of strings.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.character_tokenize" title="cudf.core.column.string.StringMethods.character_tokenize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">character_tokenize</span></code></a>(self, **kwargs)</p></td>
<td><p>Each string is split into individual characters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.code_points" title="cudf.core.column.string.StringMethods.code_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">code_points</span></code></a>(self, **kwargs)</p></td>
<td><p>Returns an array by filling it with the UTF-8 code point values for each character of each string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.contains" title="cudf.core.column.string.StringMethods.contains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code></a>(self, pat[, case, flags, na, regex])</p></td>
<td><p>Test if pattern or regex is contained within a string of a Series or Index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.count" title="cudf.core.column.string.StringMethods.count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">count</span></code></a>(self, pat[, flags])</p></td>
<td><p>Count occurrences of pattern in each string of the Series/Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.endswith" title="cudf.core.column.string.StringMethods.endswith"><code class="xref py py-obj docutils literal notranslate"><span class="pre">endswith</span></code></a>(self, pat, **kwargs)</p></td>
<td><p>Test if the end of each string element matches a pattern.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.extract" title="cudf.core.column.string.StringMethods.extract"><code class="xref py py-obj docutils literal notranslate"><span class="pre">extract</span></code></a>(self, pat[, flags, expand])</p></td>
<td><p>Extract capture groups in the regex <cite>pat</cite> as columns in a DataFrame.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.find" title="cudf.core.column.string.StringMethods.find"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find</span></code></a>(self, sub[, start, end])</p></td>
<td><p>Return lowest indexes in each strings in the Series/Index where the substring is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.findall" title="cudf.core.column.string.StringMethods.findall"><code class="xref py py-obj docutils literal notranslate"><span class="pre">findall</span></code></a>(self, pat[, flags])</p></td>
<td><p>Find all occurrences of pattern or regular expression in the Series/Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.get" title="cudf.core.column.string.StringMethods.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a>(self[, i])</p></td>
<td><p>Extract element from each component at specified position.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.htoi" title="cudf.core.column.string.StringMethods.htoi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">htoi</span></code></a>(self)</p></td>
<td><p>Returns integer value represented by each hex string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.index" title="cudf.core.column.string.StringMethods.index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">index</span></code></a>(self, sub[, start, end])</p></td>
<td><p>Return lowest indexes in each strings where the substring is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.insert" title="cudf.core.column.string.StringMethods.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(self[, start, repl])</p></td>
<td><p>Insert the specified string into each string in the specified position.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.ip2int" title="cudf.core.column.string.StringMethods.ip2int"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ip2int</span></code></a>(self)</p></td>
<td><p>This converts ip strings to integers</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are alphanumeric.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are alphabetic.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are decimal.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are digits.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isempty" title="cudf.core.column.string.StringMethods.isempty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isempty</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether each string is an empty string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string form floating value.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string form integer.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are lowercase.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are numeric.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are whitespace.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a>(self, **kwargs)</p></td>
<td><p>Check whether all characters in each string are uppercase.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.join" title="cudf.core.column.string.StringMethods.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(self, sep)</p></td>
<td><p>Join lists contained as elements in the Series/Index with passed delimiter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.len" title="cudf.core.column.string.StringMethods.len"><code class="xref py py-obj docutils literal notranslate"><span class="pre">len</span></code></a>(self, **kwargs)</p></td>
<td><p>Computes the length of each element in the Series/Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.ljust" title="cudf.core.column.string.StringMethods.ljust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ljust</span></code></a>(self, width[, fillchar])</p></td>
<td><p>Filling right side of strings in the Series/Index with an additional character.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.lower" title="cudf.core.column.string.StringMethods.lower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower</span></code></a>(self, **kwargs)</p></td>
<td><p>Converts all characters to lowercase.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.lstrip" title="cudf.core.column.string.StringMethods.lstrip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lstrip</span></code></a>(self[, to_strip])</p></td>
<td><p>Remove leading and trailing characters.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.match" title="cudf.core.column.string.StringMethods.match"><code class="xref py py-obj docutils literal notranslate"><span class="pre">match</span></code></a>(self, pat[, case, flags])</p></td>
<td><p>Determine if each string matches a regular expression.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.ngrams" title="cudf.core.column.string.StringMethods.ngrams"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ngrams</span></code></a>(self[, n, separator])</p></td>
<td><p>Generate the n-grams from a set of tokens, each record in series is treated a token.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.ngrams_tokenize" title="cudf.core.column.string.StringMethods.ngrams_tokenize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ngrams_tokenize</span></code></a>(self[, n, delimiter, separator])</p></td>
<td><p>Generate the n-grams using tokens from each string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.normalize_spaces" title="cudf.core.column.string.StringMethods.normalize_spaces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_spaces</span></code></a>(self, **kwargs)</p></td>
<td><p>Remove extra whitespace between tokens and trim whitespace from the beginning and the end of each string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.pad" title="cudf.core.column.string.StringMethods.pad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad</span></code></a>(self, width[, side, fillchar])</p></td>
<td><p>Pad strings in the Series/Index up to width.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.partition" title="cudf.core.column.string.StringMethods.partition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">partition</span></code></a>(self[, sep, expand])</p></td>
<td><p>Split the string at the first occurrence of sep.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.replace" title="cudf.core.column.string.StringMethods.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(self, pat, repl[, n, case, flags, regex])</p></td>
<td><p>Replace occurrences of pattern/regex in the Series/Index with some other string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.replace_tokens" title="cudf.core.column.string.StringMethods.replace_tokens"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_tokens</span></code></a>(self, targets, replacements)</p></td>
<td><p>The targets tokens are searched for within each string in the series and replaced with the corresponding replacements if found.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.replace_with_backrefs" title="cudf.core.column.string.StringMethods.replace_with_backrefs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace_with_backrefs</span></code></a>(self, pat, repl, **kwargs)</p></td>
<td><p>Use the <code class="docutils literal notranslate"><span class="pre">repl</span></code> back-ref template to create a new string with the extracted elements found using the <code class="docutils literal notranslate"><span class="pre">pat</span></code> expression.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.rfind" title="cudf.core.column.string.StringMethods.rfind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rfind</span></code></a>(self, sub[, start, end])</p></td>
<td><p>Return highest indexes in each strings in the Series/Index where the substring is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.rindex" title="cudf.core.column.string.StringMethods.rindex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rindex</span></code></a>(self, sub[, start, end])</p></td>
<td><p>Return highest indexes in each strings where the substring is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.rjust" title="cudf.core.column.string.StringMethods.rjust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rjust</span></code></a>(self, width[, fillchar])</p></td>
<td><p>Filling left side of strings in the Series/Index with an additional character.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.rpartition" title="cudf.core.column.string.StringMethods.rpartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpartition</span></code></a>(self[, sep, expand])</p></td>
<td><p>Split the string at the last occurrence of sep.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.rsplit" title="cudf.core.column.string.StringMethods.rsplit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsplit</span></code></a>(self[, pat, n, expand])</p></td>
<td><p>Split strings around given separator/delimiter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.rstrip" title="cudf.core.column.string.StringMethods.rstrip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rstrip</span></code></a>(self[, to_strip])</p></td>
<td><p>Remove leading and trailing characters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.slice" title="cudf.core.column.string.StringMethods.slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice</span></code></a>(self[, start, stop, step])</p></td>
<td><p>Slice substrings from each element in the Series or Index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.slice_from" title="cudf.core.column.string.StringMethods.slice_from"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_from</span></code></a>(self, starts, stops, **kwargs)</p></td>
<td><p>Return substring of each string using positions for each string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.slice_replace" title="cudf.core.column.string.StringMethods.slice_replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_replace</span></code></a>(self[, start, stop, repl])</p></td>
<td><p>Replace the specified section of each string with a new string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.split" title="cudf.core.column.string.StringMethods.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a>(self[, pat, n, expand])</p></td>
<td><p>Split strings around given separator/delimiter.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.startswith" title="cudf.core.column.string.StringMethods.startswith"><code class="xref py py-obj docutils literal notranslate"><span class="pre">startswith</span></code></a>(self, pat, **kwargs)</p></td>
<td><p>Test if the start of each string element matches a pattern.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.strip" title="cudf.core.column.string.StringMethods.strip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">strip</span></code></a>(self[, to_strip])</p></td>
<td><p>Remove leading and trailing characters.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.swapcase" title="cudf.core.column.string.StringMethods.swapcase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapcase</span></code></a>(self, **kwargs)</p></td>
<td><p>Change each lowercase character to uppercase and vice versa.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.title" title="cudf.core.column.string.StringMethods.title"><code class="xref py py-obj docutils literal notranslate"><span class="pre">title</span></code></a>(self, **kwargs)</p></td>
<td><p>Uppercase the first letter of each letter after a space and lowercase the rest.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.token_count" title="cudf.core.column.string.StringMethods.token_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">token_count</span></code></a>(self[, delimiter])</p></td>
<td><p>Each string is split into tokens using the provided delimiter.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.tokenize" title="cudf.core.column.string.StringMethods.tokenize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tokenize</span></code></a>(self[, delimiter])</p></td>
<td><p>Each string is split into tokens using the provided delimiter(s).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.translate" title="cudf.core.column.string.StringMethods.translate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate</span></code></a>(self, table, **kwargs)</p></td>
<td><p>Map all characters in the string through the given mapping table.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.upper" title="cudf.core.column.string.StringMethods.upper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper</span></code></a>(self, **kwargs)</p></td>
<td><p>Convert each string to uppercase.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.url_decode" title="cudf.core.column.string.StringMethods.url_decode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">url_decode</span></code></a>(self, **kwargs)</p></td>
<td><p>Returns a URL-decoded format of each string.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.url_encode" title="cudf.core.column.string.StringMethods.url_encode"><code class="xref py py-obj docutils literal notranslate"><span class="pre">url_encode</span></code></a>(self, **kwargs)</p></td>
<td><p>Returns a URL-encoded format of each string.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.wrap" title="cudf.core.column.string.StringMethods.wrap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wrap</span></code></a>(self, width, **kwargs)</p></td>
<td><p>Wrap long strings in the Series/Index to be formatted in paragraphs with length less than a given width.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.string.StringMethods.zfill" title="cudf.core.column.string.StringMethods.zfill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zfill</span></code></a>(self, width, **kwargs)</p></td>
<td><p>Pad strings in the Series/Index by prepending ‘0’ characters.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.byte_count">
<code class="sig-name descname">byte_count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.byte_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the number of bytes of each string in the Series/Index.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of int</span></dt><dd><p>A Series or Index of integer values
indicating the number of bytes of each strings in the
Series or Index.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"abc"</span><span class="p">,</span><span class="s2">"d"</span><span class="p">,</span><span class="s2">"ef"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">byte_count</span><span class="p">()</span>
<span class="go">0    3</span>
<span class="go">1    1</span>
<span class="go">2    2</span>
<span class="go">dtype: int32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"Hello"</span><span class="p">,</span> <span class="s2">"Bye"</span><span class="p">,</span> <span class="s2">"Thanks 😊"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">byte_count</span><span class="p">()</span>
<span class="go">0     5</span>
<span class="go">1     3</span>
<span class="go">2    11</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.capitalize">
<code class="sig-name descname">capitalize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.capitalize" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert strings in the Series/Index to be capitalized.
This only applies to ASCII characters at this time.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series or Index of object</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'CAPITALS'</span><span class="p">,</span> <span class="s1">'this is a sentence'</span><span class="p">,</span> <span class="s1">'SwApCaSe'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">0                 Lower</span>
<span class="go">1              Capitals</span>
<span class="go">2    This is a sentence</span>
<span class="go">3              Swapcase</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello, friend"</span><span class="p">,</span><span class="s2">"goodbye, friend"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">capitalize</span><span class="p">()</span>
<span class="go">0      Hello, friend</span>
<span class="go">1    Goodbye, friend</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.cat">
<code class="sig-name descname">cat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">others</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">na_rep</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.cat" title="Permalink to this definition">¶</a></dt>
<dd><p>Concatenate strings in the Series/Index with given separator.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">others</span></code> is specified, this function concatenates the Series/Index
and elements of others element-wise. If others is not passed, then all
values in the Series/Index are concatenated into a single string with
a given sep.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>others</strong><span class="classifier">Series or List of str</span></dt><dd><blockquote>
<div><p>Strings to be appended.
The number of strings must match <code class="docutils literal notranslate"><span class="pre">size()</span></code> of this instance.
This must be either a Series of string dtype or a Python
list of strings.</p>
</div></blockquote>
<dl class="simple">
<dt>sep<span class="classifier">str</span></dt><dd><p>If specified, this separator will be appended to each string
before appending the others.</p>
</dd>
<dt>na_rep<span class="classifier">str</span></dt><dd><p>This character will take the place of any null strings
(not empty strings) in either list.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">na_rep</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, and <code class="docutils literal notranslate"><span class="pre">others</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>,
missing values in the Series/Index are
omitted from the result.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">na_rep</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, and <code class="docutils literal notranslate"><span class="pre">others</span></code> is
not <code class="docutils literal notranslate"><span class="pre">None</span></code>, a row containing a missing value
in any of the columns (before concatenation)
will have a missing value in the result.</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>concat</strong><span class="classifier">str or Series/Index of str dtype</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">others</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code> is returned,
otherwise a <code class="docutils literal notranslate"><span class="pre">Series/Index</span></code> (same type as caller)
of str dtype is returned.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s1">' '</span><span class="p">)</span>
<span class="go">'a b d'</span>
</pre></div>
</div>
<p>By default, NA values in the Series are ignored. Using na_rep, they
can be given a representation:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s1">' '</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">'?'</span><span class="p">)</span>
<span class="go">'a b ? d'</span>
</pre></div>
</div>
<p>If others is specified, corresponding values are concatenated with
the separator. Result will be a Series of strings.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">)</span>
<span class="go">0     a,A</span>
<span class="go">1     b,B</span>
<span class="go">2    None</span>
<span class="go">3     d,D</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Missing values will remain missing in the result, but can again be
represented using na_rep</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">],</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">,</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0    a,A</span>
<span class="go">1    b,B</span>
<span class="go">2    -,C</span>
<span class="go">3    d,D</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>If sep is not specified, the values are concatenated without
separation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'C'</span><span class="p">,</span> <span class="s1">'D'</span><span class="p">],</span> <span class="n">na_rep</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0    aA</span>
<span class="go">1    bB</span>
<span class="go">2    -C</span>
<span class="go">3    dD</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.center">
<code class="sig-name descname">center</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">fillchar</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.center" title="Permalink to this definition">¶</a></dt>
<dd><p>Filling left and right side of strings in the Series/Index with an
additional character.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>Minimum width of resulting string;
additional characters will be filled
with fillchar.</p>
</dd>
<dt><strong>fillchar</strong><span class="classifier">str, default is ‘ ‘ (whitespace)</span></dt><dd><p>Additional character for filling.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Returns Series or Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">'d'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0       a</span>
<span class="go">1       b</span>
<span class="go">2    None</span>
<span class="go">3       d</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0       a</span>
<span class="go">1       b</span>
<span class="go">2    None</span>
<span class="go">3       d</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0      a-</span>
<span class="go">1      b-</span>
<span class="go">2    None</span>
<span class="go">3      d-</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0    --a--</span>
<span class="go">1    --b--</span>
<span class="go">2     None</span>
<span class="go">3    --d--</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0    --a---</span>
<span class="go">1    --b---</span>
<span class="go">2      None</span>
<span class="go">3    --d---</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.character_ngrams">
<code class="sig-name descname">character_ngrams</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.character_ngrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the n-grams from characters in a column of strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The degree of the n-gram (number of consecutive characters).
Default of 2 for bigrams.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'abcd'</span><span class="p">,</span><span class="s1">'efgh'</span><span class="p">,</span><span class="s1">'xyz'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">character_ngrams</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0    ab</span>
<span class="go">1    bc</span>
<span class="go">2    cd</span>
<span class="go">3    ef</span>
<span class="go">4    fg</span>
<span class="go">5    gh</span>
<span class="go">6    xy</span>
<span class="go">7    yz</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">character_ngrams</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0    abc</span>
<span class="go">1    bcd</span>
<span class="go">2    efg</span>
<span class="go">3    fgh</span>
<span class="go">4    xyz</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.character_tokenize">
<code class="sig-name descname">character_tokenize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.character_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Each string is split into individual characters.
The sequence returned contains each character as an individual string.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series or Index of object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"hello world"</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">"goodbye, thank you."</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">character_tokenize</span><span class="p">()</span>
<span class="go">0     h</span>
<span class="go">1     e</span>
<span class="go">2     l</span>
<span class="go">3     l</span>
<span class="go">4     o</span>
<span class="go">5</span>
<span class="go">6     w</span>
<span class="go">7     o</span>
<span class="go">8     r</span>
<span class="go">9     l</span>
<span class="go">10    d</span>
<span class="go">11    g</span>
<span class="go">12    o</span>
<span class="go">13    o</span>
<span class="go">14    d</span>
<span class="go">15    b</span>
<span class="go">16    y</span>
<span class="go">17    e</span>
<span class="go">18    ,</span>
<span class="go">19</span>
<span class="go">20    t</span>
<span class="go">21    h</span>
<span class="go">22    a</span>
<span class="go">23    n</span>
<span class="go">24    k</span>
<span class="go">25</span>
<span class="go">26    y</span>
<span class="go">27    o</span>
<span class="go">28    u</span>
<span class="go">29    .</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.code_points">
<code class="sig-name descname">code_points</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.code_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array by filling it with the UTF-8 code point
values for each character of each string.
This function uses the <code class="docutils literal notranslate"><span class="pre">len()</span></code> method to determine
the size of each sub-array of integers.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series or Index.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"xyz"</span><span class="p">,</span> <span class="s2">"éee"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">code_points</span><span class="p">()</span>
<span class="go">0       97</span>
<span class="go">1      120</span>
<span class="go">2      121</span>
<span class="go">3      122</span>
<span class="go">4    50089</span>
<span class="go">5      101</span>
<span class="go">6      101</span>
<span class="go">dtype: int32</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"abc"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">code_points</span><span class="p">()</span>
<span class="go">0    97</span>
<span class="go">1    98</span>
<span class="go">2    99</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.contains">
<code class="sig-name descname">contains</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">case</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">na</span><span class="o">=</span><span class="default_value">nan</span></em>, <em class="sig-param"><span class="n">regex</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.contains" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if pattern or regex is contained within a string of a Series or
Index.</p>
<p>Return boolean Series or Index based on whether a given pattern or
regex is contained within a string of a Series or Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str</span></dt><dd><p>Character sequence or regular expression.</p>
</dd>
<dt><strong>regex</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, assumes the pattern is a regular expression.
If False, treats the pattern as a literal string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of bool dtype</dt><dd><p>A Series/Index of boolean dtype indicating whether the given
pattern is contained within the string of each element of the
Series/Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The parameters <cite>case</cite>, <cite>flags</cite>, and <cite>na</cite> are not yet supported and
will raise a NotImplementedError if anything other than the default
value is set.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'Mouse'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'house and parrot'</span><span class="p">,</span> <span class="s1">'23'</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span>
<span class="go">0               Mouse</span>
<span class="go">1                 dog</span>
<span class="go">2    house and parrot</span>
<span class="go">3                  23</span>
<span class="go">4                None</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">'og'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">0    False</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">4     null</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Returning an Index of booleans using only a literal pattern.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'Mouse'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'house and parrot'</span><span class="p">,</span> <span class="s1">'23.0'</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">StringIndex</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ind</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">'23'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Index(['False', 'False', 'False', 'True', 'null'], dtype='object')</span>
</pre></div>
</div>
<p>Returning ‘house’ or ‘dog’ when either expression occurs in a string.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">'house|dog'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">0    False</span>
<span class="go">1     True</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">4     null</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Returning any digit using regular expression.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">'\d'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                               <span class="c1"># noqa W605</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3     True</span>
<span class="go">4     null</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Ensure <code class="docutils literal notranslate"><span class="pre">pat</span></code> is a not a literal pattern when <code class="docutils literal notranslate"><span class="pre">regex</span></code> is set
to True. Note in the following example one might expect
only <cite>s2[1]</cite> and <cite>s2[3]</cite> to return True. However,
‘.0’ as a regex matches any character followed by a 0.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'40'</span><span class="p">,</span> <span class="s1">'40.0'</span><span class="p">,</span> <span class="s1">'41'</span><span class="p">,</span> <span class="s1">'41.0'</span><span class="p">,</span> <span class="s1">'35'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s1">'.0'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">3     True</span>
<span class="go">4    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.count">
<code class="sig-name descname">count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.count" title="Permalink to this definition">¶</a></dt>
<dd><p>Count occurrences of pattern in each string of the Series/Index.</p>
<p>This function is used to count the number of times a particular
regex pattern is repeated in each of the string elements of the Series.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str</span></dt><dd><p>Valid regular expression.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><cite>flags</cite> parameter is currently not supported.</p></li>
<li><p>Some characters need to be escaped when passing
in pat. eg. <code class="docutils literal notranslate"><span class="pre">'$'</span></code> has a special meaning in regex
and must be escaped when finding this literal character.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'Aaba'</span><span class="p">,</span> <span class="s1">'Baca'</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">'CABA'</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="go">0       0</span>
<span class="go">1       0</span>
<span class="go">2       2</span>
<span class="go">3       2</span>
<span class="go">4    null</span>
<span class="go">5       0</span>
<span class="go">6       1</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
<p>Escape <code class="docutils literal notranslate"><span class="pre">'$'</span></code> to find the literal dollar sign.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'$'</span><span class="p">,</span> <span class="s1">'B'</span><span class="p">,</span> <span class="s1">'Aab$'</span><span class="p">,</span> <span class="s1">'$$ca'</span><span class="p">,</span> <span class="s1">'C$B$'</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">'\$'</span><span class="p">)</span>                                       <span class="c1"># noqa W605</span>
<span class="go">0    1</span>
<span class="go">1    0</span>
<span class="go">2    1</span>
<span class="go">3    2</span>
<span class="go">4    2</span>
<span class="go">5    0</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
<p>This is also available on Index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">StringIndex</span><span class="p">([</span><span class="s1">'A'</span><span class="p">,</span> <span class="s1">'A'</span><span class="p">,</span> <span class="s1">'Aaba'</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="go">Int64Index([0, 0, 2, 1], dtype='int64')</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.endswith">
<code class="sig-name descname">endswith</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.endswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the end of each string element matches a pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str or list-like</span></dt><dd><p>If <cite>str</cite> is an <cite>str</cite>, evaluates whether each string of
series ends with <cite>pat</cite>.
If <cite>pat</cite> is a list-like, evaluates whether <cite>self[i]</cite>
ends with <cite>pat[i]</cite>.
Regular expressions are not accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of bool</dt><dd><p>A Series of booleans indicating whether the given
pattern matches the end of each string element.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>na</cite> parameter is not yet supported, as cudf uses
native strings instead of Python objects.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'bat'</span><span class="p">,</span> <span class="s1">'bear'</span><span class="p">,</span> <span class="s1">'caT'</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0     bat</span>
<span class="go">1    bear</span>
<span class="go">2     caT</span>
<span class="go">3    None</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">'t'</span><span class="p">)</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3     null</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.extract">
<code class="sig-name descname">extract</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">expand</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.extract" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract capture groups in the regex <cite>pat</cite> as columns in a DataFrame.</p>
<p>For each subject string in the Series, extract groups from the first
match of regular expression <cite>pat</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str</span></dt><dd><p>Regular expression pattern with capturing groups.</p>
</dd>
<dt><strong>expand</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, return DataFrame with on column per capture group.
If False, return a Series/Index if there is one capture group or
DataFrame if there are multiple capture groups.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame or Series/Index</dt><dd><p>A DataFrame with one row for each subject string, and one column
for each group. If <cite>expand=False</cite> and <cite>pat</cite> has only one capture
group, then return a Series/Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The <cite>flags</cite> parameter is not yet supported and will raise a
NotImplementedError if anything other than the default value is passed.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'a1'</span><span class="p">,</span> <span class="s1">'b2'</span><span class="p">,</span> <span class="s1">'c3'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s1">'([ab])(\d)'</span><span class="p">)</span>                                <span class="c1"># noqa W605</span>
<span class="go">      0     1</span>
<span class="go">0     a     1</span>
<span class="go">1     b     2</span>
<span class="go">2  None  None</span>
</pre></div>
</div>
<p>A pattern with one group will return a DataFrame with one
column if expand=True.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s1">'[ab](\d)'</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>                     <span class="c1"># noqa W605</span>
<span class="go">      0</span>
<span class="go">0     1</span>
<span class="go">1     2</span>
<span class="go">2  None</span>
</pre></div>
</div>
<p>A pattern with one group will return a Series if expand=False.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="sa">r</span><span class="s1">'[ab](\d)'</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>                    <span class="c1"># noqa W605</span>
<span class="go">0       1</span>
<span class="go">1       2</span>
<span class="go">2    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.find">
<code class="sig-name descname">find</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sub</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">end</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.find" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lowest indexes in each strings in the Series/Index
where the substring is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>.
Return -1 on failure.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sub</strong><span class="classifier">str</span></dt><dd><p>Substring being searched.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Left edge index.</p>
</dd>
<dt><strong>end</strong><span class="classifier">int</span></dt><dd><p>Right edge index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of int</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'abc'</span><span class="p">,</span> <span class="s1">'a'</span><span class="p">,</span><span class="s1">'b'</span> <span class="p">,</span><span class="s1">'ddb'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="go">0    1</span>
<span class="go">1   -1</span>
<span class="go">2    0</span>
<span class="go">3    2</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
<p>Parameters such as <cite>start</cite> and <cite>end</cite> can also be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0    1</span>
<span class="go">1   -1</span>
<span class="go">2   -1</span>
<span class="go">3    2</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.findall">
<code class="sig-name descname">findall</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.findall" title="Permalink to this definition">¶</a></dt>
<dd><p>Find all occurrences of pattern or regular expression in the
Series/Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str</span></dt><dd><p>Pattern or regular expression.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>All non-overlapping matches of pattern or
regular expression in each string of this Series/Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><cite>flags</cite> parameter is currently not supported.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'Lion'</span><span class="p">,</span> <span class="s1">'Monkey'</span><span class="p">,</span> <span class="s1">'Rabbit'</span><span class="p">])</span>
</pre></div>
</div>
<p>The search for the pattern ‘Monkey’ returns one match:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">'Monkey'</span><span class="p">)</span>
<span class="go">        0</span>
<span class="go">0    None</span>
<span class="go">1  Monkey</span>
<span class="go">2    None</span>
</pre></div>
</div>
<p>When the pattern matches more than one string
in the Series, all matches are returned:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">'on'</span><span class="p">)</span>
<span class="go">      0</span>
<span class="go">0    on</span>
<span class="go">1    on</span>
<span class="go">2  None</span>
</pre></div>
</div>
<p>Regular expressions are supported too. For instance,
the search for all the strings ending with
the word ‘on’ is shown next:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">'on$'</span><span class="p">)</span>
<span class="go">      0</span>
<span class="go">0    on</span>
<span class="go">1  None</span>
<span class="go">2  None</span>
</pre></div>
</div>
<p>If the pattern is found more than once in the same
string, then multiple strings are returned as columns:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="go">      0     1</span>
<span class="go">0  None  None</span>
<span class="go">1  None  None</span>
<span class="go">2     b     b</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.get">
<code class="sig-name descname">get</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">i</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract element from each component at specified position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>i</strong><span class="classifier">int</span></dt><dd><p>Position of element to extract.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello world"</span><span class="p">,</span> <span class="s2">"rapids"</span><span class="p">,</span> <span class="s2">"cudf"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    hello world</span>
<span class="go">1         rapids</span>
<span class="go">2           cudf</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go">0    d</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0    e</span>
<span class="go">1    a</span>
<span class="go">2    u</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">get</span></code> also accepts negative index number.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0    d</span>
<span class="go">1    s</span>
<span class="go">2    f</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.htoi">
<code class="sig-name descname">htoi</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.htoi" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns integer value represented by each hex string.
String is interpretted to have hex (base-16) characters.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"1234"</span><span class="p">,</span> <span class="s2">"ABCDEF"</span><span class="p">,</span> <span class="s2">"1A2"</span><span class="p">,</span> <span class="s2">"cafe"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">htoi</span><span class="p">()</span>
<span class="go">0        4660</span>
<span class="go">1    11259375</span>
<span class="go">2         418</span>
<span class="go">3       51966</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.index">
<code class="sig-name descname">index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sub</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">end</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return lowest indexes in each strings where the substring
is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>. This is the same
as str.find except instead of returning -1, it raises a ValueError
when the substring is not found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sub</strong><span class="classifier">str</span></dt><dd><p>Substring being searched.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Left edge index.</p>
</dd>
<dt><strong>end</strong><span class="classifier">int</span></dt><dd><p>Right edge index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of object</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; import cudf
&gt;&gt;&gt; s = cudf.Series(['abc', 'a','b' ,'ddb'])
&gt;&gt;&gt; s.str.index('b')
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: substring not found
</pre></div>
</div>
<p>Parameters such as <cite>start</cite> and <cite>end</cite> can also be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'abc'</span><span class="p">,</span> <span class="s1">'abb'</span><span class="p">,</span><span class="s1">'ab'</span> <span class="p">,</span><span class="s1">'ddb'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0    1</span>
<span class="go">1    1</span>
<span class="go">2    1</span>
<span class="go">3    2</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.insert">
<code class="sig-name descname">insert</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">repl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.insert" title="Permalink to this definition">¶</a></dt>
<dd><p>Insert the specified string into each string in the specified
position.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Beginning position of the string to replace.
Default is beginning of the each string.
Specify -1 to insert at the end of each string.</p>
</dd>
<dt><strong>repl</strong><span class="classifier">str</span></dt><dd><p>String to insert into the specified position value.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>A new string series with the specified string
inserted at the specified position.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"abcdefghij"</span><span class="p">,</span> <span class="s2">"0123456789"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s1">'_'</span><span class="p">)</span>
<span class="go">0    ab_cdefghij</span>
<span class="go">1    01_23456789</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>When no <cite>repl</cite> is passed, nothing is inserted.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0    abcdefghij</span>
<span class="go">1    0123456789</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Negative values are also supported for <cite>start</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s1">'_'</span><span class="p">)</span>
<span class="go">0    abcdefghij_</span>
<span class="go">1    0123456789_</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.ip2int">
<code class="sig-name descname">ip2int</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.ip2int" title="Permalink to this definition">¶</a></dt>
<dd><p>This converts ip strings to integers</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"12.168.1.1"</span><span class="p">,</span> <span class="s2">"10.0.0.1"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ip2int</span><span class="p">()</span>
<span class="go">0    212336897</span>
<span class="go">1    167772161</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
<p>Returns 0’s if any string is not an IP.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"12.168.1.1"</span><span class="p">,</span> <span class="s2">"10.0.0.1"</span><span class="p">,</span> <span class="s2">"abc"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ip2int</span><span class="p">()</span>
<span class="go">0    212336897</span>
<span class="go">1    167772161</span>
<span class="go">2            0</span>
<span class="go">dtype: int64</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isalnum">
<code class="sig-name descname">isalnum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isalnum" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are alphanumeric.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isalnum">str.isalnum()</a>
for each element of the Series/Index. If a string has zero
characters, False is returned for that check.</p>
<p>Equivalent to: <code class="docutils literal notranslate"><span class="pre">isalpha()</span> <span class="pre">or</span> <span class="pre">isdigit()</span> <span class="pre">or</span> <span class="pre">isnumeric()</span> <span class="pre">or</span> <span class="pre">isdecimal()</span></code></p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the
same length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'one1'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Note that checks against characters mixed with
any additional punctuation or whitespace will
evaluate to false for an alphanumeric check.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'A B'</span><span class="p">,</span> <span class="s1">'1.5'</span><span class="p">,</span> <span class="s1">'3,000'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isalpha">
<code class="sig-name descname">isalpha</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are alphabetic.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isalpha">str.isalpha()</a>
for each element of the Series/Index.
If a string has zero characters, False is returned for that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same length
as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'one1'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isdecimal">
<code class="sig-name descname">isdecimal</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isdecimal" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are decimal.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isdecimal">str.isdecimal()</a>
for each element of the Series/Index.
If a string has zero characters, False is returned for
that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'23'</span><span class="p">,</span> <span class="s1">'³'</span><span class="p">,</span> <span class="s1">'⅕'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
</pre></div>
</div>
<p>The s3.str.isdecimal method checks for characters used to form
numbers in base 10.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s3</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isdecimal</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isdigit">
<code class="sig-name descname">isdigit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isdigit" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are digits.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isdigit">str.isdigit()</a>
for each element of the Series/Index.
If a string has zero characters, False is returned
for that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'23'</span><span class="p">,</span> <span class="s1">'³'</span><span class="p">,</span> <span class="s1">'⅕'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">s.str.isdigit</span></code> method is the same as <code class="docutils literal notranslate"><span class="pre">s.str.isdecimal</span></code> but
also includes special digits, like superscripted and
subscripted digits in unicode.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isempty">
<code class="sig-name descname">isempty</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether each string is an empty string.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same length as
the original Series/Index.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"1"</span><span class="p">,</span> <span class="s2">"abc"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="s2">" "</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isempty</span><span class="p">()</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">4    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isfloat">
<code class="sig-name descname">isfloat</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isfloat" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Check whether all characters in each string form floating value.</p>
<p>If a string has zero characters, False is returned for
that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>“, “9.9”, “9.9.9”])</dt><dd><div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isfloat</span><span class="p">()</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isinteger">
<code class="sig-name descname">isinteger</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isinteger" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string form integer.</p>
<p>If a string has zero characters, False is returned for
that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"1"</span><span class="p">,</span> <span class="s2">"0.1"</span><span class="p">,</span> <span class="s2">"+100"</span><span class="p">,</span> <span class="s2">"-15"</span><span class="p">,</span> <span class="s2">"abc"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isinteger</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3     True</span>
<span class="go">4    False</span>
<span class="go">dtype: bool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"this is plan text"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="s2">"10 10"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isinteger</span><span class="p">()</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.islower">
<code class="sig-name descname">islower</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.islower" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are lowercase.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.islower">str.islower()</a>
for each element of the Series/Index.
If a string has zero characters, False is returned
for that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'leopard'</span><span class="p">,</span> <span class="s1">'Golden Eagle'</span><span class="p">,</span> <span class="s1">'SNAKE'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">islower</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isnumeric">
<code class="sig-name descname">isnumeric</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isnumeric" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are numeric.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isnumeric">str.isnumeric()</a>
for each element of the Series/Index. If a
string has zero characters, False is returned for that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'one'</span><span class="p">,</span> <span class="s1">'one1'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s1</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">s1.str.isnumeric</span></code> method is the same as <code class="docutils literal notranslate"><span class="pre">s2.str.isdigit</span></code> but
also includes other characters that can represent
quantities such as unicode fractions.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'23'</span><span class="p">,</span> <span class="s1">'³'</span><span class="p">,</span> <span class="s1">'⅕'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s2</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isnumeric</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isspace">
<code class="sig-name descname">isspace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isspace" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are whitespace.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isspace">str.isspace()</a>
for each element of the Series/Index.
If a string has zero characters, False is returned
for that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same length as
the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isupper" title="cudf.core.column.string.StringMethods.isupper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isupper</span></code></a></dt><dd><p>Check whether all characters are uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">' '</span><span class="p">,</span> <span class="s1">'</span><span class="se">\t\r\n</span><span class="s1"> '</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span>
<span class="go">0     True</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.isupper">
<code class="sig-name descname">isupper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.isupper" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether all characters in each string are uppercase.</p>
<p>This is equivalent to running the Python string method
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.isupper">str.isupper()</a>
for each element of the Series/Index.
If a string has zero characters, False is returned
for that check.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of bool</span></dt><dd><p>Series or Index of boolean values with the same
length as the original Series/Index.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalnum" title="cudf.core.column.string.StringMethods.isalnum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalnum</span></code></a></dt><dd><p>Check whether all characters are alphanumeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isalpha" title="cudf.core.column.string.StringMethods.isalpha"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isalpha</span></code></a></dt><dd><p>Check whether all characters are alphabetic.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdecimal" title="cudf.core.column.string.StringMethods.isdecimal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdecimal</span></code></a></dt><dd><p>Check whether all characters are decimal.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isdigit" title="cudf.core.column.string.StringMethods.isdigit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isdigit</span></code></a></dt><dd><p>Check whether all characters are digits.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isinteger" title="cudf.core.column.string.StringMethods.isinteger"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isinteger</span></code></a></dt><dd><p>Check whether all characters are integer.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isnumeric" title="cudf.core.column.string.StringMethods.isnumeric"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isnumeric</span></code></a></dt><dd><p>Check whether all characters are numeric.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isfloat" title="cudf.core.column.string.StringMethods.isfloat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isfloat</span></code></a></dt><dd><p>Check whether all characters are float.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.islower" title="cudf.core.column.string.StringMethods.islower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">islower</span></code></a></dt><dd><p>Check whether all characters are lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.isspace" title="cudf.core.column.string.StringMethods.isspace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isspace</span></code></a></dt><dd><p>Check whether all characters are whitespace.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'leopard'</span><span class="p">,</span> <span class="s1">'Golden Eagle'</span><span class="p">,</span> <span class="s1">'SNAKE'</span><span class="p">,</span> <span class="s1">''</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">isupper</span><span class="p">()</span>
<span class="go">0    False</span>
<span class="go">1    False</span>
<span class="go">2     True</span>
<span class="go">3    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sep</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Join lists contained as elements in the Series/Index with passed
delimiter.</p>
<dl class="simple">
<dt>Raises<span class="classifier">NotImplementedError</span></dt><dd><p>Columns of arrays / lists are not yet supported.</p>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.len">
<code class="sig-name descname">len</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.len" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the length of each element in the Series/Index.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of int</span></dt><dd><p>A Series or Index of integer values
indicating the length of each element in the Series or Index.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"dog"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">len</span><span class="p">()</span>
<span class="go">0       3</span>
<span class="go">1       0</span>
<span class="go">2       1</span>
<span class="go">3    null</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.ljust">
<code class="sig-name descname">ljust</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">fillchar</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.ljust" title="Permalink to this definition">¶</a></dt>
<dd><p>Filling right side of strings in the Series/Index with an additional
character. Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.ljust">str.ljust()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>Minimum width of resulting string;
additional characters will be filled
with <code class="docutils literal notranslate"><span class="pre">fillchar</span></code>.</p>
</dd>
<dt><strong>fillchar</strong><span class="classifier">str, default ‘ ‘ (whitespace)</span></dt><dd><p>Additional character for filling, default is whitespace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Returns Series or Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello world"</span><span class="p">,</span> <span class="s2">"rapids ai"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s2">"_"</span><span class="p">)</span>
<span class="go">0    hello world</span>
<span class="go">1     rapids ai_</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span>  <span class="s2">"ab"</span><span class="p">,</span> <span class="s2">"__"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ljust</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s2">"-"</span><span class="p">)</span>
<span class="go">0     a</span>
<span class="go">1     -</span>
<span class="go">2    ab</span>
<span class="go">3    __</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.lower">
<code class="sig-name descname">lower</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.lower" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts all characters to lowercase.</p>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.lower">str.lower()</a>.</p>
<dl class="simple">
<dt>Returns<span class="classifier">Series or Index of object</span></dt><dd><p>A copy of the object with all strings converted to lowercase.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.upper" title="cudf.core.column.string.StringMethods.upper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper</span></code></a></dt><dd><p>Converts all characters to uppercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.title" title="cudf.core.column.string.StringMethods.title"><code class="xref py py-obj docutils literal notranslate"><span class="pre">title</span></code></a></dt><dd><p>Converts first character of each word to uppercase and remaining to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.capitalize" title="cudf.core.column.string.StringMethods.capitalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">capitalize</span></code></a></dt><dd><p>Converts first character to uppercase and remaining to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.swapcase" title="cudf.core.column.string.StringMethods.swapcase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapcase</span></code></a></dt><dd><p>Converts uppercase to lowercase and lowercase to uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'CAPITALS'</span><span class="p">,</span> <span class="s1">'this is a sentence'</span><span class="p">,</span> <span class="s1">'SwApCaSe'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="go">0                 lower</span>
<span class="go">1              capitals</span>
<span class="go">2    this is a sentence</span>
<span class="go">3              swapcase</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.lstrip">
<code class="sig-name descname">lstrip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">to_strip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.lstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove leading and trailing characters.</p>
<p>Strip whitespaces (including newlines)
or a set of specified characters from
each string in the Series/Index from left side.
Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.lstrip">str.lstrip()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>to_strip</strong><span class="classifier">str or None, default None</span></dt><dd><p>Specifying the set of characters to be removed.
All combinations of this set of characters will
be stripped. If None then whitespaces are removed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of object</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.strip" title="cudf.core.column.string.StringMethods.strip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">strip</span></code></a></dt><dd><p>Remove leading and trailing characters in Series/Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.rstrip" title="cudf.core.column.string.StringMethods.rstrip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rstrip</span></code></a></dt><dd><p>Remove trailing characters in Series/Index.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'1. Ant.  '</span><span class="p">,</span> <span class="s1">'2. Bee!</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'3. Cat?</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">'123.'</span><span class="p">)</span>
<span class="go">0     Ant.</span>
<span class="go">1     Bee!\n</span>
<span class="go">2     Cat?\t</span>
<span class="go">3       None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.match">
<code class="sig-name descname">match</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">case</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.match" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if each string matches a regular expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str</span></dt><dd><p>Character sequence or regular expression.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of boolean values.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Parameters currently not supported are: <cite>case</cite>, <cite>flags</cite> and <cite>na</cite>.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"rapids"</span><span class="p">,</span> <span class="s2">"ai"</span><span class="p">,</span> <span class="s2">"cudf"</span><span class="p">])</span>
</pre></div>
</div>
<p>Checking for strings starting with <cite>a</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="go">0    False</span>
<span class="go">1     True</span>
<span class="go">2    False</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
<p>Checking for strings starting with any of <cite>a</cite> or <cite>c</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s1">'[ac]'</span><span class="p">)</span>
<span class="go">0    False</span>
<span class="go">1     True</span>
<span class="go">2     True</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.ngrams">
<code class="sig-name descname">ngrams</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">separator</span><span class="o">=</span><span class="default_value">'_'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.ngrams" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the n-grams from a set of tokens, each record
in series is treated a token.</p>
<p>You can generate tokens from a Series instance using
the <code class="docutils literal notranslate"><span class="pre">Series.str.tokenize()</span></code> function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int</span></dt><dd><p>The degree of the n-gram (number of consecutive tokens).
Default of 2 for bigrams.</p>
</dd>
<dt><strong>separator</strong><span class="classifier">str</span></dt><dd><p>The separator to use between within an n-gram.
Default is ‘_’.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'this is my'</span><span class="p">,</span> <span class="s1">'favorite book'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'this is my'</span><span class="p">,</span> <span class="s1">'favorite book'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ngrams</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span>
<span class="go">0    this is my_favorite book</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'abc'</span><span class="p">,</span><span class="s1">'def'</span><span class="p">,</span><span class="s1">'xyz'</span><span class="p">,</span><span class="s1">'hhh'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">str_series</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ngrams</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">"_"</span><span class="p">)</span>
<span class="go">0    abc_def</span>
<span class="go">1    def_xyz</span>
<span class="go">2    xyz_hhh</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.ngrams_tokenize">
<code class="sig-name descname">ngrams_tokenize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">2</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="n">separator</span><span class="o">=</span><span class="default_value">'_'</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.ngrams_tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the n-grams using tokens from each string.
This will tokenize each string and then generate ngrams for each
string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>n</strong><span class="classifier">int, Default 2.</span></dt><dd><p>The degree of the n-gram (number of consecutive tokens).</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str, Default is white-space.</span></dt><dd><p>The character used to locate the split points of each string.</p>
</dd>
<dt><strong>sep</strong><span class="classifier">str, Default is ‘_’.</span></dt><dd><p>The separator to use between tokens within an n-gram.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'this is the'</span><span class="p">,</span> <span class="s1">'best book'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">ngrams_tokenize</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">'_'</span><span class="p">)</span>
<span class="go">0      this_is</span>
<span class="go">1       is_the</span>
<span class="go">2    best_book</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.normalize_spaces">
<code class="sig-name descname">normalize_spaces</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.normalize_spaces" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove extra whitespace between tokens and trim whitespace
from the beginning and the end of each string.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series or Index of object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello </span><span class="se">\t</span><span class="s2"> world"</span><span class="p">,</span><span class="s2">" test string  "</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">normalize_spaces</span><span class="p">()</span>
<span class="go">0    hello world</span>
<span class="go">1    test string</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.pad">
<code class="sig-name descname">pad</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">side</span><span class="o">=</span><span class="default_value">'left'</span></em>, <em class="sig-param"><span class="n">fillchar</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.pad" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad strings in the Series/Index up to width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>Minimum width of resulting string;
additional characters will be filled with
character defined in fillchar.</p>
</dd>
<dt><strong>side</strong><span class="classifier">{‘left’, ‘right’, ‘both’}, default ‘left’</span></dt><dd><p>Side from which to fill resulting string.</p>
</dd>
<dt><strong>fillchar</strong><span class="classifier">str,  default ‘ ‘ (whitespace)</span></dt><dd><p>Additional character for filling, default is whitespace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of object</dt><dd><p>Returns Series or Index with minimum number
of char in object.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.rjust" title="cudf.core.column.string.StringMethods.rjust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rjust</span></code></a></dt><dd><p>Fills the left side of strings with an arbitrary character. Equivalent to <code class="docutils literal notranslate"><span class="pre">Series.str.pad(side='left')</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.ljust" title="cudf.core.column.string.StringMethods.ljust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ljust</span></code></a></dt><dd><p>Fills the right side of strings with an arbitrary character. Equivalent to <code class="docutils literal notranslate"><span class="pre">Series.str.pad(side='right')</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.center" title="cudf.core.column.string.StringMethods.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a></dt><dd><p>Fills boths sides of strings with an arbitrary character. Equivalent to <code class="docutils literal notranslate"><span class="pre">Series.str.pad(side='both')</span></code>.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.zfill" title="cudf.core.column.string.StringMethods.zfill"><code class="xref py py-obj docutils literal notranslate"><span class="pre">zfill</span></code></a></dt><dd><p>Pad strings in the Series/Index by prepending ‘0’ character. Equivalent to <code class="docutils literal notranslate"><span class="pre">Series.str.pad(side='left',</span> <span class="pre">fillchar='0')</span></code>.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"caribou"</span><span class="p">,</span> <span class="s2">"tiger"</span><span class="p">])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">0       caribou</span>
<span class="go">1         tiger</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">'right'</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0    caribou---</span>
<span class="go">1    tiger-----</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">'both'</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">0    -caribou--</span>
<span class="go">1    --tiger---</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.partition">
<code class="sig-name descname">partition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="n">expand</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.partition" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the string at the first occurrence of sep.</p>
<p>This method splits the string at the first occurrence
of sep, and returns 3 elements containing the part
before the separator, the separator itself, and the
part after the separator. If the separator is not found,
return 3 elements containing the string itself, followed
by two empty strings.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sep</strong><span class="classifier">str, default ‘ ‘ (whitespace)</span></dt><dd><p>String to split on.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame or MultiIndex</dt><dd><p>Returns a DataFrame / MultiIndex</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.rpartition" title="cudf.core.column.string.StringMethods.rpartition"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rpartition</span></code></a></dt><dd><p>Split the string at the last occurrence of sep.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.split" title="cudf.core.column.string.StringMethods.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a></dt><dd><p>Split strings around given separators.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The parameter <cite>expand</cite> is not yet supported and will raise a
<cite>NotImplementedError</cite> if anything other than the default value is set.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'Linda van der Berg'</span><span class="p">,</span> <span class="s1">'George Pitt-Rivers'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    Linda van der Berg</span>
<span class="go">1    George Pitt-Rivers</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">partition</span><span class="p">()</span>
<span class="go">        0  1             2</span>
<span class="go">0   Linda     van der Berg</span>
<span class="go">1  George      Pitt-Rivers</span>
</pre></div>
</div>
<p>To partition by something different than a space:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">'-'</span><span class="p">)</span>
<span class="go">                    0  1       2</span>
<span class="go">0  Linda van der Berg</span>
<span class="go">1         George Pitt  -  Rivers</span>
</pre></div>
</div>
<p>Also available on indices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">StringIndex</span><span class="p">([</span><span class="s1">'X 123'</span><span class="p">,</span> <span class="s1">'Y 999'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">StringIndex(['X 123' 'Y 999'], dtype='object')</span>
</pre></div>
</div>
<p>Which will create a MultiIndex:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">partition</span><span class="p">()</span>
<span class="go">MultiIndex(levels=[0    X</span>
<span class="go">1    Y</span>
<span class="go">dtype: object, 0</span>
<span class="go">dtype: object, 0    123</span>
<span class="go">1    999</span>
<span class="go">dtype: object],</span>
<span class="go">codes=   0  1  2</span>
<span class="go">0  0  0  0</span>
<span class="go">1  1  0  1)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.replace">
<code class="sig-name descname">replace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">case</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">flags</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">regex</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace occurrences of pattern/regex in the Series/Index with some
other string. Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.replace">str.replace()</a>
or <a class="reference external" href="https://docs.python.org/3/library/re.html#re.sub">re.sub()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str or list-like</span></dt><dd><p>String(s) to be replaced as a character sequence or regular
expression.</p>
</dd>
<dt><strong>repl</strong><span class="classifier">str or list-like</span></dt><dd><p>String(s) to be used as replacement.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default -1 (all)</span></dt><dd><p>Number of replacements to make from the start.</p>
</dd>
<dt><strong>regex</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, assumes the pattern is a regular expression.
If False, treats the pattern as a literal string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>A copy of the object with all matching occurrences of pat replaced
by repl.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The parameters <cite>case</cite> and <cite>flags</cite> are not yet supported and will raise
a <cite>NotImplementedError</cite> if anything other than the default value
is set.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'foo'</span><span class="p">,</span> <span class="s1">'fuz'</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0     foo</span>
<span class="go">1     fuz</span>
<span class="go">2    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>When pat is a string and regex is True (the default), the given pat
is compiled as a regex. When repl is a string, it replaces matching
regex patterns as with <code class="docutils literal notranslate"><span class="pre">re.sub()</span></code>. NaN value(s) in the Series
are left as is:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'f.'</span><span class="p">,</span> <span class="s1">'ba'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">0     bao</span>
<span class="go">1     baz</span>
<span class="go">2    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>When pat is a string and <cite>regex</cite> is False, every pat is replaced
with repl as with <code class="docutils literal notranslate"><span class="pre">str.replace()</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'f.'</span><span class="p">,</span> <span class="s1">'ba'</span><span class="p">,</span> <span class="n">regex</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">0     foo</span>
<span class="go">1     fuz</span>
<span class="go">2    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.replace_tokens">
<code class="sig-name descname">replace_tokens</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">targets</span></em>, <em class="sig-param"><span class="n">replacements</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.replace_tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>The targets tokens are searched for within each string in the series
and replaced with the corresponding replacements if found.
Tokens are identified by the delimiter character provided.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>targets</strong><span class="classifier">array-like, Sequence or Series</span></dt><dd><p>The tokens to search for inside each string.</p>
</dd>
<dt><strong>replacements</strong><span class="classifier">array-like, Sequence, Series or str</span></dt><dd><p>The strings to replace for each found target token found.
Alternately, this can be a single str instance and would be
used as replacement for each string found.</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">str</span></dt><dd><p>The character used to locate the tokens of each string.
Default is whitespace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"this is me"</span><span class="p">,</span> <span class="s2">"theme music"</span><span class="p">,</span> <span class="s2">""</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">targets</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"is"</span><span class="p">,</span> <span class="s2">"me"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace_tokens</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="s2">"_"</span><span class="p">)</span>
<span class="go">0       this _ _</span>
<span class="go">1    theme music</span>
<span class="go">2</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"this;is;me"</span><span class="p">,</span> <span class="s2">"theme;music"</span><span class="p">,</span> <span class="s2">""</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sr</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace_tokens</span><span class="p">(</span><span class="n">targets</span><span class="o">=</span><span class="n">targets</span><span class="p">,</span> <span class="n">replacements</span><span class="o">=</span><span class="s2">":"</span><span class="p">)</span>
<span class="go">0     this;is;me</span>
<span class="go">1    theme;music</span>
<span class="go">2</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.replace_with_backrefs">
<code class="sig-name descname">replace_with_backrefs</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="n">repl</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.replace_with_backrefs" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the <code class="docutils literal notranslate"><span class="pre">repl</span></code> back-ref template to create a new string
with the extracted elements found using the <code class="docutils literal notranslate"><span class="pre">pat</span></code> expression.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str</span></dt><dd><p>Regex with groupings to identify extract sections.
This should not be a compiled regex.</p>
</dd>
<dt><strong>repl</strong><span class="classifier">str</span></dt><dd><p>String template containing back-reference indicators.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"A543"</span><span class="p">,</span><span class="s2">"Z756"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">replace_with_backrefs</span><span class="p">(</span><span class="s1">'(\d)(\d)'</span><span class="p">,</span> <span class="s1">'V</span><span class="se">\2\1</span><span class="s1">'</span><span class="p">)</span>
<span class="go">0    AV453</span>
<span class="go">1    ZV576</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.rfind">
<code class="sig-name descname">rfind</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sub</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">end</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.rfind" title="Permalink to this definition">¶</a></dt>
<dd><p>Return highest indexes in each strings in the Series/Index
where the substring is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>.
Return -1 on failure. Equivalent to standard <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.rfind">str.rfind()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sub</strong><span class="classifier">str</span></dt><dd><p>Substring being searched.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Left edge index.</p>
</dd>
<dt><strong>end</strong><span class="classifier">int</span></dt><dd><p>Right edge index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of int</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.find" title="cudf.core.column.string.StringMethods.find"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find</span></code></a></dt><dd><p>Return lowest indexes in each strings.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"abc"</span><span class="p">,</span> <span class="s2">"hello world"</span><span class="p">,</span> <span class="s2">"rapids ai"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span>
<span class="go">0    0</span>
<span class="go">1   -1</span>
<span class="go">2    7</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
<p>Using <cite>start</cite> and <cite>end</cite> parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s1">'a'</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0   -1</span>
<span class="go">1   -1</span>
<span class="go">2   -1</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.rindex">
<code class="sig-name descname">rindex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sub</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">end</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.rindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Return highest indexes in each strings where the substring
is fully contained between <code class="docutils literal notranslate"><span class="pre">[start:end]</span></code>. This is the same
as <code class="docutils literal notranslate"><span class="pre">str.rfind</span></code> except instead of returning -1, it raises a
<code class="docutils literal notranslate"><span class="pre">ValueError</span></code> when the substring is not found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sub</strong><span class="classifier">str</span></dt><dd><p>Substring being searched.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int</span></dt><dd><p>Left edge index.</p>
</dd>
<dt><strong>end</strong><span class="classifier">int</span></dt><dd><p>Right edge index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of object</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span>&gt;&gt;&gt; import cudf
&gt;&gt;&gt; s = cudf.Series(['abc', 'a','b' ,'ddb'])
&gt;&gt;&gt; s.str.rindex('b')
Traceback (most recent call last):
File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: substring not found
</pre></div>
</div>
<p>Parameters such as <cite>start</cite> and <cite>end</cite> can also be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'abc'</span><span class="p">,</span> <span class="s1">'abb'</span><span class="p">,</span><span class="s1">'ab'</span> <span class="p">,</span><span class="s1">'ddb'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rindex</span><span class="p">(</span><span class="s1">'b'</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    1</span>
<span class="go">3    2</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.rjust">
<code class="sig-name descname">rjust</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="n">fillchar</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.rjust" title="Permalink to this definition">¶</a></dt>
<dd><p>Filling left side of strings in the Series/Index with an additional
character. Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.rjust">str.rjust()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>Minimum width of resulting string;
additional characters will be filled
with fillchar.</p>
</dd>
<dt><strong>fillchar</strong><span class="classifier">str, default ‘ ‘ (whitespace)</span></dt><dd><p>Additional character for filling, default is whitespace.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Returns Series or Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello world"</span><span class="p">,</span> <span class="s2">"rapids ai"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s2">"_"</span><span class="p">)</span>
<span class="go">0    _________hello world</span>
<span class="go">1    ___________rapids ai</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">""</span><span class="p">,</span>  <span class="s2">"ab"</span><span class="p">,</span> <span class="s2">"__"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">fillchar</span><span class="o">=</span><span class="s2">"-"</span><span class="p">)</span>
<span class="go">0     a</span>
<span class="go">1     -</span>
<span class="go">2    ab</span>
<span class="go">3    __</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.rpartition">
<code class="sig-name descname">rpartition</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="n">expand</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.rpartition" title="Permalink to this definition">¶</a></dt>
<dd><p>Split the string at the last occurrence of sep.</p>
<p>This method splits the string at the last occurrence
of sep, and returns 3 elements containing the part
before the separator, the separator itself, and the
part after the separator. If the separator is not
found, return 3 elements containing two empty strings,
followed by the string itself.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>sep</strong><span class="classifier">str, default ‘ ‘ (whitespace)</span></dt><dd><p>String to split on.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame or MultiIndex</dt><dd><p>Returns a DataFrame / MultiIndex</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The parameter <cite>expand</cite> is not yet supported and will raise a
<cite>NotImplementedError</cite> if anything other than the default value is set.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'Linda van der Berg'</span><span class="p">,</span> <span class="s1">'George Pitt-Rivers'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    Linda van der Berg</span>
<span class="go">1    George Pitt-Rivers</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rpartition</span><span class="p">()</span>
<span class="go">            0  1            2</span>
<span class="go">0  Linda van der            Berg</span>
<span class="go">1         George     Pitt-Rivers</span>
</pre></div>
</div>
<p>Also available on indices:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">StringIndex</span><span class="p">([</span><span class="s1">'X 123'</span><span class="p">,</span> <span class="s1">'Y 999'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">StringIndex(['X 123' 'Y 999'], dtype='object')</span>
</pre></div>
</div>
<p>Which will create a MultiIndex:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rpartition</span><span class="p">()</span>
<span class="go">MultiIndex(levels=[0    X</span>
<span class="go">1    Y</span>
<span class="go">dtype: object, 0</span>
<span class="go">dtype: object, 0    123</span>
<span class="go">1    999</span>
<span class="go">dtype: object],</span>
<span class="go">codes=   0  1  2</span>
<span class="go">0  0  0  0</span>
<span class="go">1  1  0  1)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.rsplit">
<code class="sig-name descname">rsplit</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">expand</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.rsplit" title="Permalink to this definition">¶</a></dt>
<dd><p>Split strings around given separator/delimiter.</p>
<p>Splits the string in the Series/Index from the end, at the
specified delimiter string. Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.rsplit">str.rsplit()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str, default ‘ ‘ (space)</span></dt><dd><p>String to split on, does not yet support regular expressions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default -1 (all)</span></dt><dd><p>Limit number of splits in output. <cite>None</cite>, 0, and -1 will all be
interpreted as “all splits”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame or MultiIndex</dt><dd><p>Returns a DataFrame/MultiIndex with each split as a column.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.split" title="cudf.core.column.string.StringMethods.split"><code class="xref py py-obj docutils literal notranslate"><span class="pre">split</span></code></a></dt><dd><p>Split strings around given separator/delimiter.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.split" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str.split</span></code></a></dt><dd><p>Standard library version for split.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.rsplit" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str.rsplit</span></code></a></dt><dd><p>Standard library version for rsplit.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The parameter <cite>expand</cite> is not yet supported and will raise a
<cite>NotImplementedError</cite> if anything other than the default value is
set. The handling of the n keyword depends on the number of
found splits:</p>
<blockquote>
<div><ul class="simple">
<li><p>If found splits &gt; n, make first n splits only</p></li>
<li><p>If found splits &lt;= n, make all splits</p></li>
<li><p>If for a certain row the number of found splits &lt; n,
append None for padding up to n.</p></li>
</ul>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"this is a regular sentence"</span><span class="p">,</span><span class="s2">"https://docs.python.org/3/tutorial/index.html"</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>      <span class="c1"># noqa E501</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">                                               0        1         2</span>
<span class="go">0                                      this is a  regular  sentence</span>
<span class="go">1  https://docs.python.org/3/tutorial/index.html     None      None</span>
<span class="go">2                                           None     None      None</span>
</pre></div>
</div>
<p>For slightly more complex use cases like splitting the
html document name from a url, a combination of parameter
settings can be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s2">"/"</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">                                    0           1</span>
<span class="go">0          this is a regular sentence        None</span>
<span class="go">1  https://docs.python.org/3/tutorial  index.html</span>
<span class="go">2                                None        None</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.rstrip">
<code class="sig-name descname">rstrip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">to_strip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.rstrip" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove leading and trailing characters.</p>
<p>Strip whitespaces (including newlines)
or a set of specified characters from each
string in the Series/Index from right side.
Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.rstrip">str.rstrip()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>to_strip</strong><span class="classifier">str or None, default None</span></dt><dd><p>Specifying the set of characters to
be removed. All combinations of this
set of characters will be stripped.
If None then whitespaces are removed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Returns Series or Index.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.strip" title="cudf.core.column.string.StringMethods.strip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">strip</span></code></a></dt><dd><p>Remove leading and trailing characters in Series/Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.lstrip" title="cudf.core.column.string.StringMethods.lstrip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lstrip</span></code></a></dt><dd><p>Remove leading characters in Series/Index.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'1. Ant.  '</span><span class="p">,</span> <span class="s1">'2. Bee!</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'3. Cat?</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1. Ant.</span>
<span class="go">1    2. Bee!\n</span>
<span class="go">2    3. Cat?\t</span>
<span class="go">3         None</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">'.!? </span><span class="se">\n\t</span><span class="s1">'</span><span class="p">)</span>
<span class="go">0    1. Ant</span>
<span class="go">1    2. Bee</span>
<span class="go">2    3. Cat</span>
<span class="go">3      None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.slice">
<code class="sig-name descname">slice</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice substrings from each element in the Series or Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">int, optional</span></dt><dd><p>Start position for slice operation.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, optional</span></dt><dd><p>Stop position for slice operation.</p>
</dd>
<dt><strong>step</strong><span class="classifier">int, optional</span></dt><dd><p>Step size for slice operation.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Series or Index from sliced substring from
original string object.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.slice_replace" title="cudf.core.column.string.StringMethods.slice_replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice_replace</span></code></a></dt><dd><p>Replace a slice with a string.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.get" title="cudf.core.column.string.StringMethods.get"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get</span></code></a></dt><dd><p>Return element at position. Equivalent to <code class="docutils literal notranslate"><span class="pre">Series.str.slice(start=i,</span> <span class="pre">stop=i+1)</span></code> with <code class="docutils literal notranslate"><span class="pre">i</span></code> being the position.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"koala"</span><span class="p">,</span> <span class="s2">"fox"</span><span class="p">,</span> <span class="s2">"chameleon"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0        koala</span>
<span class="go">1          fox</span>
<span class="go">2    chameleon</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0        oala</span>
<span class="go">1          ox</span>
<span class="go">2    hameleon</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">0    a</span>
<span class="go">1    x</span>
<span class="go">2    n</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">stop</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0    ko</span>
<span class="go">1    fo</span>
<span class="go">2    ch</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">0      kaa</span>
<span class="go">1       fx</span>
<span class="go">2    caeen</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0    kl</span>
<span class="go">1     f</span>
<span class="go">2    cm</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.slice_from">
<code class="sig-name descname">slice_from</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">starts</span></em>, <em class="sig-param"><span class="n">stops</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.slice_from" title="Permalink to this definition">¶</a></dt>
<dd><p>Return substring of each string using positions for each string.</p>
<p>The starts and stops parameters are of Column type.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>starts</strong><span class="classifier">Series</span></dt><dd><p>Beginning position of each the string to extract.
Default is beginning of the each string.</p>
</dd>
<dt><strong>stops</strong><span class="classifier">Series</span></dt><dd><p>Ending position of the each string to extract.
Default is end of each string.
Use -1 to specify to the end of that string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>A substring of each string using positions for each string.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello"</span><span class="p">,</span><span class="s2">"there"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    hello</span>
<span class="go">1    there</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">starts</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stops</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice_from</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">stops</span><span class="p">)</span>
<span class="go">0    ello</span>
<span class="go">1      re</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.slice_replace">
<code class="sig-name descname">slice_replace</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">start</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">repl</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.slice_replace" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace the specified section of each string with a new string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>start</strong><span class="classifier">int, optional</span></dt><dd><p>Beginning position of the string to replace.
Default is beginning of the each string.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, optional</span></dt><dd><p>Ending position of the string to replace.
Default is end of each string.</p>
</dd>
<dt><strong>repl</strong><span class="classifier">str, optional</span></dt><dd><p>String to insert into the specified position values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>A new string with the specified section of the string
replaced with <cite>repl</cite> string.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.slice" title="cudf.core.column.string.StringMethods.slice"><code class="xref py py-obj docutils literal notranslate"><span class="pre">slice</span></code></a></dt><dd><p>Just slicing without replacement.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'ab'</span><span class="p">,</span> <span class="s1">'abc'</span><span class="p">,</span> <span class="s1">'abdc'</span><span class="p">,</span> <span class="s1">'abcde'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0        a</span>
<span class="go">1       ab</span>
<span class="go">2      abc</span>
<span class="go">3     abdc</span>
<span class="go">4    abcde</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Specify just <cite>start</cite>, meaning replace <cite>start</cite> until the <cite>end</cite> of
the string with <cite>repl</cite>.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice_replace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">repl</span><span class="o">=</span><span class="s1">'X'</span><span class="p">)</span>
<span class="go">0    aX</span>
<span class="go">1    aX</span>
<span class="go">2    aX</span>
<span class="go">3    aX</span>
<span class="go">4    aX</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Specify just <cite>stop</cite>, meaning the <cite>start</cite> of the string to <cite>stop</cite>
is replaced with <cite>repl</cite>, and the rest of the string is included.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice_replace</span><span class="p">(</span><span class="n">stop</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">repl</span><span class="o">=</span><span class="s1">'X'</span><span class="p">)</span>
<span class="go">0       X</span>
<span class="go">1       X</span>
<span class="go">2      Xc</span>
<span class="go">3     Xdc</span>
<span class="go">4    Xcde</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Specify <cite>start</cite> and <cite>stop</cite>, meaning the slice from <cite>start</cite>
to <cite>stop</cite> is replaced with <cite>repl</cite>. Everything before or
after <cite>start</cite> and <cite>stop</cite> is included as is.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">slice_replace</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">repl</span><span class="o">=</span><span class="s1">'X'</span><span class="p">)</span>
<span class="go">0      aX</span>
<span class="go">1      aX</span>
<span class="go">2      aX</span>
<span class="go">3     aXc</span>
<span class="go">4    aXde</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">n</span><span class="o">=</span><span class="default_value">- 1</span></em>, <em class="sig-param"><span class="n">expand</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Split strings around given separator/delimiter.</p>
<p>Splits the string in the Series/Index from the beginning, at the
specified delimiter string. Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.split">str.split()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str, default ‘ ‘ (space)</span></dt><dd><p>String to split on, does not yet support regular expressions.</p>
</dd>
<dt><strong>n</strong><span class="classifier">int, default -1 (all)</span></dt><dd><p>Limit number of splits in output. <cite>None</cite>, 0, and -1 will all be
interpreted as “all splits”.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>Returns a DataFrame with each split as a column.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.rsplit" title="cudf.core.column.string.StringMethods.rsplit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rsplit</span></code></a></dt><dd><p>Splits string around given separator/delimiter, starting from the right.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.split" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str.split</span></code></a></dt><dd><p>Standard library version for split.</p>
</dd>
<dt><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.rsplit" title="(in Python v3.8)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str.rsplit</span></code></a></dt><dd><p>Standard library version for rsplit.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The parameter <cite>expand</cite> is not yet supported and will raise a
NotImplementedError if anything other than the default value
is set. The handling of the n keyword depends on the number
of found splits:</p>
<blockquote>
<div><ul class="simple">
<li><p>If found splits &gt; n, make first n splits only</p></li>
<li><p>If found splits &lt;= n, make all splits</p></li>
<li><p>If for a certain row the number of found
splits &lt; n, append None for padding up to n</p></li>
</ul>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"this is a regular sentence"</span><span class="p">,</span> <span class="s2">"https://docs.python.org/index.html"</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>       <span class="c1"># noqa E501</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0            this is a regular sentence</span>
<span class="go">1    https://docs.python.org/index.html</span>
<span class="go">2                                  None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>The <cite>n</cite> parameter can be used to limit the number of
splits on the delimiter.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">                                    0     1                   2</span>
<span class="go">0                                this    is  a regular sentence</span>
<span class="go">1  https://docs.python.org/index.html  None                None</span>
<span class="go">2                                None  None                None</span>
</pre></div>
</div>
<p>The <cite>pat</cite> parameter can be used to split by other characters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">pat</span> <span class="o">=</span> <span class="s2">"/"</span><span class="p">)</span>
<span class="go">                            0     1                2           3</span>
<span class="go">0  this is a regular sentence  None             None        None</span>
<span class="go">1                      https:        docs.python.org  index.html</span>
<span class="go">2                        None  None             None        None</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.startswith">
<code class="sig-name descname">startswith</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">pat</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.startswith" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the start of each string element matches a pattern.</p>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.startswith">str.startswith()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pat</strong><span class="classifier">str or list-like</span></dt><dd><p>If <cite>str</cite> is an <cite>str</cite>, evaluates whether each string of
series starts with <cite>pat</cite>.
If <cite>pat</cite> is a list-like, evaluates whether <cite>self[i]</cite>
starts with <cite>pat[i]</cite>.
Regular expressions are not accepted.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of bool</dt><dd><p>A Series of booleans indicating whether the given
pattern matches the start of each string element.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.endswith" title="cudf.core.column.string.StringMethods.endswith"><code class="xref py py-obj docutils literal notranslate"><span class="pre">endswith</span></code></a></dt><dd><p>Same as startswith, but tests the end of string.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.contains" title="cudf.core.column.string.StringMethods.contains"><code class="xref py py-obj docutils literal notranslate"><span class="pre">contains</span></code></a></dt><dd><p>Tests if string element contains a pattern.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0     bat</span>
<span class="go">1    Bear</span>
<span class="go">2     cat</span>
<span class="go">3    None</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'b'</span><span class="p">)</span>
<span class="go">0     True</span>
<span class="go">1    False</span>
<span class="go">2    False</span>
<span class="go">3     null</span>
<span class="go">dtype: bool</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.strip">
<code class="sig-name descname">strip</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">to_strip</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.strip" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove leading and trailing characters.</p>
<p>Strip whitespaces (including newlines) or a set of
specified characters from each string in the Series/Index
from left and right sides. Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.strip">str.strip()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>to_strip</strong><span class="classifier">str or None, default None</span></dt><dd><p>Specifying the set of characters to be removed.
All combinations of this set of characters
will be stripped. If None then whitespaces are removed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Returns Series or Index.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.lstrip" title="cudf.core.column.string.StringMethods.lstrip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lstrip</span></code></a></dt><dd><p>Remove leading characters in Series/Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.rstrip" title="cudf.core.column.string.StringMethods.rstrip"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rstrip</span></code></a></dt><dd><p>Remove trailing characters in Series/Index.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'1. Ant.  '</span><span class="p">,</span> <span class="s1">'2. Bee!</span><span class="se">\n</span><span class="s1">'</span><span class="p">,</span> <span class="s1">'3. Cat?</span><span class="se">\t</span><span class="s1">'</span><span class="p">,</span> <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1. Ant.</span>
<span class="go">1    2. Bee!\n</span>
<span class="go">2    3. Cat?\t</span>
<span class="go">3         None</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="go">0    1. Ant.</span>
<span class="go">1    2. Bee!</span>
<span class="go">2    3. Cat?</span>
<span class="go">3       None</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">'123.!? </span><span class="se">\n\t</span><span class="s1">'</span><span class="p">)</span>
<span class="go">0     Ant</span>
<span class="go">1     Bee</span>
<span class="go">2     Cat</span>
<span class="go">3    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.swapcase">
<code class="sig-name descname">swapcase</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.swapcase" title="Permalink to this definition">¶</a></dt>
<dd><p>Change each lowercase character to uppercase and vice versa.
This only applies to ASCII characters at this time.</p>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.swapcase">str.swapcase()</a>.</p>
<p>Returns : Series or Index of object</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.lower" title="cudf.core.column.string.StringMethods.lower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower</span></code></a></dt><dd><p>Converts all characters to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.upper" title="cudf.core.column.string.StringMethods.upper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper</span></code></a></dt><dd><p>Converts all characters to uppercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.title" title="cudf.core.column.string.StringMethods.title"><code class="xref py py-obj docutils literal notranslate"><span class="pre">title</span></code></a></dt><dd><p>Converts first character of each word to uppercase and remaining to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.capitalize" title="cudf.core.column.string.StringMethods.capitalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">capitalize</span></code></a></dt><dd><p>Converts first character to uppercase and remaining to lowercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'CAPITALS'</span><span class="p">,</span> <span class="s1">'this is a sentence'</span><span class="p">,</span> <span class="s1">'SwApCaSe'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0                 lower</span>
<span class="go">1              CAPITALS</span>
<span class="go">2    this is a sentence</span>
<span class="go">3              SwApCaSe</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">swapcase</span><span class="p">()</span>
<span class="go">0                 LOWER</span>
<span class="go">1              capitals</span>
<span class="go">2    THIS IS A SENTENCE</span>
<span class="go">3              sWaPcAsE</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.title">
<code class="sig-name descname">title</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.title" title="Permalink to this definition">¶</a></dt>
<dd><p>Uppercase the first letter of each letter after a space
and lowercase the rest.
This only applies to ASCII characters at this time.</p>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.title">str.title()</a>.</p>
<p>Returns : Series or Index of object</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.lower" title="cudf.core.column.string.StringMethods.lower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower</span></code></a></dt><dd><p>Converts all characters to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.upper" title="cudf.core.column.string.StringMethods.upper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper</span></code></a></dt><dd><p>Converts all characters to uppercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.capitalize" title="cudf.core.column.string.StringMethods.capitalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">capitalize</span></code></a></dt><dd><p>Converts first character to uppercase and remaining to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.swapcase" title="cudf.core.column.string.StringMethods.swapcase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapcase</span></code></a></dt><dd><p>Converts uppercase to lowercase and lowercase to uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'CAPITALS'</span><span class="p">,</span> <span class="s1">'this is a sentence'</span><span class="p">,</span> <span class="s1">'SwApCaSe'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0                 lower</span>
<span class="go">1              CAPITALS</span>
<span class="go">2    this is a sentence</span>
<span class="go">3              SwApCaSe</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="go">0                 Lower</span>
<span class="go">1              Capitals</span>
<span class="go">2    This Is A Sentence</span>
<span class="go">3              Swapcase</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.token_count">
<code class="sig-name descname">token_count</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.token_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Each string is split into tokens using the provided delimiter.
The returned integer sequence is the number of tokens in each string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>delimiter</strong><span class="classifier">str or list of strs, Default is whitespace.</span></dt><dd><p>The characters or strings used to locate the
split points of each string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s2">"hello world"</span><span class="p">,</span><span class="s2">"goodbye"</span><span class="p">,</span><span class="s2">""</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">token_count</span><span class="p">()</span>
<span class="go">0    2</span>
<span class="go">1    1</span>
<span class="go">2    0</span>
<span class="go">dtype: int32</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.tokenize">
<code class="sig-name descname">tokenize</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">' '</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.tokenize" title="Permalink to this definition">¶</a></dt>
<dd><p>Each string is split into tokens using the provided delimiter(s).
The sequence returned contains the tokens in the order
they were found.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>delimiter</strong><span class="classifier">str or list of strs, Default is whitespace.</span></dt><dd><p>The string used to locate the split points of each string.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index of object.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"hello world"</span><span class="p">,</span> <span class="s2">"goodbye world"</span><span class="p">,</span> <span class="s2">"hello goodbye"</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ser</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">tokenize</span><span class="p">()</span>
<span class="go">0      hello</span>
<span class="go">1      world</span>
<span class="go">2    goodbye</span>
<span class="go">3      world</span>
<span class="go">4      hello</span>
<span class="go">5    goodbye</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.translate">
<code class="sig-name descname">translate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">table</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.translate" title="Permalink to this definition">¶</a></dt>
<dd><p>Map all characters in the string through the given
mapping table.</p>
<p>Equivalent to standard <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.translate">str.translate()</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>table</strong><span class="classifier">dict</span></dt><dd><p>Table is a mapping of Unicode ordinals to Unicode
ordinals, strings, or None.
Unmapped characters are left untouched.
<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.maketrans">str.maketrans()</a>
is a helper function for making translation tables.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'CAPITALS'</span><span class="p">,</span> <span class="s1">'this is a sentence'</span><span class="p">,</span><span class="s1">'SwApCaSe'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">translate</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="s2">"1"</span><span class="p">})</span>
<span class="go">0                 lower</span>
<span class="go">1              CAPITALS</span>
<span class="go">2    this is 1 sentence</span>
<span class="go">3              SwApC1Se</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">translate</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="s2">"1"</span><span class="p">,</span> <span class="s2">"e"</span><span class="p">:</span><span class="s2">"#"</span><span class="p">})</span>
<span class="go">0                 low#r</span>
<span class="go">1              CAPITALS</span>
<span class="go">2    this is 1 s#nt#nc#</span>
<span class="go">3              SwApC1S#</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.upper">
<code class="sig-name descname">upper</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.upper" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert each string to uppercase.
This only applies to ASCII characters at this time.</p>
<p>Equivalent to <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.upper">str.upper()</a>.</p>
<p>Returns : Series or Index of object</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.lower" title="cudf.core.column.string.StringMethods.lower"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lower</span></code></a></dt><dd><p>Converts all characters to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.upper" title="cudf.core.column.string.StringMethods.upper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">upper</span></code></a></dt><dd><p>Converts all characters to uppercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.title" title="cudf.core.column.string.StringMethods.title"><code class="xref py py-obj docutils literal notranslate"><span class="pre">title</span></code></a></dt><dd><p>Converts first character of each word to uppercase and remaining to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.capitalize" title="cudf.core.column.string.StringMethods.capitalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">capitalize</span></code></a></dt><dd><p>Converts first character to uppercase and remaining to lowercase.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.swapcase" title="cudf.core.column.string.StringMethods.swapcase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapcase</span></code></a></dt><dd><p>Converts uppercase to lowercase and lowercase to uppercase.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'lower'</span><span class="p">,</span> <span class="s1">'CAPITALS'</span><span class="p">,</span> <span class="s1">'this is a sentence'</span><span class="p">,</span> <span class="s1">'SwApCaSe'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0                 lower</span>
<span class="go">1              CAPITALS</span>
<span class="go">2    this is a sentence</span>
<span class="go">3              SwApCaSe</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
<span class="go">0                 LOWER</span>
<span class="go">1              CAPITALS</span>
<span class="go">2    THIS IS A SENTENCE</span>
<span class="go">3              SWAPCASE</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.url_decode">
<code class="sig-name descname">url_decode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.url_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a URL-decoded format of each string.
No format checking is performed. All characters
are expected to be encoded as UTF-8 hex values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series or Index.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'A</span><span class="si">%2F</span><span class="s1">B-C</span><span class="si">%2F</span><span class="s1">D'</span><span class="p">,</span> <span class="s1">'e</span><span class="si">%20f</span><span class="s1">.g'</span><span class="p">,</span> <span class="s1">'4-5%2C6'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">url_decode</span><span class="p">()</span>
<span class="go">0    A/B-C/D</span>
<span class="go">1      e f.g</span>
<span class="go">2      4-5,6</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"https%3A</span><span class="si">%2F%2F</span><span class="s2">rapids.ai</span><span class="si">%2F</span><span class="s2">start.html"</span><span class="p">,</span> <span class="s2">"https%3A</span><span class="si">%2F%2F</span><span class="s2">medium.com</span><span class="si">%2F</span><span class="s2">rapids-ai"</span><span class="p">]</span>     <span class="c1"># noqa E501</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">url_decode</span><span class="p">()</span>
<span class="go">0    https://rapids.ai/start.html</span>
<span class="go">1    https://medium.com/rapids-ai</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.url_encode">
<code class="sig-name descname">url_encode</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.url_encode" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a URL-encoded format of each string.
No format checking is performed.
All characters are encoded except for ASCII letters,
digits, and these characters: <code class="docutils literal notranslate"><span class="pre">‘.’,’_’,’-‘,’~’</span></code>.
Encoding converts to hex using UTF-8 encoded bytes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Series or Index.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'A/B-C/D'</span><span class="p">,</span> <span class="s1">'e f.g'</span><span class="p">,</span> <span class="s1">'4-5,6'</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">url_encode</span><span class="p">()</span>
<span class="go">0    A%2FB-C%2FD</span>
<span class="go">1        e%20f.g</span>
<span class="go">2        4-5%2C6</span>
<span class="go">dtype: object</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"https://rapids.ai/start.html"</span><span class="p">,</span> <span class="s2">"https://medium.com/rapids-ai"</span><span class="p">]</span>         <span class="c1"># noqa E501</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">url_encode</span><span class="p">()</span>
<span class="go">0    https%3A%2F%2Frapids.ai%2Fstart.html</span>
<span class="go">1    https%3A%2F%2Fmedium.com%2Frapids-ai</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.wrap">
<code class="sig-name descname">wrap</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Wrap long strings in the Series/Index to be formatted in
paragraphs with length less than a given width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>Maximum line width.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series or Index</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The parameters <cite>expand_tabsbool</cite>, <cite>replace_whitespace</cite>,
<cite>drop_whitespace</cite>, <cite>break_long_words</cite>, <cite>break_on_hyphens</cite>,
<cite>expand_tabsbool</cite> are not yet supported and will raise a
NotImplementedError if they are set to any value.</p>
<p>This method currently achieves behavior matching R’s
stringr library <code class="docutils literal notranslate"><span class="pre">str_wrap</span></code> function, the equivalent
pandas implementation can be obtained using the
following parameter setting:</p>
<blockquote>
<div><p>expand_tabs = False</p>
<p>replace_whitespace = True</p>
<p>drop_whitespace = True</p>
<p>break_long_words = False</p>
<p>break_on_hyphens = False</p>
</div></blockquote>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'line to be wrapped'</span><span class="p">,</span> <span class="s1">'another line to be wrapped'</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">wrap</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="go">0             line to be\nwrapped</span>
<span class="go">1    another line\nto be\nwrapped</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.string.StringMethods.zfill">
<code class="sig-name descname">zfill</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">width</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.string.StringMethods.zfill" title="Permalink to this definition">¶</a></dt>
<dd><p>Pad strings in the Series/Index by prepending ‘0’ characters.</p>
<p>Strings in the Series/Index are padded with ‘0’ characters
on the left of the string to reach a total string length
width. Strings in the Series/Index with length greater
or equal to width are unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>width</strong><span class="classifier">int</span></dt><dd><p>Minimum length of resulting string;
strings with length less than width
be prepended with ‘0’ characters.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series/Index of str dtype</dt><dd><p>Returns Series or Index with prepended ‘0’ characters.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.rjust" title="cudf.core.column.string.StringMethods.rjust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rjust</span></code></a></dt><dd><p>Fills the left side of strings with an arbitrary character.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.ljust" title="cudf.core.column.string.StringMethods.ljust"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ljust</span></code></a></dt><dd><p>Fills the right side of strings with an arbitrary character.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.pad" title="cudf.core.column.string.StringMethods.pad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pad</span></code></a></dt><dd><p>Fills the specified sides of strings with an arbitrary character.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.string.StringMethods.center" title="cudf.core.column.string.StringMethods.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a></dt><dd><p>Fills boths sides of strings with an arbitrary character.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>Differs from <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.zfill">str.zfill()</a>
which has special handling for ‘+’/’-‘ in the string.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="s1">'-1'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">'1000'</span><span class="p">,</span>  <span class="kc">None</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0      -1</span>
<span class="go">1       1</span>
<span class="go">2    1000</span>
<span class="go">3    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
<p>Note that <code class="docutils literal notranslate"><span class="pre">None</span></code> is not string, therefore it is converted
to <code class="docutils literal notranslate"><span class="pre">None</span></code>. The minus sign in <code class="docutils literal notranslate"><span class="pre">'-1'</span></code> is treated as a
regular character and the zero is added to the left
of it (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str.zfill">str.zfill()</a>
would have moved it to the left). <code class="docutils literal notranslate"><span class="pre">1000</span></code> remains unchanged as
it is longer than width.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">0     0-1</span>
<span class="go">1     001</span>
<span class="go">2    1000</span>
<span class="go">3    None</span>
<span class="go">dtype: object</span>
</pre></div>
</div>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tupleize_cols</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.Index.gpu_values" title="cudf.core.index.Index.gpu_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gpu_values</span></code></a></dt><dd><p>View the data as a numba device array object</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.Index.is_unique" title="cudf.core.index.Index.is_unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_unique</span></code></a></dt><dd><p>Return if the index has unique values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.Index.name" title="cudf.core.index.Index.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>Returns the name of the Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.Index.names" title="cudf.core.index.Index.names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">names</span></code></a></dt><dd><p>Returns a tuple containing the name of the Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.Index.ndim" title="cudf.core.index.Index.ndim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndim</span></code></a></dt><dd><p>Dimension of the data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.Index.values" title="cudf.core.index.Index.values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">values</span></code></a></dt><dd><p>Return an array representing the data in the Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.any" title="cudf.core.index.Index.any"><code class="xref py py-obj docutils literal notranslate"><span class="pre">any</span></code></a>(self)</p></td>
<td><p>Return whether any elements is True in Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.argsort" title="cudf.core.index.Index.argsort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">argsort</span></code></a>(self[, ascending])</p></td>
<td><p>Return the integer indices that would sort the index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.astype" title="cudf.core.index.Index.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(self, dtype[, copy])</p></td>
<td><p>Create an Index with values cast to dtypes.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.dropna" title="cudf.core.index.Index.dropna"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dropna</span></code></a>(self)</p></td>
<td><p>Return a Series with null values removed.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.equals" title="cudf.core.index.Index.equals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equals</span></code></a>(self, other)</p></td>
<td><p>Determine if two Index objects contain the same elements.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.from_pandas" title="cudf.core.index.Index.from_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_pandas</span></code></a>(index[, nan_as_null])</p></td>
<td><p>Convert from a Pandas Index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.get_level_values" title="cudf.core.index.Index.get_level_values"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_level_values</span></code></a>(self, level)</p></td>
<td><p>Return an Index of values for requested level.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.get_slice_bound" title="cudf.core.index.Index.get_slice_bound"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice_bound</span></code></a>(self, label, side, kind)</p></td>
<td><p>Calculate slice bound that corresponds to given label.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.isin" title="cudf.core.index.Index.isin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isin</span></code></a>(self, values)</p></td>
<td><p>Return a boolean array where the index values are in values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.join" title="cudf.core.index.Index.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(self, other[, how, level, …])</p></td>
<td><p>Compute join_index and indexers to conform data structures to the new index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.max" title="cudf.core.index.Index.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">max</span></code></a>(self)</p></td>
<td><p>Return the maximum value of the Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.memory_usage" title="cudf.core.index.Index.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_usage</span></code></a>(self[, deep])</p></td>
<td><p>Memory usage of the values.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.min" title="cudf.core.index.Index.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">min</span></code></a>(self)</p></td>
<td><p>Return the minimum value of the Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.rename" title="cudf.core.index.Index.rename"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rename</span></code></a>(self, name[, inplace])</p></td>
<td><p>Alter Index name.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.sum" title="cudf.core.index.Index.sum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sum</span></code></a>(self)</p></td>
<td><p>Return the sum of all values of the Index.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.take" title="cudf.core.index.Index.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(self, indices)</p></td>
<td><p>Gather only the specific subset of indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.to_array" title="cudf.core.index.Index.to_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numpy array for the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.to_arrow" title="cudf.core.index.Index.to_arrow"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_arrow</span></code></a>(self)</p></td>
<td><p>Convert Index to a PyArrow Array.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.to_dlpack" title="cudf.core.index.Index.to_dlpack"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dlpack</span></code></a>(self)</p></td>
<td><p>Converts a cuDF object into a DLPack tensor.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.to_pandas" title="cudf.core.index.Index.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas Index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.to_series" title="cudf.core.index.Index.to_series"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_series</span></code></a>(self[, index, name])</p></td>
<td><p>Create a Series with both index and values equal to the index keys.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.Index.unique" title="cudf.core.index.Index.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(self)</p></td>
<td><p>Return unique values in the index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.Index.where" title="cudf.core.index.Index.where"><code class="xref py py-obj docutils literal notranslate"><span class="pre">where</span></code></a>(self, cond[, other])</p></td>
<td><p>Replace values where the condition is False.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.index.Index.any">
<code class="sig-name descname">any</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.any" title="Permalink to this definition">¶</a></dt>
<dd><p>Return whether any elements is True in Index.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.argsort">
<code class="sig-name descname">argsort</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">ascending</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.argsort" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the integer indices that would sort the index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>ascending</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, returns the indices for ascending order.
If False, returns the indices for descending order.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>array</strong><span class="classifier">A cupy array containing Integer indices that</span></dt><dd><p>would sort the index if used as an indexer.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.astype">
<code class="sig-name descname">astype</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">dtype</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.astype" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an Index with values cast to dtypes. The class of a new Index
is determined by dtype. When conversion is impossible, a ValueError
exception is raised.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>dtype</strong><span class="classifier">numpy dtype</span></dt><dd><p>Use a numpy.dtype to cast entire Index object to.</p>
</dd>
<dt><strong>copy</strong><span class="classifier">bool, default False</span></dt><dd><p>By default, astype always returns a newly allocated object.
If copy is set to False and internal requirements on dtype are
satisfied, the original data is used to create a new Index
or the original Index is returned.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Index</dt><dd><p>Index with values cast to specified dtype.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.dropna">
<code class="sig-name descname">dropna</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.dropna" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Series with null values removed.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two Index objects contain the same elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>out: bool</dt><dd><p>True if “other” is an Index and it has the same elements
as calling index; False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.from_pandas">
<em class="property">classmethod </em><code class="sig-name descname">from_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">index</span></em>, <em class="sig-param"><span class="n">nan_as_null</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.from_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert from a Pandas Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Pandas Index object</span></dt><dd><p>A Pandas Index object which has to be converted
to cuDF Index.</p>
</dd>
<dt><strong>nan_as_null</strong><span class="classifier">bool, Default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">None</span></code>/<code class="docutils literal notranslate"><span class="pre">True</span></code>, converts <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values
to <code class="docutils literal notranslate"><span class="pre">null</span></code> values.
If <code class="docutils literal notranslate"><span class="pre">False</span></code>, leaves <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> values as is.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><dl class="simple">
<dt>TypeError for invalid input type.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pdi</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">Index</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdi</span><span class="p">)</span>
<span class="go">Index(['10.0', '20.0', '30.0', 'null'], dtype='object')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">Index</span><span class="o">.</span><span class="n">from_pandas</span><span class="p">(</span><span class="n">pdi</span><span class="p">,</span> <span class="n">nan_as_null</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">Float64Index([10.0, 20.0, 30.0, nan], dtype='float64')</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.get_level_values">
<code class="sig-name descname">get_level_values</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">level</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.get_level_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an Index of values for requested level.</p>
<p>This is primarily useful to get an individual level of values from a
MultiIndex, but is provided on Index as well for compatibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>level</strong><span class="classifier">int or str</span></dt><dd><p>It is either the integer position or the name of the level.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Index</dt><dd><p>Calling object, as there is only one level in the Index.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.multiindex.get_level_values</span></code></dt><dd><p>Get values for a level of a MultiIndex.</p>
</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>For Index, level should be 0, since there are no multiple levels.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">StringIndex</span><span class="p">([</span><span class="s2">"a"</span><span class="p">,</span><span class="s2">"b"</span><span class="p">,</span><span class="s2">"c"</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">StringIndex(['a' 'b' 'c'], dtype='object')</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.get_slice_bound">
<code class="sig-name descname">get_slice_bound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">label</span></em>, <em class="sig-param"><span class="n">side</span></em>, <em class="sig-param"><span class="n">kind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.get_slice_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate slice bound that corresponds to given label.
Returns leftmost (one-past-the-rightmost if <code class="docutils literal notranslate"><span class="pre">side=='right'</span></code>) position
of given label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">object</span></dt><dd></dd>
<dt><strong>side</strong><span class="classifier">{‘left’, ‘right’}</span></dt><dd></dd>
<dt><strong>kind</strong><span class="classifier">{‘ix’, ‘loc’, ‘getitem’}</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Index of label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.gpu_values">
<em class="property">property </em><code class="sig-name descname">gpu_values</code><a class="headerlink" href="#cudf.core.index.Index.gpu_values" title="Permalink to this definition">¶</a></dt>
<dd><p>View the data as a numba device array object</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.is_unique">
<em class="property">property </em><code class="sig-name descname">is_unique</code><a class="headerlink" href="#cudf.core.index.Index.is_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index has unique values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.isin">
<code class="sig-name descname">isin</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">values</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.isin" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a boolean array where the index values are in values.</p>
<p>Compute boolean array of whether each index value is found in
the passed set of values. The length of the returned boolean
array matches the length of the index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>values</strong><span class="classifier">set, list-like, Index</span></dt><dd><p>Sought values.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>is_contained</strong><span class="classifier">cupy array</span></dt><dd><p>CuPy array of boolean values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.join">
<code class="sig-name descname">join</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em>, <em class="sig-param"><span class="n">how</span><span class="o">=</span><span class="default_value">'left'</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">return_indexers</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.join" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute join_index and indexers to conform data structures
to the new index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>other</strong><span class="classifier">Index.</span></dt><dd></dd>
<dt><strong>how</strong><span class="classifier">{‘left’, ‘right’, ‘inner’, ‘outer’}</span></dt><dd></dd>
<dt><strong>return_indexers</strong><span class="classifier">bool, default False</span></dt><dd></dd>
<dt><strong>sort</strong><span class="classifier">bool, default False</span></dt><dd><p>Sort the join keys lexicographically in the result Index. If False,
the order of the join keys depends on the join type (how keyword).</p>
</dd>
<dt><strong>Returns: index</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lhs</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
<span class="gp">... </span>    <span class="p">{</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">]})</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s1">'a'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">]</span>
<span class="gp">... </span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rhs</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">index</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lhs</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">'inner'</span><span class="p">)</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    3</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    4</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  1  1</span>
<span class="go">1  0  0)</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.max">
<code class="sig-name descname">max</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.max" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the maximum value of the Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>scalar</dt><dd><p>Maximum value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.Index.min" title="cudf.core.index.Index.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.min</span></code></a></dt><dd><p>Return the minimum value in an Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.max" title="cudf.core.series.Series.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.series.Series.max</span></code></a></dt><dd><p>Return the maximum value in a Series.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.dataframe.Dataframe.max</span></code></dt><dd><p>Return the maximum values in a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.memory_usage">
<code class="sig-name descname">memory_usage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory usage of the values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep</strong><span class="classifier">bool</span></dt><dd><p>Introspect the data deeply,
interrogate <cite>object</cite> dtypes for system-level
memory consumption.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bytes used</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.min">
<code class="sig-name descname">min</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.min" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the minimum value of the Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>scalar</dt><dd><p>Minimum value.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.Index.max" title="cudf.core.index.Index.max"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Index.max</span></code></a></dt><dd><p>Return the maximum value in an Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.series.Series.min" title="cudf.core.series.Series.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.series.Series.min</span></code></a></dt><dd><p>Return the minimum value in a Series.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.dataframe.DataFrame.min" title="cudf.core.dataframe.DataFrame.min"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.dataframe.DataFrame.min</span></code></a></dt><dd><p>Return the minimum values in a DataFrame.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#cudf.core.index.Index.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the Index.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.names">
<em class="property">property </em><code class="sig-name descname">names</code><a class="headerlink" href="#cudf.core.index.Index.names" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tuple containing the name of the Index.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.ndim">
<em class="property">property </em><code class="sig-name descname">ndim</code><a class="headerlink" href="#cudf.core.index.Index.ndim" title="Permalink to this definition">¶</a></dt>
<dd><p>Dimension of the data. Apart from MultiIndex ndim is always 1.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.rename">
<code class="sig-name descname">rename</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">name</span></em>, <em class="sig-param"><span class="n">inplace</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.rename" title="Permalink to this definition">¶</a></dt>
<dd><p>Alter Index name.</p>
<p>Defaults to returning new index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>name</strong><span class="classifier">label</span></dt><dd><p>Name(s) to set.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Index</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.sum">
<code class="sig-name descname">sum</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the sum of all values of the Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>scalar</dt><dd><p>Sum of all values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">6</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather only the specific subset of indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: An array-like that maps to values contained in this Index.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.to_array">
<code class="sig-name descname">to_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fillna</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.to_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numpy array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>Defaults to None, which will skip null values.
If it equals “pandas”, null values are filled with NaNs.
Non integral dtype is promoted to np.float64.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.to_arrow">
<code class="sig-name descname">to_arrow</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.to_arrow" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert Index to a PyArrow Array.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">to_arrow</span><span class="p">()</span>
<span class="go">&lt;pyarrow.lib.Int64Array object at 0x7fcaa6f53440&gt;</span>
<span class="go">[</span>
<span class="go">-3,</span>
<span class="go">10,</span>
<span class="go">15,</span>
<span class="go">20</span>
<span class="go">]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.to_dlpack">
<code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object into a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object and converts it to a PyCapsule object
which contains a pointer to a DLPack tensor. This function deep copies the
data into the DLPack tensor from the cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">DataFrame, Series, Index, or Column</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Output DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas Index.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class 'pandas.core.indexes.numeric.Int64Index'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.index.GenericIndex'&gt;</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.to_series">
<code class="sig-name descname">to_series</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.to_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Series with both index and values equal to the index keys.
Useful with map for returning an indexer based on an index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">Index, optional</span></dt><dd><p>Index of resulting Series. If None, defaults to original index.</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, optional</span></dt><dd><p>Dame of resulting Series. If None, defaults to name of original
index.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Series</dt><dd><p>The dtype will be based on the type of the Index values.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique values in the index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index without duplicates</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.values">
<em class="property">property </em><code class="sig-name descname">values</code><a class="headerlink" href="#cudf.core.index.Index.values" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array representing the data in the Index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>array</strong><span class="classifier">A cupy array of data in the Index.</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.Index.where">
<code class="sig-name descname">where</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">cond</span></em>, <em class="sig-param"><span class="n">other</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Index.where" title="Permalink to this definition">¶</a></dt>
<dd><p>Replace values where the condition is False.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cond</strong><span class="classifier">bool array-like with the same length as self</span></dt><dd><p>Where cond is True, keep the original value.
Where False, replace with corresponding value from other.
Callables are not supported.</p>
</dd>
<dt><strong>other: scalar, or array-like</strong></dt><dd><p>Entries where cond is False are replaced with
corresponding value from other. Callables are not
supported. Default is None.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Same type as caller</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="rangeindex">
<h2>RangeIndex<a class="headerlink" href="#rangeindex" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.RangeIndex">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">RangeIndex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">start</span></em>, <em class="sig-param"><span class="n">stop</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">step</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.dtype" title="cudf.core.index.RangeIndex.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p><cite>dtype</cite> of the range of values in RangeIndex.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.is_contiguous" title="cudf.core.index.RangeIndex.is_contiguous"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_contiguous</span></code></a></dt><dd><p>Returns if the index is contiguous.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.is_monotonic_decreasing" title="cudf.core.index.RangeIndex.is_monotonic_decreasing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic_decreasing</span></code></a></dt><dd><p>Return if the index is monotonic decreasing (only equal or decreasing) values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.is_monotonic_increasing" title="cudf.core.index.RangeIndex.is_monotonic_increasing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic_increasing</span></code></a></dt><dd><p>Return if the index is monotonic increasing (only equal or increasing) values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.is_unique" title="cudf.core.index.RangeIndex.is_unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_unique</span></code></a></dt><dd><p>Return if the index has unique values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.name" title="cudf.core.index.RangeIndex.name"><code class="xref py py-obj docutils literal notranslate"><span class="pre">name</span></code></a></dt><dd><p>Returns the name of the Index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.size" title="cudf.core.index.RangeIndex.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a></dt><dd><p>Return the number of elements in the underlying data.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.start" title="cudf.core.index.RangeIndex.start"><code class="xref py py-obj docutils literal notranslate"><span class="pre">start</span></code></a></dt><dd><p>The value of the <cite>start</cite> parameter (0 if this was not supplied).</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.RangeIndex.stop" title="cudf.core.index.RangeIndex.stop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">stop</span></code></a></dt><dd><p>The value of the stop parameter.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.copy" title="cudf.core.index.RangeIndex.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self[, deep])</p></td>
<td><p>Make a copy of this object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.equals" title="cudf.core.index.RangeIndex.equals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equals</span></code></a>(self, other)</p></td>
<td><p>Determine if two Index objects contain the same elements.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.find_label_range" title="cudf.core.index.RangeIndex.find_label_range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_label_range</span></code></a>(self, first, last)</p></td>
<td><p>Find range that starts with <cite>first</cite> and ends with <cite>last</cite>, inclusively.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.get_slice_bound" title="cudf.core.index.RangeIndex.get_slice_bound"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice_bound</span></code></a>(self, label, side, kind)</p></td>
<td><p>Calculate slice bound that corresponds to given label.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.memory_usage" title="cudf.core.index.RangeIndex.memory_usage"><code class="xref py py-obj docutils literal notranslate"><span class="pre">memory_usage</span></code></a>(self, **kwargs)</p></td>
<td><p>Memory usage of the values.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.to_frame" title="cudf.core.index.RangeIndex.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_frame</span></code></a>(self[, index, name])</p></td>
<td><p>Create a DataFrame with a column containing this Index</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.to_gpu_array" title="cudf.core.index.RangeIndex.to_gpu_array"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_gpu_array</span></code></a>(self[, fillna])</p></td>
<td><p>Get a dense numba device array for the data.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.to_pandas" title="cudf.core.index.RangeIndex.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas Index.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.RangeIndex.unique" title="cudf.core.index.RangeIndex.unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unique</span></code></a>(self)</p></td>
<td><p>Return unique values in the index.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of this object.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#cudf.core.index.RangeIndex.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>dtype</cite> of the range of values in RangeIndex.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.equals">
<code class="sig-name descname">equals</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">other</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.equals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if two Index objects contain the same elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>out: bool</dt><dd><p>True if “other” is an Index and it has the same elements
as calling index; False otherwise.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.find_label_range">
<code class="sig-name descname">find_label_range</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">last</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.find_label_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Find range that starts with <cite>first</cite> and ends with <cite>last</cite>,
inclusively.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>begin, end</strong><span class="classifier">2-tuple of int</span></dt><dd><p>The starting index and the ending index.
The <cite>last</cite> value occurs at <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">-</span> <span class="pre">1</span></code> position.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.get_slice_bound">
<code class="sig-name descname">get_slice_bound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">label</span></em>, <em class="sig-param"><span class="n">side</span></em>, <em class="sig-param"><span class="n">kind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.get_slice_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate slice bound that corresponds to given label.
Returns leftmost (one-past-the-rightmost if <code class="docutils literal notranslate"><span class="pre">side=='right'</span></code>) position
of given label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">object</span></dt><dd></dd>
<dt><strong>side</strong><span class="classifier">{‘left’, ‘right’}</span></dt><dd></dd>
<dt><strong>kind</strong><span class="classifier">{‘ix’, ‘loc’, ‘getitem’}</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Index of label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.is_contiguous">
<em class="property">property </em><code class="sig-name descname">is_contiguous</code><a class="headerlink" href="#cudf.core.index.RangeIndex.is_contiguous" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns if the index is contiguous. <cite>True</cite> incase of RangeIndex.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.is_monotonic_decreasing">
<em class="property">property </em><code class="sig-name descname">is_monotonic_decreasing</code><a class="headerlink" href="#cudf.core.index.RangeIndex.is_monotonic_decreasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index is monotonic decreasing
(only equal or decreasing) values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.is_monotonic_increasing">
<em class="property">property </em><code class="sig-name descname">is_monotonic_increasing</code><a class="headerlink" href="#cudf.core.index.RangeIndex.is_monotonic_increasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index is monotonic increasing
(only equal or increasing) values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.is_unique">
<em class="property">property </em><code class="sig-name descname">is_unique</code><a class="headerlink" href="#cudf.core.index.RangeIndex.is_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index has unique values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.memory_usage">
<code class="sig-name descname">memory_usage</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.memory_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>Memory usage of the values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep</strong><span class="classifier">bool</span></dt><dd><p>Introspect the data deeply,
interrogate <cite>object</cite> dtypes for system-level
memory consumption.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>bytes used</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.name">
<em class="property">property </em><code class="sig-name descname">name</code><a class="headerlink" href="#cudf.core.index.RangeIndex.name" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the name of the Index.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.size">
<em class="property">property </em><code class="sig-name descname">size</code><a class="headerlink" href="#cudf.core.index.RangeIndex.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of elements in the underlying data.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.start">
<em class="property">property </em><code class="sig-name descname">start</code><a class="headerlink" href="#cudf.core.index.RangeIndex.start" title="Permalink to this definition">¶</a></dt>
<dd><p>The value of the <cite>start</cite> parameter (0 if this was not supplied).</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.stop">
<em class="property">property </em><code class="sig-name descname">stop</code><a class="headerlink" href="#cudf.core.index.RangeIndex.stop" title="Permalink to this definition">¶</a></dt>
<dd><p>The value of the stop parameter.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.to_frame">
<code class="sig-name descname">to_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DataFrame with a column containing this Index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">boolean, default True</span></dt><dd><p>Set the index of the returned DataFrame as the original Index</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, default None</span></dt><dd><p>Name to be used for the column</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>cudf DataFrame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.to_gpu_array">
<code class="sig-name descname">to_gpu_array</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">fillna</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.to_gpu_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Get a dense numba device array for the data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fillna</strong><span class="classifier">str or None</span></dt><dd><p>Replacement value to fill in place of nulls.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>if <code class="docutils literal notranslate"><span class="pre">fillna</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, null values are skipped.  Therefore, the
output size could be smaller.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas Index.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class 'pandas.core.indexes.numeric.Int64Index'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.index.GenericIndex'&gt;</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.RangeIndex.unique">
<code class="sig-name descname">unique</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.RangeIndex.unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return unique values in the index.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index without duplicates</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="genericindex">
<h2>GenericIndex<a class="headerlink" href="#genericindex" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.GenericIndex">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">GenericIndex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.GenericIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.GenericIndex.dtype" title="cudf.core.index.GenericIndex.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></dt><dd><p><cite>dtype</cite> of the underlying values in GenericIndex.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.GenericIndex.is_monotonic" title="cudf.core.index.GenericIndex.is_monotonic"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic</span></code></a></dt><dd><p>Alias for is_monotonic_increasing.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.GenericIndex.is_monotonic_decreasing" title="cudf.core.index.GenericIndex.is_monotonic_decreasing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic_decreasing</span></code></a></dt><dd><p>Return if the index is monotonic decreasing (only equal or decreasing) values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.GenericIndex.is_monotonic_increasing" title="cudf.core.index.GenericIndex.is_monotonic_increasing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_monotonic_increasing</span></code></a></dt><dd><p>Return if the index is monotonic increasing (only equal or increasing) values.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.GenericIndex.is_unique" title="cudf.core.index.GenericIndex.is_unique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_unique</span></code></a></dt><dd><p>Return if the index has unique values.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.GenericIndex.copy" title="cudf.core.index.GenericIndex.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>(self[, deep])</p></td>
<td><p>Make a copy of this object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.GenericIndex.find_label_range" title="cudf.core.index.GenericIndex.find_label_range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">find_label_range</span></code></a>(self, first, last)</p></td>
<td><p>Find range that starts with <em>first</em> and ends with <em>last</em>, inclusively.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.GenericIndex.get_slice_bound" title="cudf.core.index.GenericIndex.get_slice_bound"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_slice_bound</span></code></a>(self, label, side, kind)</p></td>
<td><p>Calculate slice bound that corresponds to given label.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.GenericIndex.to_frame" title="cudf.core.index.GenericIndex.to_frame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_frame</span></code></a>(self[, index, name])</p></td>
<td><p>Create a DataFrame with a column containing this Index</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.copy">
<code class="sig-name descname">copy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">deep</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.GenericIndex.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Make a copy of this object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>deep</strong><span class="classifier">bool, default True</span></dt><dd><p>Make a deep copy of the data.
With <code class="docutils literal notranslate"><span class="pre">deep=False</span></code> the is not copied.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>copy</strong><span class="classifier">Index</span></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.dtype">
<em class="property">property </em><code class="sig-name descname">dtype</code><a class="headerlink" href="#cudf.core.index.GenericIndex.dtype" title="Permalink to this definition">¶</a></dt>
<dd><p><cite>dtype</cite> of the underlying values in GenericIndex.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.find_label_range">
<code class="sig-name descname">find_label_range</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">first</span></em>, <em class="sig-param"><span class="n">last</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.GenericIndex.find_label_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Find range that starts with <em>first</em> and ends with <em>last</em>,
inclusively.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>begin, end</strong><span class="classifier">2-tuple of int</span></dt><dd><p>The starting index and the ending index.
The <em>last</em> value occurs at <code class="docutils literal notranslate"><span class="pre">end</span> <span class="pre">-</span> <span class="pre">1</span></code> position.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.get_slice_bound">
<code class="sig-name descname">get_slice_bound</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">label</span></em>, <em class="sig-param"><span class="n">side</span></em>, <em class="sig-param"><span class="n">kind</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.GenericIndex.get_slice_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate slice bound that corresponds to given label.
Returns leftmost (one-past-the-rightmost if <code class="docutils literal notranslate"><span class="pre">side=='right'</span></code>) position
of given label.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>label</strong><span class="classifier">object</span></dt><dd></dd>
<dt><strong>side</strong><span class="classifier">{‘left’, ‘right’}</span></dt><dd></dd>
<dt><strong>kind</strong><span class="classifier">{‘ix’, ‘loc’, ‘getitem’}</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>int</dt><dd><p>Index of label.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.is_monotonic">
<em class="property">property </em><code class="sig-name descname">is_monotonic</code><a class="headerlink" href="#cudf.core.index.GenericIndex.is_monotonic" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for is_monotonic_increasing.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.is_monotonic_decreasing">
<em class="property">property </em><code class="sig-name descname">is_monotonic_decreasing</code><a class="headerlink" href="#cudf.core.index.GenericIndex.is_monotonic_decreasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index is monotonic decreasing
(only equal or decreasing) values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.is_monotonic_increasing">
<em class="property">property </em><code class="sig-name descname">is_monotonic_increasing</code><a class="headerlink" href="#cudf.core.index.GenericIndex.is_monotonic_increasing" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index is monotonic increasing
(only equal or increasing) values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.is_unique">
<em class="property">property </em><code class="sig-name descname">is_unique</code><a class="headerlink" href="#cudf.core.index.GenericIndex.is_unique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return if the index has unique values.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.GenericIndex.to_frame">
<code class="sig-name descname">to_frame</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.GenericIndex.to_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a DataFrame with a column containing this Index</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>index</strong><span class="classifier">boolean, default True</span></dt><dd><p>Set the index of the returned DataFrame as the original Index</p>
</dd>
<dt><strong>name</strong><span class="classifier">str, default None</span></dt><dd><p>Name to be used for the column</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd><p>cudf DataFrame</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="int8index">
<h2>Int8Index<a class="headerlink" href="#int8index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Int8Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Int8Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Int8Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="int16index">
<h2>Int16Index<a class="headerlink" href="#int16index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Int16Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Int16Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Int16Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="int32index">
<h2>Int32Index<a class="headerlink" href="#int32index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Int32Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Int32Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Int32Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="int64index">
<h2>Int64Index<a class="headerlink" href="#int64index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Int64Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Int64Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Int64Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="uint8index">
<h2>UInt8Index<a class="headerlink" href="#uint8index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.UInt8Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">UInt8Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.UInt8Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="uint16index">
<h2>UInt16Index<a class="headerlink" href="#uint16index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.UInt16Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">UInt16Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.UInt16Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="uint32index">
<h2>UInt32Index<a class="headerlink" href="#uint32index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.UInt32Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">UInt32Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.UInt32Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="uint64index">
<h2>UInt64Index<a class="headerlink" href="#uint64index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.UInt64Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">UInt64Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.UInt64Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="float32index">
<h2>Float32Index<a class="headerlink" href="#float32index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Float32Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Float32Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Float32Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="float64index">
<h2>Float64Index<a class="headerlink" href="#float64index" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.Float64Index">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">Float64Index</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.Float64Index" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
</dd></dl>
</div>
<div class="section" id="categoricalindex">
<h2>CategoricalIndex<a class="headerlink" href="#categoricalindex" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.CategoricalIndex">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">CategoricalIndex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">categories</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ordered</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.CategoricalIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.CategoricalIndex.categories" title="cudf.core.index.CategoricalIndex.categories"><code class="xref py py-obj docutils literal notranslate"><span class="pre">categories</span></code></a></dt><dd><p>The categories of this categorical.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.index.CategoricalIndex.codes" title="cudf.core.index.CategoricalIndex.codes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">codes</span></code></a></dt><dd><p>The category codes of this categorical.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt id="cudf.core.index.CategoricalIndex.categories">
<em class="property">property </em><code class="sig-name descname">categories</code><a class="headerlink" href="#cudf.core.index.CategoricalIndex.categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The categories of this categorical.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.CategoricalIndex.codes">
<em class="property">property </em><code class="sig-name descname">codes</code><a class="headerlink" href="#cudf.core.index.CategoricalIndex.codes" title="Permalink to this definition">¶</a></dt>
<dd><p>The category codes of this categorical.</p>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="stringindex">
<h2>StringIndex<a class="headerlink" href="#stringindex" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.StringIndex">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">StringIndex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">values</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.StringIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.index.StringIndex.str" title="cudf.core.index.StringIndex.str"><code class="xref py py-obj docutils literal notranslate"><span class="pre">str</span></code></a></dt><dd><p>Vectorized string functions for Series and Index.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.StringIndex.take" title="cudf.core.index.StringIndex.take"><code class="xref py py-obj docutils literal notranslate"><span class="pre">take</span></code></a>(self, indices)</p></td>
<td><p>Gather only the specific subset of indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.index.StringIndex.to_pandas" title="cudf.core.index.StringIndex.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas Index.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.index.StringIndex.str">
<em class="property">property </em><code class="sig-name descname">str</code><a class="headerlink" href="#cudf.core.index.StringIndex.str" title="Permalink to this definition">¶</a></dt>
<dd><p>Vectorized string functions for Series and Index.</p>
<p>This mimics pandas <code class="docutils literal notranslate"><span class="pre">df.str</span></code> interface. nulls stay null
unless handled otherwise by a particular method.
Patterned after Python’s string methods, with some
inspiration from R’s stringr package.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.StringIndex.take">
<code class="sig-name descname">take</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">indices</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.StringIndex.take" title="Permalink to this definition">¶</a></dt>
<dd><p>Gather only the specific subset of indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>indices: An array-like that maps to values contained in this Index.</strong></dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.index.StringIndex.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.StringIndex.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas Index.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class 'pandas.core.indexes.numeric.Int64Index'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.index.GenericIndex'&gt;</span>
</pre></div>
</div>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="datetimeindex">
<h2>DatetimeIndex<a class="headerlink" href="#datetimeindex" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.index.DatetimeIndex">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.index.</code><code class="sig-name descname">DatetimeIndex</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">data</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">freq</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">tz</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">normalize</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">closed</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">ambiguous</span><span class="o">=</span><span class="default_value">'raise'</span></em>, <em class="sig-param"><span class="n">dayfirst</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">yearfirst</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">name</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.DatetimeIndex" title="Permalink to this definition">¶</a></dt>
<dd><p>Immutable, ordered and sliceable sequence of integer labels.
The basic object storing row labels for all cuDF objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>Index</dt><dd><p>cudf Index</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"uint64"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">"a"</span><span class="p">)</span>
<span class="go">UInt64Index([1, 2, 3], dtype='uint64', name='a')</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">Index</span><span class="p">(</span><span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s2">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s2">"b"</span><span class="p">:[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]}))</span>
<span class="go">MultiIndex(levels=[0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: int64, 0    2</span>
<span class="go">1    3</span>
<span class="go">dtype: int64],</span>
<span class="go">codes=   a  b</span>
<span class="go">0  0  0</span>
<span class="go">1  1  1)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>day</strong></dt><dd></dd>
<dt><strong>hour</strong></dt><dd></dd>
<dt><strong>minute</strong></dt><dd></dd>
<dt><strong>month</strong></dt><dd></dd>
<dt><strong>second</strong></dt><dd></dd>
<dt><strong>weekday</strong></dt><dd></dd>
<dt><strong>year</strong></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.index.DatetimeIndex.to_pandas" title="cudf.core.index.DatetimeIndex.to_pandas"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_pandas</span></code></a>(self)</p></td>
<td><p>Convert to a Pandas Index.</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 62%"/>
<col style="width: 38%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>get_dt_field</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.index.DatetimeIndex.to_pandas">
<code class="sig-name descname">to_pandas</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.index.DatetimeIndex.to_pandas" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert to a Pandas Index.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">as_index</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="go">Int64Index([-3, 10, 15, 20], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">())</span>
<span class="go">&lt;class 'pandas.core.indexes.numeric.Int64Index'&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="go">&lt;class 'cudf.core.index.GenericIndex'&gt;</span>
</pre></div>
</div>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="categories">
<h2>Categories<a class="headerlink" href="#categories" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.column.categorical.CategoricalAccessor">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.column.categorical.</code><code class="sig-name descname">CategoricalAccessor</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">column</span></em>, <em class="sig-param"><span class="n">parent</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Accessor object for categorical properties of the Series values.
Be aware that assigning to <cite>categories</cite> is a inplace operation,
while all methods return new categorical data per default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>data</strong><span class="classifier">Series or CategoricalIndex</span></dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'category'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span>
<span class="go">Int64Index([1, 2, 3], dtype='int64')</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">reorder_categories</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [3, 2, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">remove_categories</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0   null</span>
<span class="go">1      2</span>
<span class="go">2      3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [2, 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="s1">'abcde'</span><span class="p">))</span>
<span class="go">0   null</span>
<span class="go">1   null</span>
<span class="go">2   null</span>
<span class="go">dtype: category</span>
<span class="go">Categories (5, object): [a, b, c, d, e]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_ordered</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1 &lt; 2 &lt; 3]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_unordered</span><span class="p">()</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">2    3</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 3]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.categories" title="cudf.core.column.categorical.CategoricalAccessor.categories"><code class="xref py py-obj docutils literal notranslate"><span class="pre">categories</span></code></a></dt><dd><p>The categories of this categorical.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.codes" title="cudf.core.column.categorical.CategoricalAccessor.codes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">codes</span></code></a></dt><dd><p>Return Series of codes as well as the index.</p>
</dd>
<dt><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.ordered" title="cudf.core.column.categorical.CategoricalAccessor.ordered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ordered</span></code></a></dt><dd><p>Whether the categories have an ordered relationship.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.add_categories" title="cudf.core.column.categorical.CategoricalAccessor.add_categories"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_categories</span></code></a>(self, new_categories, **kwargs)</p></td>
<td><p>Add new categories.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.as_ordered" title="cudf.core.column.categorical.CategoricalAccessor.as_ordered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_ordered</span></code></a>(self, **kwargs)</p></td>
<td><p>Set the Categorical to be ordered.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.as_unordered" title="cudf.core.column.categorical.CategoricalAccessor.as_unordered"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_unordered</span></code></a>(self, **kwargs)</p></td>
<td><p>Set the Categorical to be unordered.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.remove_categories" title="cudf.core.column.categorical.CategoricalAccessor.remove_categories"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_categories</span></code></a>(self, removals, **kwargs)</p></td>
<td><p>Remove the specified categories.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.reorder_categories" title="cudf.core.column.categorical.CategoricalAccessor.reorder_categories"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder_categories</span></code></a>(self, new_categories, …)</p></td>
<td><p>Reorder categories as specified in new_categories.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.column.categorical.CategoricalAccessor.set_categories" title="cudf.core.column.categorical.CategoricalAccessor.set_categories"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_categories</span></code></a>(self, new_categories, **kwargs)</p></td>
<td><p>Set the categories to the specified new_categories.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.add_categories">
<code class="sig-name descname">add_categories</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">new_categories</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.add_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Add new categories.</p>
<p><cite>new_categories</cite> will be included at the last/highest
place in the categories and will be unused directly
after this call.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_categories</strong><span class="classifier">category or list-like of category</span></dt><dd><p>The new categories to be included.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not to add the categories inplace
or return a copy of this categorical with
added categories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cat</dt><dd><p>Categorical with new categories added or
None if inplace.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"category"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">add_categories</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (5, int64): [1, 2, 0, 3, 4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">add_categories</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    1</span>
<span class="go">1    2</span>
<span class="go">dtype: category</span>
<span class="go">Categories (5, int64): [1, 2, 0, 3, 4]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.as_ordered">
<code class="sig-name descname">as_ordered</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.as_ordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Categorical to be ordered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not to add the categories inplace
or return a copy of this categorical with
added categories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Categorical</dt><dd><p>Ordered Categorical or None if inplace.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"category"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_ordered</span><span class="p">()</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1 &lt; 2 &lt; 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_ordered</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1 &lt; 2 &lt; 10]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.as_unordered">
<code class="sig-name descname">as_unordered</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.as_unordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the Categorical to be unordered.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not to set the ordered attribute
in-place or return a copy of this
categorical with ordered set to False.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Categorical</dt><dd><p>Unordered Categorical or None if inplace.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"category"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_ordered</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1 &lt; 2 &lt; 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_unordered</span><span class="p">()</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">as_unordered</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.categories">
<em class="property">property </em><code class="sig-name descname">categories</code><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.categories" title="Permalink to this definition">¶</a></dt>
<dd><p>The categories of this categorical.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.codes">
<em class="property">property </em><code class="sig-name descname">codes</code><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.codes" title="Permalink to this definition">¶</a></dt>
<dd><p>Return Series of codes as well as the index.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.ordered">
<em class="property">property </em><code class="sig-name descname">ordered</code><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.ordered" title="Permalink to this definition">¶</a></dt>
<dd><p>Whether the categories have an ordered relationship.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.remove_categories">
<code class="sig-name descname">remove_categories</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">removals</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.remove_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the specified categories.</p>
<p><cite>removals</cite> must be included in the
old categories. Values which were in the
removed categories will be set to null.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>removals</strong><span class="classifier">category or list-like of category</span></dt><dd><p>The categories which should be removed.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not to remove the categories
inplace or return a copy of this categorical
with removed categories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cat</dt><dd><p>Categorical with removed categories or None
if inplace.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"category"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">remove_categories</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
<span class="go">0     10</span>
<span class="go">1   null</span>
<span class="go">2   null</span>
<span class="go">3      2</span>
<span class="go">4     10</span>
<span class="go">5      2</span>
<span class="go">6     10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">remove_categories</span><span class="p">([</span><span class="mi">10</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0   null</span>
<span class="go">1      1</span>
<span class="go">2      1</span>
<span class="go">3      2</span>
<span class="go">4   null</span>
<span class="go">5      2</span>
<span class="go">6   null</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 2]</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.reorder_categories">
<code class="sig-name descname">reorder_categories</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">new_categories</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.reorder_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Reorder categories as specified in new_categories.</p>
<p><cite>new_categories</cite> need to include all old categories
and no new category items.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_categories</strong><span class="classifier">Index-like</span></dt><dd><p>The categories in new order.</p>
</dd>
<dt><strong>ordered</strong><span class="classifier">bool, optional</span></dt><dd><p>Whether or not the categorical is treated
as a ordered categorical. If not given, do
not change the ordered information.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not to reorder the categories
inplace or return a copy of this categorical
with reordered categories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cat</dt><dd><p>Categorical with reordered categories or
None if inplace.</p>
</dd>
</dl>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><dl class="simple">
<dt>ValueError</dt><dd><p>If the new categories do not contain all old
category items or any new ones.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">"category"</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">reorder_categories</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">0    10</span>
<span class="go">1     1</span>
<span class="go">2     1</span>
<span class="go">3     2</span>
<span class="go">4    10</span>
<span class="go">5     2</span>
<span class="go">6    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [10, 1, 2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">reorder_categories</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">ValueError: items in new_categories are not the same as in</span>
<span class="go">old categories</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.column.categorical.CategoricalAccessor.set_categories">
<code class="sig-name descname">set_categories</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">new_categories</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.column.categorical.CategoricalAccessor.set_categories" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the categories to the specified new_categories.</p>
<p><cite>new_categories</cite> can include new categories (which
will result in unused categories) or remove old categories
(which results in values set to null). If <cite>rename==True</cite>,
the categories will simple be renamed (less or more items
than in old categories will result in values set to null or
in unused categories respectively).</p>
<p>This method can be used to perform more than one action
of adding, removing, and reordering simultaneously and
is therefore faster than performing the individual steps
via the more specialised methods.</p>
<p>On the other hand this methods does not do checks
(e.g., whether the old categories are included in the
new categories on a reorder), which can result in
surprising changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>new_categories</strong><span class="classifier">list-like</span></dt><dd><p>The categories in new order.</p>
</dd>
<dt><strong>ordered</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not the categorical is treated as
a ordered categorical. If not given, do
not change the ordered information.</p>
</dd>
<dt><strong>rename</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not the <cite>new_categories</cite> should be
considered as a rename of the old categories
or as reordered categories.</p>
</dd>
<dt><strong>inplace</strong><span class="classifier">bool, default False</span></dt><dd><p>Whether or not to reorder the categories in-place
or return a copy of this categorical with
reordered categories.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>cat</dt><dd><p>Categorical with reordered categories
or None if inplace.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">Series</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">'category'</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0     1</span>
<span class="go">1     1</span>
<span class="go">2     2</span>
<span class="go">3    10</span>
<span class="go">4     2</span>
<span class="go">5    10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (3, int64): [1, 2, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span>
<span class="go">0      1</span>
<span class="go">1      1</span>
<span class="go">2   null</span>
<span class="go">3     10</span>
<span class="go">4   null</span>
<span class="go">5     10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">set_categories</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span>
<span class="go">0      1</span>
<span class="go">1      1</span>
<span class="go">2   null</span>
<span class="go">3     10</span>
<span class="go">4   null</span>
<span class="go">5     10</span>
<span class="go">dtype: category</span>
<span class="go">Categories (2, int64): [1, 10]</span>
</pre></div>
</div>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="groupby">
<h2>GroupBy<a class="headerlink" href="#groupby" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.core.groupby.groupby.GroupBy">
<em class="property">class </em><code class="sig-prename descclassname">cudf.core.groupby.groupby.</code><code class="sig-name descname">GroupBy</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">obj</span></em>, <em class="sig-param"><span class="n">by</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">level</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sort</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">as_index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">dropna</span><span class="o">=</span><span class="default_value">True</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy" title="Permalink to this definition">¶</a></dt>
<dd><p>Group a DataFrame or Series by a set of columns.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>by</strong><span class="classifier">optional</span></dt><dd><p>Specifies the grouping columns. Can be any of the following:
- A Python function called on each value of the object’s index
- A dict or Series that maps index labels to group names
- A cudf.Index object
- A str indicating a column name
- An array of the same length as the object
- A Grouper object
- A list of the above</p>
</dd>
<dt><strong>level</strong><span class="classifier">int, level_name or list, optional</span></dt><dd><p>For objects with a MultiIndex, <cite>level</cite> can be used to specify
grouping by one or more levels of the MultiIndex.</p>
</dd>
<dt><strong>sort</strong><span class="classifier">True, optional</span></dt><dd><p>If True (default), sort results by group9s). Note that
unlike Pandas, this also sorts values within each group.</p>
</dd>
<dt><strong>as_index</strong><span class="classifier">bool, optional</span></dt><dd><p>If as_index=True (default), the group names appear
as the keys of the resulting DataFrame.
If as_index=False, the groups are returned as ordinary
columns of the resulting DataFrame, <em>if they are named columns</em>.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, optional</span></dt><dd><p>If True (default), do not include the “null” group.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.agg" title="cudf.core.groupby.groupby.GroupBy.agg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">agg</span></code></a>(self, func)</p></td>
<td><p>Apply aggregation(s) to the groups.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.aggregate" title="cudf.core.groupby.groupby.GroupBy.aggregate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">aggregate</span></code></a>(self, func)</p></td>
<td><p>Apply aggregation(s) to the groups.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.apply" title="cudf.core.groupby.groupby.GroupBy.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code></a>(self, function)</p></td>
<td><p>Apply a python transformation function over the grouped chunk.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.apply_grouped" title="cudf.core.groupby.groupby.GroupBy.apply_grouped"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_grouped</span></code></a>(self, function, **kwargs)</p></td>
<td><p>Apply a transformation function over the grouped chunk.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.nth" title="cudf.core.groupby.groupby.GroupBy.nth"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nth</span></code></a>(self, n)</p></td>
<td><p>Return the nth row from each group.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.nunique" title="cudf.core.groupby.groupby.GroupBy.nunique"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nunique</span></code></a>(self)</p></td>
<td><p>Return the number of unique values per group.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.rolling" title="cudf.core.groupby.groupby.GroupBy.rolling"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rolling</span></code></a>(self, *args, **kwargs)</p></td>
<td><p>Returns a <cite>RollingGroupby</cite> object that enables rolling window calculations on the groups.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#cudf.core.groupby.groupby.GroupBy.size" title="cudf.core.groupby.groupby.GroupBy.size"><code class="xref py py-obj docutils literal notranslate"><span class="pre">size</span></code></a>(self)</p></td>
<td><p>Return the size of each group.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.agg">
<code class="sig-name descname">agg</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.agg" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply aggregation(s) to the groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">str, callable, list or dict</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A Series or DataFrame containing the combined results of the</dt><dd></dd>
<dt>aggregation.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">'sum'</span><span class="p">)</span>
<span class="go">   b</span>
<span class="go">a</span>
<span class="go">1  3</span>
<span class="go">2  3</span>
</pre></div>
</div>
<p>Specifying a list of aggregations to perform on each column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">'sum'</span><span class="p">,</span> <span class="s1">'min'</span><span class="p">])</span>
<span class="go">    b       c</span>
<span class="go">  sum min sum min</span>
<span class="go">a</span>
<span class="go">1   3   1   4   2</span>
<span class="go">2   3   3   1   1</span>
</pre></div>
</div>
<p>Using a dict to specify aggregations to perform per column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="s1">'max'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'min'</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">]})</span>
<span class="go">    a   b</span>
<span class="go">  max min mean</span>
<span class="go">a</span>
<span class="go">1   1   1  1.5</span>
<span class="go">2   2   3  3.0</span>
</pre></div>
</div>
<p>Using lambdas/callables to specify aggregations taking parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span> <span class="n">f1</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">"q0.5"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.75</span><span class="p">);</span> <span class="n">f2</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">"q0.75"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="go">     b          c</span>
<span class="go">  q0.5 q0.75 q0.5 q0.75</span>
<span class="go">a</span>
<span class="go">1  1.5  1.75  2.0   2.0</span>
<span class="go">2  3.0  3.00  1.0   1.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.aggregate">
<code class="sig-name descname">aggregate</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">func</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.aggregate" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply aggregation(s) to the groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">str, callable, list or dict</span></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A Series or DataFrame containing the combined results of the</dt><dd></dd>
<dt>aggregation.</dt><dd></dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="s1">'sum'</span><span class="p">)</span>
<span class="go">   b</span>
<span class="go">a</span>
<span class="go">1  3</span>
<span class="go">2  3</span>
</pre></div>
</div>
<p>Specifying a list of aggregations to perform on each column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="s1">'sum'</span><span class="p">,</span> <span class="s1">'min'</span><span class="p">])</span>
<span class="go">    b       c</span>
<span class="go">  sum min sum min</span>
<span class="go">a</span>
<span class="go">1   3   1   4   2</span>
<span class="go">2   3   3   1   1</span>
</pre></div>
</div>
<p>Using a dict to specify aggregations to perform per column.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="s1">'a'</span><span class="p">:</span> <span class="s1">'max'</span><span class="p">,</span> <span class="s1">'b'</span><span class="p">:</span> <span class="p">[</span><span class="s1">'min'</span><span class="p">,</span> <span class="s1">'mean'</span><span class="p">]})</span>
<span class="go">    a   b</span>
<span class="go">  max min mean</span>
<span class="go">a</span>
<span class="go">1   1   1  1.5</span>
<span class="go">2   2   3  3.0</span>
</pre></div>
</div>
<p>Using lambdas/callables to specify aggregations taking parameters.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.5</span><span class="p">);</span> <span class="n">f1</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">"q0.5"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f2</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="mf">0.75</span><span class="p">);</span> <span class="n">f2</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">=</span> <span class="s2">"q0.75"</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'a'</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">([</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">])</span>
<span class="go">     b          c</span>
<span class="go">  q0.5 q0.75 q0.5 q0.75</span>
<span class="go">a</span>
<span class="go">1  1.5  1.75  2.0   2.0</span>
<span class="go">2  3.0  3.00  1.0   1.0</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">function</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a python transformation function over the grouped chunk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The python transformation function that will be applied
on the grouped chunk.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">'key'</span><span class="p">])</span>

<span class="c1"># Define a function to apply to each row in a group</span>
<span class="k">def</span> <span class="nf">mult</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
  <span class="n">df</span><span class="p">[</span><span class="s1">'out'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">*</span> <span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">df</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">mult</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span>  <span class="n">out</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>
</pre></div>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.apply_grouped">
<code class="sig-name descname">apply_grouped</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">function</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.apply_grouped" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a transformation function over the grouped chunk.</p>
<p>This uses numba’s CUDA JIT compiler to convert the Python
transformation function into a CUDA kernel, thus will have a
compilation overhead during the first run.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func</strong><span class="classifier">function</span></dt><dd><p>The transformation function that will be executed on the CUDA GPU.</p>
</dd>
<dt><strong>incols: list</strong></dt><dd><p>A list of names of input columns.</p>
</dd>
<dt><strong>outcols: list</strong></dt><dd><p>A dictionary of output column names and their dtype.</p>
</dd>
<dt><strong>kwargs</strong><span class="classifier">dict</span></dt><dd><p>name-value of extra arguments. These values are passed directly into
the function.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">cudf</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">DataFrame</span><span class="p">()</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'key'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">df</span><span class="p">[</span><span class="s1">'val'</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s1">'key'</span><span class="p">])</span>

<span class="c1"># Define a function to apply to each group</span>
<span class="k">def</span> <span class="nf">mult_add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">out1</span><span class="p">,</span> <span class="n">out2</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
        <span class="n">out1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply_grouped</span><span class="p">(</span><span class="n">mult_add</span><span class="p">,</span>
                              <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">'key'</span><span class="p">,</span> <span class="s1">'val'</span><span class="p">],</span>
                              <span class="n">outcols</span><span class="o">=</span><span class="p">{</span><span class="s1">'out1'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span>
                                       <span class="s1">'out2'</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">},</span>
                              <span class="c1"># threads per block</span>
                              <span class="n">tpb</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>   <span class="n">key</span>  <span class="n">val</span> <span class="n">out1</span> <span class="n">out2</span>
<span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>    <span class="mi">0</span>
<span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>    <span class="mi">0</span>    <span class="mi">1</span>
<span class="mi">2</span>    <span class="mi">1</span>    <span class="mi">2</span>    <span class="mi">2</span>    <span class="mi">3</span>
<span class="mi">3</span>    <span class="mi">1</span>    <span class="mi">3</span>    <span class="mi">3</span>    <span class="mi">4</span>
<span class="mi">4</span>    <span class="mi">2</span>    <span class="mi">4</span>    <span class="mi">8</span>    <span class="mi">6</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>   <span class="mi">10</span>    <span class="mi">7</span>
<span class="mi">6</span>    <span class="mi">2</span>    <span class="mi">6</span>   <span class="mi">12</span>    <span class="mi">8</span>
</pre></div>
</div>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cuda</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="c1"># Create a random 15 row dataframe with one categorical</span>
<span class="c1"># feature and one random integer valued feature</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span>
        <span class="p">{</span>
            <span class="s2">"cat"</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
            <span class="s2">"val"</span><span class="p">:</span> <span class="p">[</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)],</span>
        <span class="p">}</span>
     <span class="p">)</span>

<span class="c1"># Group the dataframe by its categorical feature</span>
<span class="n">groups</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">"cat"</span><span class="p">)</span>

<span class="c1"># Define a kernel which takes the moving average of a</span>
<span class="c1"># sliding window</span>
<span class="k">def</span> <span class="nf">rolling_avg</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">avg</span><span class="p">):</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cuda</span><span class="o">.</span><span class="n">threadIdx</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">cuda</span><span class="o">.</span><span class="n">blockDim</span><span class="o">.</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">win_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># If there is not enough data to fill the window,</span>
            <span class="c1"># take the average to be NaN</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">win_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">val</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">avg</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="n">win_size</span>

<span class="c1"># Compute moving averages on all groups</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">apply_grouped</span><span class="p">(</span><span class="n">rolling_avg</span><span class="p">,</span>
                               <span class="n">incols</span><span class="o">=</span><span class="p">[</span><span class="s1">'val'</span><span class="p">],</span>
                               <span class="n">outcols</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">avg</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Results:"</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>

<span class="c1"># Note this gives the same result as its pandas equivalent</span>
<span class="n">pdf</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">to_pandas</span><span class="p">()</span>
<span class="n">pd_results</span> <span class="o">=</span> <span class="n">pdf</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)[</span><span class="s1">'val'</span><span class="p">]</span><span class="o">.</span><span class="n">rolling</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
</pre></div>
</div>
<p>Output:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">Results</span><span class="p">:</span>
     <span class="n">cat</span>  <span class="n">val</span>                 <span class="n">avg</span>
<span class="mi">0</span>    <span class="mi">1</span>   <span class="mi">16</span>
<span class="mi">1</span>    <span class="mi">1</span>   <span class="mi">45</span>
<span class="mi">2</span>    <span class="mi">1</span>   <span class="mi">62</span>                <span class="mf">41.0</span>
<span class="mi">3</span>    <span class="mi">1</span>   <span class="mi">45</span>  <span class="mf">50.666666666666664</span>
<span class="mi">4</span>    <span class="mi">1</span>   <span class="mi">26</span>  <span class="mf">44.333333333333336</span>
<span class="mi">5</span>    <span class="mi">2</span>    <span class="mi">5</span>
<span class="mi">6</span>    <span class="mi">2</span>   <span class="mi">51</span>
<span class="mi">7</span>    <span class="mi">2</span>   <span class="mi">77</span>  <span class="mf">44.333333333333336</span>
<span class="mi">8</span>    <span class="mi">2</span>    <span class="mi">1</span>                <span class="mf">43.0</span>
<span class="mi">9</span>    <span class="mi">2</span>   <span class="mi">46</span>  <span class="mf">41.333333333333336</span>
<span class="p">[</span><span class="mi">5</span> <span class="n">more</span> <span class="n">rows</span><span class="p">]</span>
</pre></div>
</div>
<p>This is functionally equivalent to <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html">pandas.DataFrame.Rolling</a></p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.nth">
<code class="sig-name descname">nth</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="n">n</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.nth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the nth row from each group.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.nunique">
<code class="sig-name descname">nunique</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.nunique" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of unique values per group.</p>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.rolling">
<code class="sig-name descname">rolling</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.rolling" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a <cite>RollingGroupby</cite> object that enables rolling window
calculations on the groups.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.core.window.Rolling</span></code></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py method">
<dt id="cudf.core.groupby.groupby.GroupBy.size">
<code class="sig-name descname">size</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.core.groupby.groupby.GroupBy.size" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the size of each group.</p>
</dd></dl>
</dd></dl>
</div>
<div class="section" id="module-cudf.io.csv">
<span id="io"></span><h2>IO<a class="headerlink" href="#module-cudf.io.csv" title="Permalink to this headline">¶</a></h2>
<dl class="py function">
<dt id="cudf.io.csv.read_csv">
<code class="sig-prename descclassname">cudf.io.csv.</code><code class="sig-name descname">read_csv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath_or_buffer</span></em>, <em class="sig-param"><span class="n">lineterminator</span><span class="o">=</span><span class="default_value">'\n'</span></em>, <em class="sig-param"><span class="n">quotechar</span><span class="o">=</span><span class="default_value">'"'</span></em>, <em class="sig-param"><span class="n">quoting</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">doublequote</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">'infer'</span></em>, <em class="sig-param"><span class="n">mangle_dupe_cols</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">usecols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">','</span></em>, <em class="sig-param"><span class="n">delimiter</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">delim_whitespace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">skipinitialspace</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">names</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skipfooter</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">skiprows</span><span class="o">=</span><span class="default_value">0</span></em>, <em class="sig-param"><span class="n">dayfirst</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">'infer'</span></em>, <em class="sig-param"><span class="n">thousands</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">decimal</span><span class="o">=</span><span class="default_value">'.'</span></em>, <em class="sig-param"><span class="n">true_values</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">false_values</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">nrows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">byte_range</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skip_blank_lines</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">parse_dates</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">comment</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">na_values</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">keep_default_na</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">na_filter</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">prefix</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">index_col</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.read_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a comma-seperated-values (CSV) dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
or any object with a <cite>read()</cite> method (such as builtin <cite>open()</cite> file handler
function or <cite>StringIO</cite>).</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>delimiter</strong><span class="classifier">char, default None</span></dt><dd><p>Alternative argument name for sep.</p>
</dd>
<dt><strong>delim_whitespace</strong><span class="classifier">bool, default False</span></dt><dd><p>Determines whether to use whitespace as delimiter.</p>
</dd>
<dt><strong>lineterminator</strong><span class="classifier">char, default ‘n’</span></dt><dd><p>Character to indicate end of line.</p>
</dd>
<dt><strong>skipinitialspace</strong><span class="classifier">bool, default False</span></dt><dd><p>Skip spaces after delimiter.</p>
</dd>
<dt><strong>names</strong><span class="classifier">list of str, default None</span></dt><dd><p>List of column names to be used.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">type, list of types, or dict of column -&gt; type, default None</span></dt><dd><p>Data type(s) for data or columns. If list, types are applied in the same
order as the column names. If dict, types are mapped to the column names.
E.g. {‘a’: np.float64, ‘b’: int32, ‘c’: ‘float’}
If <cite>None</cite>, dtypes are inferred from the dataset. Use <cite>str</cite> to preserve data
and not infer or interpret to dtype.</p>
</dd>
<dt><strong>quotechar</strong><span class="classifier">char, default ‘”’</span></dt><dd><p>Character to indicate start and end of quote item.</p>
</dd>
<dt><strong>quoting</strong><span class="classifier">str or int, default 0</span></dt><dd><p>Controls quoting behavior. Set to one of
0 (csv.QUOTE_MINIMAL), 1 (csv.QUOTE_ALL),
2 (csv.QUOTE_NONNUMERIC) or 3 (csv.QUOTE_NONE).
Quoting is enabled with all values except 3.</p>
</dd>
<dt><strong>doublequote</strong><span class="classifier">bool, default True</span></dt><dd><p>When quoting is enabled, indicates whether to interpret two
consecutive quotechar inside fields as single quotechar</p>
</dd>
<dt><strong>header</strong><span class="classifier">int, default ‘infer’</span></dt><dd><p>Row number to use as the column names. Default behavior is to infer
the column names: if no names are passed, header=0;
if column names are passed explicitly, header=None.</p>
</dd>
<dt><strong>usecols</strong><span class="classifier">list of int or str, default None</span></dt><dd><p>Returns subset of the columns given in the list. All elements must be
either integer indices (column number) or strings that correspond to
column names</p>
</dd>
<dt><strong>mangle_dupe_cols</strong><span class="classifier">boolean, default True</span></dt><dd><p>Duplicate columns will be specified as ‘X’,’X.1’,…’X.N’.</p>
</dd>
<dt><strong>skiprows</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of rows to be skipped from the start of file.</p>
</dd>
<dt><strong>skipfooter</strong><span class="classifier">int, default 0</span></dt><dd><p>Number of rows to be skipped at the bottom of file.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘zip’, None}, default ‘infer’</span></dt><dd><p>For on-the-fly decompression of on-disk data. If ‘infer’, then detect
compression from the following extensions: ‘.gz’,‘.zip’ (otherwise no
decompression). If using ‘zip’, the ZIP file must contain only one
data file to be read in, otherwise the first non-zero-sized file will
be used. Set to None for no decompression.</p>
</dd>
<dt><strong>decimal</strong><span class="classifier">char, default ‘.’</span></dt><dd><p>Character used as a decimal point.</p>
</dd>
<dt><strong>thousands</strong><span class="classifier">char, default None</span></dt><dd><p>Character used as a thousands delimiter.</p>
</dd>
<dt><strong>true_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as boolean True</p>
</dd>
<dt><strong>false_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as boolean False</p>
</dd>
<dt><strong>nrows</strong><span class="classifier">int, default None</span></dt><dd><p>If specified, maximum number of rows to read</p>
</dd>
<dt><strong>byte_range</strong><span class="classifier">list or tuple, default None</span></dt><dd><p>Byte range within the input file to be read. The first number is the
offset in bytes, the second number is the range size in bytes. Set the
size to zero to read all data after the offset location. Reads the row
that starts before or at the end of the range, even if it ends after
the end of the range.</p>
</dd>
<dt><strong>skip_blank_lines</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, discard and do not parse empty lines
If False, interpret empty lines as NaN values</p>
</dd>
<dt><strong>parse_dates</strong><span class="classifier">list of int or names, default None</span></dt><dd><p>If list of columns, then attempt to parse each entry as a date.
Columns may not always be recognized as dates, for instance due to
unusual or non-standard formats. To guarantee a date and increase parsing
speed, explicitly specify <cite>dtype=’date’</cite> for the desired columns.</p>
</dd>
<dt><strong>comment</strong><span class="classifier">char, default None</span></dt><dd><p>Character used as a comments indicator. If found at the beginning of a
line, the line will be ignored altogether.</p>
</dd>
<dt><strong>na_values</strong><span class="classifier">list, default None</span></dt><dd><p>Values to consider as invalid</p>
</dd>
<dt><strong>keep_default_na</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether or not to include the default NA values when parsing the data.</p>
</dd>
<dt><strong>na_filter</strong><span class="classifier">bool, default True</span></dt><dd><p>Detect missing values (empty strings and the values in na_values).
Passing False can improve performance.</p>
</dd>
<dt><strong>prefix</strong><span class="classifier">str, default None</span></dt><dd><p>Prefix to add to column numbers when parsing without a header row</p>
</dd>
<dt><strong>index_col</strong><span class="classifier">int, string or False, default None</span></dt><dd><p>Column to use as the row labels of the DataFrame. Passing <cite>index_col=False</cite>
explicitly disables index column inference and discards the last column.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>GPU <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object.</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.to_csv" title="cudf.io.csv.to_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.to_csv</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Create a test csv file</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">'foo.csv'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
<span class="gp">... </span>  <span class="s2">"num1,datetime,text"</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">"123,2018-11-13T12:00:00,abc"</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">"456,2018-11-14T12:35:01,def"</span><span class="p">,</span>
<span class="gp">... </span>  <span class="s2">"789,2018-11-15T18:02:59,ghi"</span>
<span class="gp">... </span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">'w'</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span><span class="o">+</span><span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">)</span>
</pre></div>
</div>
<p>Read the file with <code class="docutils literal notranslate"><span class="pre">cudf.read_csv</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cudf</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.csv.to_csv">
<code class="sig-prename descclassname">cudf.io.csv.</code><code class="sig-name descname">to_csv</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">sep</span><span class="o">=</span><span class="default_value">','</span></em>, <em class="sig-param"><span class="n">na_rep</span><span class="o">=</span><span class="default_value">''</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">header</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">line_terminator</span><span class="o">=</span><span class="default_value">'\n'</span></em>, <em class="sig-param"><span class="n">chunksize</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.csv.to_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a dataframe to csv file format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">DataFrame</span></dt><dd><p>DataFrame object to be written to csv</p>
</dd>
<dt><strong>path</strong><span class="classifier">str, default None</span></dt><dd><p>Path of file where DataFrame will be written</p>
</dd>
<dt><strong>sep</strong><span class="classifier">char, default ‘,’</span></dt><dd><p>Delimiter to be used.</p>
</dd>
<dt><strong>na_rep</strong><span class="classifier">str, default ‘’</span></dt><dd><p>String to use for null entries</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list of str, optional</span></dt><dd><p>Columns to write</p>
</dd>
<dt><strong>header</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the column names</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Write out the index as a column</p>
</dd>
<dt><strong>line_terminator</strong><span class="classifier">char, default ‘n’</span></dt><dd></dd>
<dt><strong>chunksize</strong><span class="classifier">int or None, default None</span></dt><dd><p>Rows to write at a time</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.read_csv</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Follows the standard of Pandas csv.QUOTE_NONNUMERIC for all output.</p></li>
<li><p>If <cite>to_csv</cite> leads to memory errors consider setting the <cite>chunksize</cite> argument.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Write a dataframe to csv.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">filename</span> <span class="o">=</span> <span class="s1">'foo.csv'</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'x'</span><span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
<span class="go">                         'y': [1.0, 3.3, 2.2, 4.4],</span>
<span class="go">                         'z': ['a', 'b', 'c', 'd']})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>
<span class="target" id="module-cudf.io.parquet"></span><dl class="py function">
<dt id="cudf.io.parquet.merge_parquet_filemetadata">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">merge_parquet_filemetadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filemetadata_list</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.merge_parquet_filemetadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge multiple parquet metadata blobs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>metadata_list</strong><span class="classifier">list</span></dt><dd><p>List of buffers returned by to_parquet</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Combined parquet metadata blob</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.parquet.read_parquet">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">read_parquet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath_or_buffer</span></em>, <em class="sig-param"><span class="n">engine</span><span class="o">=</span><span class="default_value">'cudf'</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">row_group</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">row_group_count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skip_rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">strings_to_categorical</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">use_pandas_metadata</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a Parquet dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, bytes, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
Python bytes of raw binary data, or any object with a <cite>read()</cite> method
(such as builtin <cite>open()</cite> file handler function or <cite>BytesIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘pyarrow’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read.</p>
</dd>
<dt><strong>row_group</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, only the row group with the specified index will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the number of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
<dt><strong>strings_to_categorical</strong><span class="classifier">boolean, default False</span></dt><dd><p>If True, return string columns as GDF_CATEGORY dtype; if False, return a
as GDF_STRING dtype.</p>
</dd>
<dt><strong>use_pandas_metadata</strong><span class="classifier">boolean, default True</span></dt><dd><p>If True and dataset has custom PANDAS schema metadata, ensure that index
columns are also loaded.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet_metadata" title="cudf.io.parquet.read_parquet_metadata"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet_metadata</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.parquet.read_parquet_metadata">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">read_parquet_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.read_parquet_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a Parquet file’s metadata and schema</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string or path object</span></dt><dd><p>Path of file to be read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Total number of rows</dt><dd></dd>
<dt>Number of row groups</dt><dd></dd>
<dt>List of column names</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_rows</span><span class="p">,</span> <span class="n">num_row_groups</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_parquet_metadata</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">cudf</span><span class="o">.</span><span class="n">read_parquet</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">row_group</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">row_groups</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.parquet.to_parquet">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">to_parquet</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="n">engine</span><span class="o">=</span><span class="default_value">'cudf'</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">'snappy'</span></em>, <em class="sig-param"><span class="n">index</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">partition_cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">statistics</span><span class="o">=</span><span class="default_value">'ROWGROUP'</span></em>, <em class="sig-param"><span class="n">metadata_file_path</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.to_parquet" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the parquet format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path or Root Directory path. Will be used as Root Directory path
while writing a partitioned dataset.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘snappy’, ‘gzip’, ‘brotli’, None}, default ‘snappy’</span></dt><dd><p>Name of the compression to use. Use <code class="docutils literal notranslate"><span class="pre">None</span></code> for no compression.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default None</span></dt><dd><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, include the dataframe’s index(es) in the file output. If
<code class="docutils literal notranslate"><span class="pre">False</span></code>, they will not be written to the file. If <code class="docutils literal notranslate"><span class="pre">None</span></code>, the
engine’s default behavior will be used.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list, optional, default None</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.parquet.write_to_dataset">
<code class="sig-prename descclassname">cudf.io.parquet.</code><code class="sig-name descname">write_to_dataset</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">root_path</span></em>, <em class="sig-param"><span class="n">partition_cols</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">fs</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">preserve_index</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">return_metadata</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.parquet.write_to_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Wraps <cite>to_parquet</cite> to write partitioned Parquet datasets.
For each combination of partition group and value,
subdirectories are created as follows:</p>
<dl>
<dt>root_dir/</dt><dd><dl class="simple">
<dt>group=value1</dt><dd><p>&lt;uuid&gt;.parquet</p>
</dd>
</dl>
<p>…
group=valueN</p>
<blockquote>
<div><p>&lt;uuid&gt;.parquet</p>
</div></blockquote>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>df</strong><span class="classifier">cudf.DataFrame</span></dt><dd></dd>
<dt><strong>root_path</strong><span class="classifier">string,</span></dt><dd><p>The root directory of the dataset</p>
</dd>
<dt><strong>fs</strong><span class="classifier">FileSystem, default None</span></dt><dd><p>If nothing passed, paths assumed to be found in the local on-disk
filesystem</p>
</dd>
<dt><strong>preserve_index</strong><span class="classifier">bool, default False</span></dt><dd><p>Preserve index values in each parquet file.</p>
</dd>
<dt><strong>partition_cols</strong><span class="classifier">list,</span></dt><dd><p>Column names by which to partition the dataset
Columns are partitioned in the order they are given</p>
</dd>
<dt><strong>return_metadata</strong><span class="classifier">bool, default False</span></dt><dd><p>Return parquet metadata for written data. Returned metadata will
include the file-path metadata (relative to <cite>root_path</cite>).</p>
</dd>
<dt><strong>**kwargs</strong><span class="classifier">dict,</span></dt><dd><p>kwargs for to_parquet function.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>
<span class="target" id="module-cudf.io.orc"></span><dl class="py function">
<dt id="cudf.io.orc.read_orc">
<code class="sig-prename descclassname">cudf.io.orc.</code><code class="sig-name descname">read_orc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath_or_buffer</span></em>, <em class="sig-param"><span class="n">engine</span><span class="o">=</span><span class="default_value">'cudf'</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stripe</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">stripe_count</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skip_rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">use_index</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">decimals_as_float</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">force_decimal_scale</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">timestamp_type</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.read_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an ORC dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, bytes, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
Python bytes of raw binary data, or any object with a <cite>read()</cite> method
(such as builtin <cite>open()</cite> file handler function or <cite>BytesIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘pyarrow’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read from the file.</p>
</dd>
<dt><strong>stripe: int, default None</strong></dt><dd><p>If not None, only the stripe with the specified index will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the number of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
<dt><strong>use_index</strong><span class="classifier">bool, default True</span></dt><dd><p>If True, use row index if available for faster seeking.</p>
</dd>
<dt><strong>kwargs are passed to the engine</strong></dt><dd></dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.parquet.read_parquet" title="cudf.io.parquet.read_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.read_parquet</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.orc.read_orc_metadata">
<code class="sig-prename descclassname">cudf.io.orc.</code><code class="sig-name descname">read_orc_metadata</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.read_orc_metadata" title="Permalink to this definition">¶</a></dt>
<dd><p>Read an ORC file’s metadata and schema</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string or path object</span></dt><dd><p>Path of file to be read</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>Total number of rows</dt><dd></dd>
<dt>Number of stripes</dt><dd></dd>
<dt>List of column names</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">num_rows</span><span class="p">,</span> <span class="n">stripes</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">read_orc_metadata</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="p">[</span><span class="n">cudf</span><span class="o">.</span><span class="n">read_orc</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">stripe</span><span class="o">=</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stripes</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.orc.to_orc">
<code class="sig-prename descclassname">cudf.io.orc.</code><code class="sig-name descname">to_orc</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">enable_statistics</span><span class="o">=</span><span class="default_value">False</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.orc.to_orc" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the ORC format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>fname</strong><span class="classifier">str</span></dt><dd><p>File path or object where the ORC dataset will be stored.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{{ ‘snappy’, None }}, default None</span></dt><dd><p>Name of the compression to use. Use None for no compression.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.orc.read_orc" title="cudf.io.orc.read_orc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.orc.read_orc</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<span class="target" id="module-cudf.io.json"></span><dl class="py function">
<dt id="cudf.io.json.read_json">
<code class="sig-prename descclassname">cudf.io.json.</code><code class="sig-name descname">read_json</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path_or_buf</span></em>, <em class="sig-param"><span class="n">engine</span><span class="o">=</span><span class="default_value">'auto'</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">lines</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">compression</span><span class="o">=</span><span class="default_value">'infer'</span></em>, <em class="sig-param"><span class="n">byte_range</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.read_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a JSON dataset into a DataFrame</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>path_or_buf</strong><span class="classifier">str, path object, or file-like object</span></dt><dd><p>Either JSON data in a <cite>str</cite>, path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
or any object with a <cite>read()</cite> method (such as builtin <cite>open()</cite> file handler
function or <cite>StringIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{{ ‘auto’, ‘cudf’, ‘pandas’ }}, default ‘auto’</span></dt><dd><p>Parser engine to use. If ‘auto’ is passed, the engine will be
automatically selected based on the other parameters.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string,</span></dt><dd><p>Indication of expected JSON string format (pandas engine only).
Compatible JSON strings can be produced by <code class="docutils literal notranslate"><span class="pre">to_json()</span></code> with a
corresponding orient value.
The set of possible orients is:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'split'</span></code> : dict like
<code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">[index],</span> <span class="pre">columns</span> <span class="pre">-&gt;</span> <span class="pre">[columns],</span> <span class="pre">data</span> <span class="pre">-&gt;</span> <span class="pre">[values]}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'records'</span></code> : list like
<code class="docutils literal notranslate"><span class="pre">[{column</span> <span class="pre">-&gt;</span> <span class="pre">value},</span> <span class="pre">...</span> <span class="pre">,</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}]</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'index'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'columns'</span></code> : dict like <code class="docutils literal notranslate"><span class="pre">{column</span> <span class="pre">-&gt;</span> <span class="pre">{index</span> <span class="pre">-&gt;</span> <span class="pre">value}}</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'values'</span></code> : just the values array</p></li>
</ul>
<p>The allowed and default values depend on the value
of the <cite>typ</cite> parameter.</p>
<ul class="simple">
<li><p>when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'series'</span></code>,</p>
<ul>
<li><p>allowed orients are <code class="docutils literal notranslate"><span class="pre">{'split','records','index'}</span></code></p></li>
<li><p>default is <code class="docutils literal notranslate"><span class="pre">'index'</span></code></p></li>
<li><p>The Series index must be unique for orient <code class="docutils literal notranslate"><span class="pre">'index'</span></code>.</p></li>
</ul>
</li>
<li><p>when <code class="docutils literal notranslate"><span class="pre">typ</span> <span class="pre">==</span> <span class="pre">'frame'</span></code>,</p>
<ul>
<li><p>allowed orients are <code class="docutils literal notranslate"><span class="pre">{'split','records','index',</span>
<span class="pre">'columns','values',</span> <span class="pre">'table'}</span></code></p></li>
<li><p>default is <code class="docutils literal notranslate"><span class="pre">'columns'</span></code></p></li>
<li><p>The DataFrame index must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code> and
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>.</p></li>
<li><p>The DataFrame columns must be unique for orients <code class="docutils literal notranslate"><span class="pre">'index'</span></code>,
<code class="docutils literal notranslate"><span class="pre">'columns'</span></code>, and <code class="docutils literal notranslate"><span class="pre">'records'</span></code>.</p></li>
</ul>
</li>
</ul>
</dd>
<dt><strong>typ</strong><span class="classifier">type of object to recover (series or frame), default ‘frame’</span></dt><dd><p>With cudf engine, only frame output is supported.</p>
</dd>
<dt><strong>dtype</strong><span class="classifier">boolean or dict, default True</span></dt><dd><p>If True, infer dtypes, if a dict of column to dtype, then use those,
if False, then don’t infer dtypes at all, applies only to the data.</p>
</dd>
<dt><strong>convert_axes</strong><span class="classifier">boolean, default True</span></dt><dd><p>Try to convert the axes to the proper dtypes (pandas engine only).</p>
</dd>
<dt><strong>convert_dates</strong><span class="classifier">boolean, default True</span></dt><dd><p>List of columns to parse for dates (pandas engine only); If True, then try
to parse datelike columns default is True; a column label is datelike if</p>
<ul class="simple">
<li><p>it ends with <code class="docutils literal notranslate"><span class="pre">'_at'</span></code>,</p></li>
<li><p>it ends with <code class="docutils literal notranslate"><span class="pre">'_time'</span></code>,</p></li>
<li><p>it begins with <code class="docutils literal notranslate"><span class="pre">'timestamp'</span></code>,</p></li>
<li><p>it is <code class="docutils literal notranslate"><span class="pre">'modified'</span></code>, or</p></li>
<li><p>it is <code class="docutils literal notranslate"><span class="pre">'date'</span></code></p></li>
</ul>
</dd>
<dt><strong>keep_default_dates</strong><span class="classifier">boolean, default True</span></dt><dd><p>If parsing dates, parse the default datelike columns (pandas engine only)</p>
</dd>
<dt><strong>numpy</strong><span class="classifier">boolean, default False</span></dt><dd><p>Direct decoding to numpy arrays (pandas engine only). Supports numeric
data only, but non-numeric column and index labels are supported. Note
also that the JSON ordering MUST be the same for each term if numpy=True.</p>
</dd>
<dt><strong>precise_float</strong><span class="classifier">boolean, default False</span></dt><dd><p>Set to enable usage of higher precision (strtod) function when
decoding string to double values (pandas engine only). Default (False)
is to use fast but less precise builtin functionality</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default None</span></dt><dd><p>The timestamp unit to detect if converting dates (pandas engine only).
The default behavior is to try and detect the correct precision, but if
this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force
parsing only seconds, milliseconds, microseconds or nanoseconds.</p>
</dd>
<dt><strong>encoding</strong><span class="classifier">str, default is ‘utf-8’</span></dt><dd><p>The encoding to use to decode py3 bytes.
With cudf engine, only utf-8 is supported.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">boolean, default False</span></dt><dd><p>Read the file as a json object per line.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">integer, default None</span></dt><dd><p>Return JsonReader object for iteration (pandas engine only).
See the <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/io.html#io-jsonl">line-delimited json docs</a>
for more information on <code class="docutils literal notranslate"><span class="pre">chunksize</span></code>.
This can only be passed if <cite>lines=True</cite>.
If this is None, the file will be read into memory all at once.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}, default ‘infer’</span></dt><dd><p>For on-the-fly decompression of on-disk data. If ‘infer’, then use
gzip, bz2, zip or xz if path_or_buf is a string ending in
‘.gz’, ‘.bz2’, ‘.zip’, or ‘xz’, respectively, and no decompression
otherwise. If using ‘zip’, the ZIP file must contain only one data
file to be read in. Set to None for no decompression.</p>
</dd>
<dt><strong>byte_range</strong><span class="classifier">list or tuple, default None</span></dt><dd><p>Byte range within the input file to be read (cudf engine only).
The first number is the offset in bytes, the second number is the range
size in bytes. Set the size to zero to read all data after the offset
location. Reads the row that starts before or at the end of the range,
even if it ends after the end of the range.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl>
<dt><strong>result</strong><span class="classifier">Series or DataFrame, depending on the value of <cite>typ</cite>.</span></dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.to_json" title="cudf.io.json.to_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.to_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.json.to_json">
<code class="sig-prename descclassname">cudf.io.json.</code><code class="sig-name descname">to_json</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cudf_val</span></em>, <em class="sig-param"><span class="n">path_or_buf</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.json.to_json" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert the cuDF object to a JSON string.
Note nulls and NaNs will be converted to null and datetime objects
will be converted to UNIX timestamps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string or file handle, optional</span></dt><dd><p>File path or object. If not specified, the result is returned as a string.</p>
</dd>
<dt><strong>orient</strong><span class="classifier">string</span></dt><dd><p>Indication of expected JSON string format.</p>
<ul class="simple">
<li><dl class="simple">
<dt>Series</dt><dd><ul>
<li><p>default is ‘index’</p></li>
<li><p>allowed values are: {‘split’,’records’,’index’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>DataFrame</dt><dd><ul>
<li><p>default is ‘columns’</p></li>
<li><p>allowed values are:
{‘split’,’records’,’index’,’columns’,’values’,’table’}</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>The format of the JSON string</dt><dd><ul>
<li><p>‘split’ : dict like {‘index’ -&gt; [index],
‘columns’ -&gt; [columns], ‘data’ -&gt; [values]}</p></li>
<li><p>‘records’ : list like
[{column -&gt; value}, … , {column -&gt; value}]</p></li>
<li><p>‘index’ : dict like {index -&gt; {column -&gt; value}}</p></li>
<li><p>‘columns’ : dict like {column -&gt; {index -&gt; value}}</p></li>
<li><p>‘values’ : just the values array</p></li>
<li><p>‘table’ : dict like {‘schema’: {schema}, ‘data’: {data}}
describing the data, and the data component is
like <code class="docutils literal notranslate"><span class="pre">orient='records'</span></code>.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
<dt><strong>date_format</strong><span class="classifier">{None, ‘epoch’, ‘iso’}</span></dt><dd><p>Type of date conversion. ‘epoch’ = epoch milliseconds,
‘iso’ = ISO8601. The default depends on the <cite>orient</cite>. For
<code class="docutils literal notranslate"><span class="pre">orient='table'</span></code>, the default is ‘iso’. For all other orients,
the default is ‘epoch’.</p>
</dd>
<dt><strong>double_precision</strong><span class="classifier">int, default 10</span></dt><dd><p>The number of decimal places to use when encoding
floating point values.</p>
</dd>
<dt><strong>force_ascii</strong><span class="classifier">bool, default True</span></dt><dd><p>Force encoded string to be ASCII.</p>
</dd>
<dt><strong>date_unit</strong><span class="classifier">string, default ‘ms’ (milliseconds)</span></dt><dd><p>The time unit to encode to, governs timestamp and ISO8601
precision.  One of ‘s’, ‘ms’, ‘us’, ‘ns’ for second, millisecond,
microsecond, and nanosecond respectively.</p>
</dd>
<dt><strong>default_handler</strong><span class="classifier">callable, default None</span></dt><dd><p>Handler to call if object cannot otherwise be converted to a
suitable format for JSON. Should receive a single argument which is
the object to convert and return a serializable object.</p>
</dd>
<dt><strong>lines</strong><span class="classifier">bool, default False</span></dt><dd><p>If ‘orient’ is ‘records’ write out line delimited json format. Will
throw ValueError if incorrect ‘orient’ since others are not list
like.</p>
</dd>
<dt><strong>compression</strong><span class="classifier">{‘infer’, ‘gzip’, ‘bz2’, ‘zip’, ‘xz’, None}</span></dt><dd><p>A string representing the compression to use in the output file,
only used when the first argument is a filename. By default, the
compression is inferred from the filename.</p>
</dd>
<dt><strong>index</strong><span class="classifier">bool, default True</span></dt><dd><p>Whether to include the index values in the JSON string. Not
including the index (<code class="docutils literal notranslate"><span class="pre">index=False</span></code>) is only supported when
orient is ‘split’ or ‘table’.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<span class="target" id="module-cudf.io.avro"></span><dl class="py function">
<dt id="cudf.io.avro.read_avro">
<code class="sig-prename descclassname">cudf.io.avro.</code><code class="sig-name descname">read_avro</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">filepath_or_buffer</span></em>, <em class="sig-param"><span class="n">engine</span><span class="o">=</span><span class="default_value">'cudf'</span></em>, <em class="sig-param"><span class="n">columns</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">skip_rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">num_rows</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.avro.read_avro" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an Avro dataset into a DataFrame</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>filepath_or_buffer</strong><span class="classifier">str, path object, bytes, or file-like object</span></dt><dd><p>Either a path to a file (a <cite>str</cite>, <cite>pathlib.Path</cite>, or
<cite>py._path.local.LocalPath</cite>), URL (including http, ftp, and S3 locations),
Python bytes of raw binary data, or any object with a <cite>read()</cite> method
(such as builtin <cite>open()</cite> file handler function or <cite>BytesIO</cite>).</p>
</dd>
<dt><strong>engine</strong><span class="classifier">{ ‘cudf’, ‘fastavro’ }, default ‘cudf’</span></dt><dd><p>Parser engine to use.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default None</span></dt><dd><p>If not None, only these columns will be read.</p>
</dd>
<dt><strong>skip_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the number of rows to skip from the start of the file.</p>
</dd>
<dt><strong>num_rows</strong><span class="classifier">int, default None</span></dt><dd><p>If not None, the total number of rows to read.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.csv.read_csv" title="cudf.io.csv.read_csv"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.csv.read_csv</span></code></a></dt><dd></dd>
<dt><a class="reference internal" href="#cudf.io.json.read_json" title="cudf.io.json.read_json"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.json.read_json</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>cuDF supports local and remote data stores. See configuration details for
available sources
<a class="reference external" href="https://docs.dask.org/en/latest/remote-data-services.html">here</a>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_avro</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<span class="target" id="module-cudf.io.dlpack"></span><dl class="py function">
<dt id="cudf.io.dlpack.from_dlpack">
<code class="sig-prename descclassname">cudf.io.dlpack.</code><code class="sig-name descname">from_dlpack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">pycapsule_obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.dlpack.from_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts from a DLPack tensor to a cuDF object.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a PyCapsule object which contains a pointer to
a DLPack tensor as input, and returns a cuDF object. This function deep
copies the data in the DLPack tensor into a cuDF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>pycapsule_obj</strong><span class="classifier">PyCapsule</span></dt><dd><p>Input DLPack tensor pointer which is encapsulated in a PyCapsule
object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A cuDF DataFrame or Series depending on if the input DLPack tensor is 1D</dt><dd></dd>
<dt>or 2D.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.dlpack.to_dlpack">
<code class="sig-prename descclassname">cudf.io.dlpack.</code><code class="sig-name descname">to_dlpack</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">cudf_obj</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.dlpack.to_dlpack" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a cuDF object to a DLPack tensor.</p>
<p>DLPack is an open-source memory tensor structure:
<a class="reference external" href="https://github.com/dmlc/dlpack">dmlc/dlpack</a>.</p>
<p>This function takes a cuDF object as input, and returns a PyCapsule object
which contains a pointer to DLPack tensor. This function deep
copies the data in the cuDF object into the DLPack tensor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>cudf_obj</strong><span class="classifier">cuDF Object</span></dt><dd><p>Input cuDF object.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>A  DLPack tensor pointer which is encapsulated in a PyCapsule object.</dt><dd></dd>
</dl>
</dd>
</dl>
</dd></dl>
<span class="target" id="module-cudf.io.feather"></span><dl class="py function">
<dt id="cudf.io.feather.read_feather">
<code class="sig-prename descclassname">cudf.io.feather.</code><code class="sig-name descname">read_feather</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.read_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Load an feather object from the file path, returning a DataFrame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">string</span></dt><dd><p>File path</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, default=None</span></dt><dd><p>If not None, only these columns will be read from the file.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>DataFrame</dt><dd></dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd></dd>
</dl>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">cudf</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">cudf</span><span class="o">.</span><span class="n">read_feather</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span>
<span class="go">  num1                datetime text</span>
<span class="go">0  123 2018-11-13T12:00:00.000 5451</span>
<span class="go">1  456 2018-11-14T12:35:01.000 5784</span>
<span class="go">2  789 2018-11-15T18:02:59.000 6117</span>
</pre></div>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.feather.to_feather">
<code class="sig-prename descclassname">cudf.io.feather.</code><code class="sig-name descname">to_feather</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">df</span></em>, <em class="sig-param"><span class="n">path</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.feather.to_feather" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a DataFrame to the feather format.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path</strong><span class="classifier">str</span></dt><dd><p>File path</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.feather.read_feather" title="cudf.io.feather.read_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.read_feather</span></code></a></dt><dd></dd>
</dl>
</div>
</dd></dl>
<span class="target" id="module-cudf.io.hdf"></span><dl class="py function">
<dt id="cudf.io.hdf.read_hdf">
<code class="sig-prename descclassname">cudf.io.hdf.</code><code class="sig-name descname">read_hdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path_or_buf</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.read_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Read from the store, close it if we opened it.</p>
<p>Retrieve pandas object stored in file, optionally based on where
criteria</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">string, buffer or path object</span></dt><dd><p>Path to the file to open, or an open <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">HDFStore</a>.
object.
Supports any object implementing the <code class="docutils literal notranslate"><span class="pre">__fspath__</span></code> protocol.
This includes <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.8)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a> and py._path.local.LocalPath
objects.</p>
</dd>
<dt><strong>key</strong><span class="classifier">object, optional</span></dt><dd><p>The group identifier in the store. Can be omitted if the HDF file
contains a single pandas object.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘r’, ‘r+’, ‘a’}, optional</span></dt><dd><p>Mode to use when opening the file. Ignored if path_or_buf is a
<a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">Pandas HDFS</a>.
Default is ‘r’.</p>
</dd>
<dt><strong>where</strong><span class="classifier">list, optional</span></dt><dd><p>A list of Term (or convertible) objects.</p>
</dd>
<dt><strong>start</strong><span class="classifier">int, optional</span></dt><dd><p>Row number to start selection.</p>
</dd>
<dt><strong>stop</strong><span class="classifier">int, optional</span></dt><dd><p>Row number to stop selection.</p>
</dd>
<dt><strong>columns</strong><span class="classifier">list, optional</span></dt><dd><p>A list of columns names to return.</p>
</dd>
<dt><strong>iterator</strong><span class="classifier">bool, optional</span></dt><dd><p>Return an iterator object.</p>
</dd>
<dt><strong>chunksize</strong><span class="classifier">int, optional</span></dt><dd><p>Number of rows to include in an iteration when using an iterator.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
<dt><strong>**kwargs</strong></dt><dd><p>Additional keyword arguments passed to HDFStore.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>item</strong><span class="classifier">object</span></dt><dd><p>The selected object. Return type depends on the object stored.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.to_hdf" title="cudf.io.hdf.to_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.to_hdf</span></code></a></dt><dd><p>Write a HDF file from a DataFrame.</p>
</dd>
</dl>
</div>
</dd></dl>
<dl class="py function">
<dt id="cudf.io.hdf.to_hdf">
<code class="sig-prename descclassname">cudf.io.hdf.</code><code class="sig-name descname">to_hdf</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">path_or_buf</span></em>, <em class="sig-param"><span class="n">key</span></em>, <em class="sig-param"><span class="n">value</span></em>, <em class="sig-param"><span class="o">*</span><span class="n">args</span></em>, <em class="sig-param"><span class="o">**</span><span class="n">kwargs</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.io.hdf.to_hdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the contained data to an HDF5 file using HDFStore.</p>
<p>Hierarchical Data Format (HDF) is self-describing, allowing an
application to interpret the structure and contents of a file with
no outside information. One HDF file can hold a mix of related objects
which can be accessed as a group or as individual objects.</p>
<p>In order to add another DataFrame or Series to an existing HDF file
please use append mode and a different a key.</p>
<p>For more information see the <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#hdf5-pytables">user guide</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>path_or_buf</strong><span class="classifier">str or pandas.HDFStore</span></dt><dd><p>File path or HDFStore object.</p>
</dd>
<dt><strong>key</strong><span class="classifier">str</span></dt><dd><p>Identifier for the group in the store.</p>
</dd>
<dt><strong>mode</strong><span class="classifier">{‘a’, ‘w’, ‘r+’}, default ‘a’</span></dt><dd><p>Mode to open file:</p>
<ul class="simple">
<li><p>‘w’: write, a new file is created (an existing file with the same name
would be deleted).</p></li>
<li><p>‘a’: append, an existing file is opened for reading and writing, and if
the file does not exist it is created.</p></li>
<li><p>‘r+’: similar to ‘a’, but the file must already exist.</p></li>
</ul>
</dd>
<dt><strong>format</strong><span class="classifier">{‘fixed’, ‘table’}, default ‘fixed’</span></dt><dd><p>Possible values:</p>
<ul class="simple">
<li><p>‘fixed’: Fixed format. Fast writing/reading. Not-appendable,
nor searchable.</p></li>
<li><p>‘table’: Table format. Write as a PyTables Table structure
which may perform worse but allow more flexible operations
like searching / selecting subsets of the data.</p></li>
</ul>
</dd>
<dt><strong>append</strong><span class="classifier">bool, default False</span></dt><dd><p>For Table formats, append the input data to the existing.</p>
</dd>
<dt><strong>data_columns</strong><span class="classifier">list of columns or True, optional</span></dt><dd><p>List of columns to create as indexed data columns for on-disk
queries, or True to use all columns. By default only the axes
of the object are indexed. See <a class="reference external" href="https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#io-hdf5-query-data-columns">Query via Data Columns</a>.
Applicable only to format=’table’.</p>
</dd>
<dt><strong>complevel</strong><span class="classifier">{0-9}, optional</span></dt><dd><p>Specifies a compression level for data.
A value of 0 disables compression.</p>
</dd>
<dt><strong>complib</strong><span class="classifier">{‘zlib’, ‘lzo’, ‘bzip2’, ‘blosc’}, default ‘zlib’</span></dt><dd><p>Specifies the compression library to be used.
As of v0.20.2 these additional compressors for Blosc are supported
(default if no compressor specified: ‘blosc:blosclz’):
{‘blosc:blosclz’, ‘blosc:lz4’, ‘blosc:lz4hc’, ‘blosc:snappy’,
‘blosc:zlib’, ‘blosc:zstd’}.
Specifying a compression library which is not available issues
a ValueError.</p>
</dd>
<dt><strong>fletcher32</strong><span class="classifier">bool, default False</span></dt><dd><p>If applying compression use the fletcher32 checksum.</p>
</dd>
<dt><strong>dropna</strong><span class="classifier">bool, default False</span></dt><dd><p>If true, ALL nan rows will not be written to store.</p>
</dd>
<dt><strong>errors</strong><span class="classifier">str, default ‘strict’</span></dt><dd><p>Specifies how encoding and decoding errors are to be handled.
See the errors argument for <a class="reference external" href="https://docs.python.org/3/library/functions.html#open" title="(in Python v3.8)"><code class="xref py py-func docutils literal notranslate"><span class="pre">open()</span></code></a> for a full list
of options.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#cudf.io.hdf.read_hdf" title="cudf.io.hdf.read_hdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.hdf.read_hdf</span></code></a></dt><dd><p>Read from HDF file.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.parquet.to_parquet" title="cudf.io.parquet.to_parquet"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.parquet.to_parquet</span></code></a></dt><dd><p>Write a DataFrame to the binary parquet format.</p>
</dd>
<dt><a class="reference internal" href="#cudf.io.feather.to_feather" title="cudf.io.feather.to_feather"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cudf.io.feather.to_feather</span></code></a></dt><dd><p>Write out feather-format for DataFrames.</p>
</dd>
</dl>
</div>
</dd></dl>
</div>
<div class="section" id="gpuarrowreader">
<h2>GpuArrowReader<a class="headerlink" href="#gpuarrowreader" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt id="cudf.comm.gpuarrow.GpuArrowReader">
<em class="property">class </em><code class="sig-prename descclassname">cudf.comm.gpuarrow.</code><code class="sig-name descname">GpuArrowReader</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">schema</span></em>, <em class="sig-param"><span class="n">dev_ary</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%"/>
<col style="width: 90%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="cudf.comm.gpuarrow.GpuArrowReader.to_dict"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_dict</span></code></a>(self)</p></td>
<td><p>Return a dictionary of Series object</p></td>
</tr>
</tbody>
</table>
<table class="docutils align-default">
<colgroup>
<col style="width: 50%"/>
<col style="width: 50%"/>
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>schema</strong></p></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="cudf.comm.gpuarrow.GpuArrowReader.to_dict">
<code class="sig-name descname">to_dict</code><span class="sig-paren">(</span><em class="sig-param"><span class="n">self</span></em><span class="sig-paren">)</span><a class="headerlink" href="#cudf.comm.gpuarrow.GpuArrowReader.to_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a dictionary of Series object</p>
</dd></dl>
</dd></dl>
</div>
</div>
</div>
</div>
<footer>
<div aria-label="footer navigation" class="rst-footer-buttons" role="navigation">
<a accesskey="n" class="btn btn-neutral float-right" href="10min.html" rel="next" title="10 Minutes to cuDF and Dask-cuDF">Next <span class="fa fa-arrow-circle-right"></span></a>
<a accesskey="p" class="btn btn-neutral float-left" href="index.html" rel="prev" title="Welcome to cuDF’s documentation!"><span class="fa fa-arrow-circle-left"></span> Previous</a>
</div>
<hr/>
<div role="contentinfo">
<p>
        
        © Copyright 2018, NVIDIA

    </p>
</div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
</div>
</div>
</section>
</div>
<script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>