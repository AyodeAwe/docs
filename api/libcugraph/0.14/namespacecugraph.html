<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/xhtml;charset=utf-8" http-equiv="Content-Type"/>
<meta content="IE=9" http-equiv="X-UA-Compatible"/>
<meta content="Doxygen 1.8.18" name="generator"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>libcugraph: cugraph Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script src="jquery.js" type="text/javascript"></script>
<script src="dynsections.js" type="text/javascript"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script src="search/searchdata.js" type="text/javascript"></script>
<script src="search/search.js" type="text/javascript"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" id="rapids-fa-tag" rel="stylesheet"/><link href="/assets/css/custom.css" id="rapids-selector-css" rel="stylesheet"/></head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea"><div id="rapids-doxygen-container"><div class="rapids-home-container"><a class="rapids-home-container__home-btn" href="/api">Home</a></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">libcugraph</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/clx/stable/api.html">clx</a><a class="rapids-selector__menu-item" href="/api/cudf-java/stable">cudf-java</a><a class="rapids-selector__menu-item" href="/api/cudf/stable/api.html">cudf</a><a class="rapids-selector__menu-item" href="/api/cugraph/stable/api.html">cugraph</a><a class="rapids-selector__menu-item" href="/api/cuml/stable/api.html">cuml</a><a class="rapids-selector__menu-item" href="/api/cusignal/stable/api.html">cusignal</a><a class="rapids-selector__menu-item" href="/api/cuspatial/stable/api.html">cuspatial</a><a class="rapids-selector__menu-item" href="/api/cuxfilter/stable">cuxfilter</a><a class="rapids-selector__menu-item" href="/api/libcudf/stable/namespacecudf.html">libcudf</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/stable">libcugraph</a><a class="rapids-selector__menu-item" href="/api/libcuml/stable">libcuml</a><a class="rapids-selector__menu-item" href="/api/libnvstrings/stable/annotated.html">libnvstrings</a><a class="rapids-selector__menu-item" href="/api/nvstrings/stable/api.html">nvstrings</a><a class="rapids-selector__menu-item" href="/api/rmm/stable/annotated.html">rmm</a></div></div><div class="rapids-selector__container rapids-selector--hidden"><div class="rapids-selector__selected">stable (0.14)</div><div class="rapids-selector__menu"><a class="rapids-selector__menu-item" href="/api/libcugraph/nightly">nightly (0.15)</a><a class="rapids-selector__menu-item rapids-selector__menu-item--selected" href="/api/libcugraph/stable">stable (0.14)</a><a class="rapids-selector__menu-item" href="/api/libcugraph/legacy">legacy (0.13)</a></div></div></div>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script src="menudata.js" type="text/javascript"></script>
<script src="menu.js" type="text/javascript"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow" onkeydown="return searchBox.OnSearchSelectKey(event)" onmouseout="return searchBox.OnSearchSelectHide()" onmouseover="return searchBox.OnSearchSelectShow()">
</div>
<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe frameborder="0" id="MSearchResults" name="MSearchResults" src="javascript:void(0)">
</iframe>
</div>
</div><!-- top -->
<div class="header">
<div class="summary">
<a href="#nested-classes">Classes</a> |
<a href="#enum-members">Enumerations</a> |
<a href="#func-members">Functions</a> </div>
<div class="headertitle">
<div class="title">cugraph Namespace Reference</div> </div>
</div><!--header-->
<div class="contents">
<p>Katz Centrality implementation.  
<a href="namespacecugraph.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1cuda__error.html">cuda_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Exception thrown when a CUDA error is encountered.  <a href="structcugraph_1_1cuda__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:"><td align="right" class="memItemLeft" valign="top">struct  </td><td class="memItemRight" valign="bottom"><a class="el" href="structcugraph_1_1logic__error.html">logic_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft"> </td><td class="mdescRight">Exception thrown when logical precondition is violated.  <a href="structcugraph_1_1logic__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a365647c6c8b681e9af24661537ee6e27"><td align="right" class="memItemLeft" valign="top">enum  </td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> { <b>CUGRAPH_WEAK</b> = 0, 
<a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27a5882369885616cc6ba190202b140ee02">cugraph_cc_t::CUGRAPH_STRONG</a>, 
<a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27a436bdad1238dd6b8309bdbd0150c0e65">cugraph_cc_t::NUM_CONNECTIVITY_TYPES</a>
 }</td></tr>
<tr class="separator:a365647c6c8b681e9af24661537ee6e27"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af9735ae2264898b1ced8393871e4d263"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </td></tr>
<tr class="memitem:af9735ae2264898b1ced8393871e4d263"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#af9735ae2264898b1ced8393871e4d263">betweenness_centrality</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, result_t *result, bool normalized=true, bool endpoints=false, WT const *weight=nullptr, VT k=0, VT const *vertices=nullptr)</td></tr>
<tr class="memdesc:af9735ae2264898b1ced8393871e4d263"><td class="mdescLeft"> </td><td class="mdescRight">Compute betweenness centrality for a graph.  <a href="namespacecugraph.html#af9735ae2264898b1ced8393871e4d263">More...</a><br/></td></tr>
<tr class="separator:af9735ae2264898b1ced8393871e4d263"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad3cd81b0f53e6ea1bc987f2b8f17f7e7"><td align="right" class="memItemLeft" valign="top"><a id="ad3cd81b0f53e6ea1bc987f2b8f17f7e7"></a>
template void </td><td class="memItemRight" valign="bottom"><b>betweenness_centrality&lt; int, int, float, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, float &gt; const &amp;, float *, bool, bool, float const *, int, int const *)</td></tr>
<tr class="separator:ad3cd81b0f53e6ea1bc987f2b8f17f7e7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa4d1f68cabb9e85ba87323cd0f03f9f6"><td align="right" class="memItemLeft" valign="top"><a id="aa4d1f68cabb9e85ba87323cd0f03f9f6"></a>
template void </td><td class="memItemRight" valign="bottom"><b>betweenness_centrality&lt; int, int, double, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, double &gt; const &amp;, double *, bool, bool, double const *, int, int const *)</td></tr>
<tr class="separator:aa4d1f68cabb9e85ba87323cd0f03f9f6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4a5cc4561f8d4351c342736c6231c560"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </td></tr>
<tr class="memitem:a4a5cc4561f8d4351c342736c6231c560"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a4a5cc4561f8d4351c342736c6231c560">katz_centrality</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, result_t *result, double alpha, int max_iter, double tol, bool has_guess, bool normalized)</td></tr>
<tr class="memdesc:a4a5cc4561f8d4351c342736c6231c560"><td class="mdescLeft"> </td><td class="mdescRight">Compute the Katz centrality for the nodes of the graph G.  <a href="namespacecugraph.html#a4a5cc4561f8d4351c342736c6231c560">More...</a><br/></td></tr>
<tr class="separator:a4a5cc4561f8d4351c342736c6231c560"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a505046d9201d75dd4f4391a08f78e8b9"><td align="right" class="memItemLeft" valign="top"><a id="a505046d9201d75dd4f4391a08f78e8b9"></a>
template void </td><td class="memItemRight" valign="bottom"><b>katz_centrality&lt; int, int, float, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, float &gt; const &amp;, double *, double, int, double, bool, bool)</td></tr>
<tr class="separator:a505046d9201d75dd4f4391a08f78e8b9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2ba0a7b1d781a3a58970277d53749261"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a2ba0a7b1d781a3a58970277d53749261"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a2ba0a7b1d781a3a58970277d53749261">ecg</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph_csr, WT min_weight, VT ensemble_size, VT *ecg_parts)</td></tr>
<tr class="memdesc:a2ba0a7b1d781a3a58970277d53749261"><td class="mdescLeft"> </td><td class="mdescRight">Computes the ecg clustering of the given graph.  <a href="namespacecugraph.html#a2ba0a7b1d781a3a58970277d53749261">More...</a><br/></td></tr>
<tr class="separator:a2ba0a7b1d781a3a58970277d53749261"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4c0f1cf1e01be99e1f94211977fd54c8"><td align="right" class="memItemLeft" valign="top"><a id="a4c0f1cf1e01be99e1f94211977fd54c8"></a>
template void </td><td class="memItemRight" valign="bottom"><b>ecg&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, float min_weight, int32_t ensemble_size, int32_t *ecg_parts)</td></tr>
<tr class="separator:a4c0f1cf1e01be99e1f94211977fd54c8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9890c1c7960f1d8e13aaf76e081a8387"><td align="right" class="memItemLeft" valign="top"><a id="a9890c1c7960f1d8e13aaf76e081a8387"></a>
template void </td><td class="memItemRight" valign="bottom"><b>ecg&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, double min_weight, int32_t ensemble_size, int32_t *ecg_parts)</td></tr>
<tr class="separator:a9890c1c7960f1d8e13aaf76e081a8387"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac1b153abaf4d37f58c9ba2c4c406047a"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ac1b153abaf4d37f58c9ba2c4c406047a"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac1b153abaf4d37f58c9ba2c4c406047a">k_truss_subgraph</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;graph, int k, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ac1b153abaf4d37f58c9ba2c4c406047a"><td class="mdescLeft"> </td><td class="mdescRight">Compute k truss for a graph.  <a href="namespacecugraph.html#ac1b153abaf4d37f58c9ba2c4c406047a">More...</a><br/></td></tr>
<tr class="separator:ac1b153abaf4d37f58c9ba2c4c406047a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a591ea13f3203828a6e098cf1bab34450"><td align="right" class="memItemLeft" valign="top"><a id="a591ea13f3203828a6e098cf1bab34450"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; int32_t, int32_t, float &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>k_truss_subgraph&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int, int, float &gt; const &amp;, int, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a591ea13f3203828a6e098cf1bab34450"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a84568d4ae6c011c454a8381daef0fa3f"><td align="right" class="memItemLeft" valign="top"><a id="a84568d4ae6c011c454a8381daef0fa3f"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; int32_t, int32_t, double &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>k_truss_subgraph&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int, int, double &gt; const &amp;, int, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a84568d4ae6c011c454a8381daef0fa3f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab5f3bcab8ac059258061c8b2dc5380d2"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ab5f3bcab8ac059258061c8b2dc5380d2"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ab5f3bcab8ac059258061c8b2dc5380d2">louvain</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT *final_modularity, int *num_level, VT *louvain_parts, int max_iter=100)</td></tr>
<tr class="memdesc:ab5f3bcab8ac059258061c8b2dc5380d2"><td class="mdescLeft"> </td><td class="mdescRight">Louvain implementation.  <a href="namespacecugraph.html#ab5f3bcab8ac059258061c8b2dc5380d2">More...</a><br/></td></tr>
<tr class="separator:ab5f3bcab8ac059258061c8b2dc5380d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a199afad1a9e13832c341611e19efd347"><td align="right" class="memItemLeft" valign="top"><a id="a199afad1a9e13832c341611e19efd347"></a>
template void </td><td class="memItemRight" valign="bottom"><b>louvain</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float *, int *, int32_t *, int)</td></tr>
<tr class="separator:a199afad1a9e13832c341611e19efd347"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a051fe2e65332d0c364c75fdaa036a009"><td align="right" class="memItemLeft" valign="top"><a id="a051fe2e65332d0c364c75fdaa036a009"></a>
template void </td><td class="memItemRight" valign="bottom"><b>louvain</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double *, int *, int32_t *, int)</td></tr>
<tr class="separator:a051fe2e65332d0c364c75fdaa036a009"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a464a3fd968b4002beb3694e60f4090fd"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a464a3fd968b4002beb3694e60f4090fd"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a464a3fd968b4002beb3694e60f4090fd">connected_components</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> connectivity_type, VT *labels)</td></tr>
<tr class="memdesc:a464a3fd968b4002beb3694e60f4090fd"><td class="mdescLeft"> </td><td class="mdescRight">Compute connected components.  <a href="namespacecugraph.html#a464a3fd968b4002beb3694e60f4090fd">More...</a><br/></td></tr>
<tr class="separator:a464a3fd968b4002beb3694e60f4090fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d033224f5b7c64a79f07ac59038b18a"><td align="right" class="memItemLeft" valign="top"><a id="a2d033224f5b7c64a79f07ac59038b18a"></a>
template void </td><td class="memItemRight" valign="bottom"><b>connected_components&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>, int32_t *)</td></tr>
<tr class="separator:a2d033224f5b7c64a79f07ac59038b18a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a62a5f86376b41d3ae86323aa02bc9d13"><td align="right" class="memItemLeft" valign="top"><a id="a62a5f86376b41d3ae86323aa02bc9d13"></a>
template void </td><td class="memItemRight" valign="bottom"><b>connected_components&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a>, int64_t *)</td></tr>
<tr class="separator:a62a5f86376b41d3ae86323aa02bc9d13"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae6eac44f16add8d9575a13366761023e"><td align="right" class="memItemLeft" valign="top"><a id="ae6eac44f16add8d9575a13366761023e"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCSR.html">experimental::GraphCSR</a>&lt; int32_t, int32_t, float &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:ae6eac44f16add8d9575a13366761023e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aab24fd1572ebfee5cc65d96ba73da92f"><td align="right" class="memItemLeft" valign="top"><a id="aab24fd1572ebfee5cc65d96ba73da92f"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCSR.html">experimental::GraphCSR</a>&lt; int32_t, int32_t, double &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>coo_to_csr&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;graph, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:aab24fd1572ebfee5cc65d96ba73da92f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad639855bed144d03aa710d4ecc865049"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ad639855bed144d03aa710d4ecc865049"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCSR.html">experimental::GraphCSR</a>&lt; VT, ET, WT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad639855bed144d03aa710d4ecc865049">coo_to_csr</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;graph, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:ad639855bed144d03aa710d4ecc865049"><td class="mdescLeft"> </td><td class="mdescRight">Convert COO to CSR.  <a href="namespacecugraph.html#ad639855bed144d03aa710d4ecc865049">More...</a><br/></td></tr>
<tr class="separator:ad639855bed144d03aa710d4ecc865049"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6c217cb925b7bda03df5a1d5e971810e"><td class="memTemplParams" colspan="2"><a id="a6c217cb925b7bda03df5a1d5e971810e"></a>
template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a6c217cb925b7bda03df5a1d5e971810e"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><b>coo_to_csr_inplace</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; &amp;graph, <a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; &amp;result)</td></tr>
<tr class="separator:a6c217cb925b7bda03df5a1d5e971810e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3eba88220e47be34a4351a4378116545"><td class="memTemplParams" colspan="2">template&lt;typename VT_IN , typename VT_OUT , typename ET &gt; </td></tr>
<tr class="memitem:a3eba88220e47be34a4351a4378116545"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; rmm::device_buffer &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a3eba88220e47be34a4351a4378116545">renumber_vertices</a> (ET number_of_edges, VT_IN const *src, VT_IN const *dst, VT_OUT *src_renumbered, VT_OUT *dst_renumbered, ET *map_size, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a3eba88220e47be34a4351a4378116545"><td class="mdescLeft"> </td><td class="mdescRight">Renumber source and destination indices.  <a href="namespacecugraph.html#a3eba88220e47be34a4351a4378116545">More...</a><br/></td></tr>
<tr class="separator:a3eba88220e47be34a4351a4378116545"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a74a3fb865292a09ae8c07c12dfdd48e2"><td align="right" class="memItemLeft" valign="top"><a id="a74a3fb865292a09ae8c07c12dfdd48e2"></a>
template std::unique_ptr&lt; rmm::device_buffer &gt; </td><td class="memItemRight" valign="bottom"><b>renumber_vertices</b> (int32_t, int64_t const *, int64_t const *, int32_t *, int32_t *, int32_t *, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a74a3fb865292a09ae8c07c12dfdd48e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa0ebd3d21f6da446ed6e6772e8c2c60f"><td align="right" class="memItemLeft" valign="top"><a id="aa0ebd3d21f6da446ed6e6772e8c2c60f"></a>
template std::unique_ptr&lt; rmm::device_buffer &gt; </td><td class="memItemRight" valign="bottom"><b>renumber_vertices</b> (int32_t, int32_t const *, int32_t const *, int32_t *, int32_t *, int32_t *, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:aa0ebd3d21f6da446ed6e6772e8c2c60f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8586a22ab60adaa041bc492e5e98beeb"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a8586a22ab60adaa041bc492e5e98beeb"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8586a22ab60adaa041bc492e5e98beeb">core_number</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, VT *core_number)</td></tr>
<tr class="memdesc:a8586a22ab60adaa041bc492e5e98beeb"><td class="mdescLeft"> </td><td class="mdescRight">Compute the Core Number for the nodes of the graph G.  <a href="namespacecugraph.html#a8586a22ab60adaa041bc492e5e98beeb">More...</a><br/></td></tr>
<tr class="separator:a8586a22ab60adaa041bc492e5e98beeb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f4653d80a07bc3703194a2ede066a97"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a8f4653d80a07bc3703194a2ede066a97"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a8f4653d80a07bc3703194a2ede066a97">k_core</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp;graph, int k, VT const *vertex_id, VT const *<a class="el" href="namespacecugraph.html#a8586a22ab60adaa041bc492e5e98beeb">core_number</a>, VT num_vertex_ids, rmm::mr::device_memory_resource *mr=rmm::mr::get_default_resource())</td></tr>
<tr class="memdesc:a8f4653d80a07bc3703194a2ede066a97"><td class="mdescLeft"> </td><td class="mdescRight">Compute K Core of the graph G.  <a href="namespacecugraph.html#a8f4653d80a07bc3703194a2ede066a97">More...</a><br/></td></tr>
<tr class="separator:a8f4653d80a07bc3703194a2ede066a97"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9dd1e68b1e0e6bc4e56681b09a40ed2a"><td align="right" class="memItemLeft" valign="top"><a id="a9dd1e68b1e0e6bc4e56681b09a40ed2a"></a>
template void </td><td class="memItemRight" valign="bottom"><b>core_number&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int32_t *<a class="el" href="namespacecugraph.html#a8586a22ab60adaa041bc492e5e98beeb">core_number</a>)</td></tr>
<tr class="separator:a9dd1e68b1e0e6bc4e56681b09a40ed2a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a589d6f87fbde14952a13b6dca17d0f1b"><td align="right" class="memItemLeft" valign="top"><a id="a589d6f87fbde14952a13b6dca17d0f1b"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; int32_t, int32_t, float &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>k_core&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int32_t, int32_t, float &gt; const &amp;, int, int32_t const *, int32_t const *, int32_t, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a589d6f87fbde14952a13b6dca17d0f1b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b446724e4c1c17247532c74c010cb6d"><td align="right" class="memItemLeft" valign="top"><a id="a6b446724e4c1c17247532c74c010cb6d"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; int32_t, int32_t, double &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>k_core&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int32_t, int32_t, double &gt; const &amp;, int, int32_t const *, int32_t const *, int32_t, rmm::mr::device_memory_resource *)</td></tr>
<tr class="separator:a6b446724e4c1c17247532c74c010cb6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac9d27efe68d8715ee723ebbca0742188"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ac9d27efe68d8715ee723ebbca0742188"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac9d27efe68d8715ee723ebbca0742188">force_atlas2</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; &amp;graph, float *pos, const int max_iter=500, float *x_start=nullptr, float *y_start=nullptr, bool outbound_attraction_distribution=true, bool lin_log_mode=false, bool prevent_overlapping=false, const float edge_weight_influence=1.0, const float jitter_tolerance=1.0, bool barnes_hut_optimize=true, const float barnes_hut_theta=0.5, const float scaling_ratio=2.0, bool strong_gravity_mode=false, const float gravity=1.0, bool verbose=false, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback=nullptr)</td></tr>
<tr class="memdesc:ac9d27efe68d8715ee723ebbca0742188"><td class="mdescLeft"> </td><td class="mdescRight">ForceAtlas2 is a continuous graph layout algorithm for handy network visualization.  <a href="namespacecugraph.html#ac9d27efe68d8715ee723ebbca0742188">More...</a><br/></td></tr>
<tr class="separator:ac9d27efe68d8715ee723ebbca0742188"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a9de2a8215103029e477b6b8122432e6a"><td align="right" class="memItemLeft" valign="top"><a id="a9de2a8215103029e477b6b8122432e6a"></a>
template void </td><td class="memItemRight" valign="bottom"><b>force_atlas2&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int, int, float &gt; &amp;graph, float *pos, const int max_iter, float *x_start, float *y_start, bool outbound_attraction_distribution, bool lin_log_mode, bool prevent_overlapping, const float edge_weight_influence, const float jitter_tolerance, bool barnes_hut_optimize, const float barnes_hut_theta, const float scaling_ratio, bool strong_gravity_mode, const float gravity, bool verbose, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback)</td></tr>
<tr class="separator:a9de2a8215103029e477b6b8122432e6a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2c2e54875cdbb66af9297762f12eb61f"><td align="right" class="memItemLeft" valign="top"><a id="a2c2e54875cdbb66af9297762f12eb61f"></a>
template void </td><td class="memItemRight" valign="bottom"><b>force_atlas2&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; int, int, double &gt; &amp;graph, float *pos, const int max_iter, float *x_start, float *y_start, bool outbound_attraction_distribution, bool lin_log_mode, bool prevent_overlapping, const float edge_weight_influence, const float jitter_tolerance, bool barnes_hut_optimize, const float barnes_hut_theta, const float scaling_ratio, bool strong_gravity_mode, const float gravity, bool verbose, <a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> *callback)</td></tr>
<tr class="separator:a2c2e54875cdbb66af9297762f12eb61f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abe6bd1c7884de072d7d4ebebd908d7cd"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:abe6bd1c7884de072d7d4ebebd908d7cd"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#abe6bd1c7884de072d7d4ebebd908d7cd">pagerank</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSCView.html">experimental::GraphCSCView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT *pagerank, VT personalization_subset_size=0, VT *personalization_subset=nullptr, WT *personalization_values=nullptr, double alpha=0.85, double tolerance=1e-5, int64_t max_iter=500, bool has_guess=false)</td></tr>
<tr class="memdesc:abe6bd1c7884de072d7d4ebebd908d7cd"><td class="mdescLeft"> </td><td class="mdescRight">Find the PageRank vertex values for a graph.  <a href="namespacecugraph.html#abe6bd1c7884de072d7d4ebebd908d7cd">More...</a><br/></td></tr>
<tr class="separator:abe6bd1c7884de072d7d4ebebd908d7cd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6ea1ea5750e588d4326bcea5eade85d"><td align="right" class="memItemLeft" valign="top"><a id="ac6ea1ea5750e588d4326bcea5eade85d"></a>
template void </td><td class="memItemRight" valign="bottom"><b>pagerank&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSCView.html">experimental::GraphCSCView</a>&lt; int, int, float &gt; const &amp;graph, float *<a class="el" href="namespacecugraph.html#abe6bd1c7884de072d7d4ebebd908d7cd">pagerank</a>, int personalization_subset_size, int *personalization_subset, float *personalization_values, double alpha, double tolerance, int64_t max_iter, bool has_guess)</td></tr>
<tr class="separator:ac6ea1ea5750e588d4326bcea5eade85d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6114d63f76515cd02f9b0abceb5a9152"><td align="right" class="memItemLeft" valign="top"><a id="a6114d63f76515cd02f9b0abceb5a9152"></a>
template void </td><td class="memItemRight" valign="bottom"><b>pagerank&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSCView.html">experimental::GraphCSCView</a>&lt; int, int, double &gt; const &amp;graph, double *<a class="el" href="namespacecugraph.html#abe6bd1c7884de072d7d4ebebd908d7cd">pagerank</a>, int personalization_subset_size, int *personalization_subset, double *personalization_values, double alpha, double tolerance, int64_t max_iter, bool has_guess)</td></tr>
<tr class="separator:a6114d63f76515cd02f9b0abceb5a9152"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a5c86ae51264c248597c0d22c0a093fa1"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a5c86ae51264c248597c0d22c0a093fa1"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a5c86ae51264c248597c0d22c0a093fa1">jaccard</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, WT *result)</td></tr>
<tr class="memdesc:a5c86ae51264c248597c0d22c0a093fa1"><td class="mdescLeft"> </td><td class="mdescRight">Compute jaccard similarity coefficient for all vertices.  <a href="namespacecugraph.html#a5c86ae51264c248597c0d22c0a093fa1">More...</a><br/></td></tr>
<tr class="separator:a5c86ae51264c248597c0d22c0a093fa1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac32f7b2f2cf849fa8f3e4f9b8b85fd68"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ac32f7b2f2cf849fa8f3e4f9b8b85fd68"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ac32f7b2f2cf849fa8f3e4f9b8b85fd68">jaccard_list</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, ET num_pairs, VT const *first, VT const *second, WT *result)</td></tr>
<tr class="memdesc:ac32f7b2f2cf849fa8f3e4f9b8b85fd68"><td class="mdescLeft"> </td><td class="mdescRight">Compute jaccard similarity coefficient for selected vertex pairs.  <a href="namespacecugraph.html#ac32f7b2f2cf849fa8f3e4f9b8b85fd68">More...</a><br/></td></tr>
<tr class="separator:ac32f7b2f2cf849fa8f3e4f9b8b85fd68"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b290fdc40ace11b37486258227a5ddf"><td align="right" class="memItemLeft" valign="top"><a id="a7b290fdc40ace11b37486258227a5ddf"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a7b290fdc40ace11b37486258227a5ddf"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec7ddb96dc8a7ab2e0835e5623e1587e"><td align="right" class="memItemLeft" valign="top"><a id="aec7ddb96dc8a7ab2e0835e5623e1587e"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:aec7ddb96dc8a7ab2e0835e5623e1587e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a1f00ff4cbc28adab6401b55cb5ccb722"><td align="right" class="memItemLeft" valign="top"><a id="a1f00ff4cbc28adab6401b55cb5ccb722"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a1f00ff4cbc28adab6401b55cb5ccb722"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2b863b0b0b16544bc7adb1781a464cf4"><td align="right" class="memItemLeft" valign="top"><a id="a2b863b0b0b16544bc7adb1781a464cf4"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:a2b863b0b0b16544bc7adb1781a464cf4"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7811f9d57ffb828e30b715e79c11afc6"><td align="right" class="memItemLeft" valign="top"><a id="a7811f9d57ffb828e30b715e79c11afc6"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, int32_t, int32_t const *, int32_t const *, float *)</td></tr>
<tr class="separator:a7811f9d57ffb828e30b715e79c11afc6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a82ff3ce7f5c4540b589fe3fcc5ba3b08"><td align="right" class="memItemLeft" valign="top"><a id="a82ff3ce7f5c4540b589fe3fcc5ba3b08"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, int32_t, int32_t const *, int32_t const *, double *)</td></tr>
<tr class="separator:a82ff3ce7f5c4540b589fe3fcc5ba3b08"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abd9f074637f01a76c24c0721bd79898b"><td align="right" class="memItemLeft" valign="top"><a id="abd9f074637f01a76c24c0721bd79898b"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, int64_t, int64_t const *, int64_t const *, float *)</td></tr>
<tr class="separator:abd9f074637f01a76c24c0721bd79898b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aa22461cf5ed9d141539845fe197a6a83"><td align="right" class="memItemLeft" valign="top"><a id="aa22461cf5ed9d141539845fe197a6a83"></a>
template void </td><td class="memItemRight" valign="bottom"><b>jaccard_list&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, int64_t, int64_t const *, int64_t const *, double *)</td></tr>
<tr class="separator:aa22461cf5ed9d141539845fe197a6a83"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0f945174cdbdf1e40211564103b2824f"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:a0f945174cdbdf1e40211564103b2824f"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a0f945174cdbdf1e40211564103b2824f">overlap</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, WT *result)</td></tr>
<tr class="memdesc:a0f945174cdbdf1e40211564103b2824f"><td class="mdescLeft"> </td><td class="mdescRight">Compute overlap coefficient for all vertices in the graph.  <a href="namespacecugraph.html#a0f945174cdbdf1e40211564103b2824f">More...</a><br/></td></tr>
<tr class="separator:a0f945174cdbdf1e40211564103b2824f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad8da8639b2acd1a83d738bb639e622fc"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ad8da8639b2acd1a83d738bb639e622fc"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad8da8639b2acd1a83d738bb639e622fc">overlap_list</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT const *weights, ET num_pairs, VT const *first, VT const *second, WT *result)</td></tr>
<tr class="memdesc:ad8da8639b2acd1a83d738bb639e622fc"><td class="mdescLeft"> </td><td class="mdescRight">Compute overlap coefficient for select pairs of vertices.  <a href="namespacecugraph.html#ad8da8639b2acd1a83d738bb639e622fc">More...</a><br/></td></tr>
<tr class="separator:ad8da8639b2acd1a83d738bb639e622fc"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac48d6838173b4e9533493f6bd7cb9f54"><td align="right" class="memItemLeft" valign="top"><a id="ac48d6838173b4e9533493f6bd7cb9f54"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:ac48d6838173b4e9533493f6bd7cb9f54"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad36728e07d25ef083d25c52f158a9e9e"><td align="right" class="memItemLeft" valign="top"><a id="ad36728e07d25ef083d25c52f158a9e9e"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:ad36728e07d25ef083d25c52f158a9e9e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a38eb1bca6f624d1df504b5845c434c0f"><td align="right" class="memItemLeft" valign="top"><a id="a38eb1bca6f624d1df504b5845c434c0f"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, float *)</td></tr>
<tr class="separator:a38eb1bca6f624d1df504b5845c434c0f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac0b08b8d7c74dcec257b10b39115e060"><td align="right" class="memItemLeft" valign="top"><a id="ac0b08b8d7c74dcec257b10b39115e060"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, double *)</td></tr>
<tr class="separator:ac0b08b8d7c74dcec257b10b39115e060"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae2f1554abbe4f623da86ec8fa45324b2"><td align="right" class="memItemLeft" valign="top"><a id="ae2f1554abbe4f623da86ec8fa45324b2"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int32_t, int32_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, float &gt; const &amp;, float const *, int32_t, int32_t const *, int32_t const *, float *)</td></tr>
<tr class="separator:ae2f1554abbe4f623da86ec8fa45324b2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3c06316042ecf67e2e965d5a7c192e88"><td align="right" class="memItemLeft" valign="top"><a id="a3c06316042ecf67e2e965d5a7c192e88"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int32_t, int32_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int32_t, int32_t, double &gt; const &amp;, double const *, int32_t, int32_t const *, int32_t const *, double *)</td></tr>
<tr class="separator:a3c06316042ecf67e2e965d5a7c192e88"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae8cd79957fe334b43013b1ac0a86ff09"><td align="right" class="memItemLeft" valign="top"><a id="ae8cd79957fe334b43013b1ac0a86ff09"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int64_t, int64_t, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, float &gt; const &amp;, float const *, int64_t, int64_t const *, int64_t const *, float *)</td></tr>
<tr class="separator:ae8cd79957fe334b43013b1ac0a86ff09"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae18bf58b0ca656750c2501e228ccdba7"><td align="right" class="memItemLeft" valign="top"><a id="ae18bf58b0ca656750c2501e228ccdba7"></a>
template void </td><td class="memItemRight" valign="bottom"><b>overlap_list&lt; int64_t, int64_t, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int64_t, int64_t, double &gt; const &amp;, double const *, int64_t, int64_t const *, int64_t const *, double *)</td></tr>
<tr class="separator:ae18bf58b0ca656750c2501e228ccdba7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad27ae2963f608e797b23436525ca341a"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ad27ae2963f608e797b23436525ca341a"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad27ae2963f608e797b23436525ca341a">bfs</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, VT *distances, VT *predecessors, double *sp_counters, const VT start_vertex, bool directed)</td></tr>
<tr class="separator:ad27ae2963f608e797b23436525ca341a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0387c5809f5847d5bd740b7f54e2a6e6"><td align="right" class="memItemLeft" valign="top"><a id="a0387c5809f5847d5bd740b7f54e2a6e6"></a>
template void </td><td class="memItemRight" valign="bottom"><b>bfs&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, float &gt; const &amp;graph, int *distances, int *predecessors, double *sp_counters, const int source_vertex, bool directed)</td></tr>
<tr class="separator:a0387c5809f5847d5bd740b7f54e2a6e6"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a95b1f98d14b0f3b58ed4957c3ad4b135"><td align="right" class="memItemLeft" valign="top"><a id="a95b1f98d14b0f3b58ed4957c3ad4b135"></a>
template void </td><td class="memItemRight" valign="bottom"><b>bfs&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, double &gt; const &amp;graph, int *distances, int *predecessors, double *sp_counters, const int source_vertex, bool directed)</td></tr>
<tr class="separator:a95b1f98d14b0f3b58ed4957c3ad4b135"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad46fa64646df0df9737055649c7acc71"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:ad46fa64646df0df9737055649c7acc71"><td align="right" class="memTemplItemLeft" valign="top">void </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#ad46fa64646df0df9737055649c7acc71">sssp</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph, WT *distances, VT *predecessors, const VT source_vertex)</td></tr>
<tr class="memdesc:ad46fa64646df0df9737055649c7acc71"><td class="mdescLeft"> </td><td class="mdescRight">Native sssp with predecessors.  <a href="namespacecugraph.html#ad46fa64646df0df9737055649c7acc71">More...</a><br/></td></tr>
<tr class="separator:ad46fa64646df0df9737055649c7acc71"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91531c0bdb6068afd2ecdbf3648465f5"><td align="right" class="memItemLeft" valign="top"><a id="a91531c0bdb6068afd2ecdbf3648465f5"></a>
template void </td><td class="memItemRight" valign="bottom"><b>sssp&lt; int, int, float &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, float &gt; const &amp;graph, float *distances, int *predecessors, const int source_vertex)</td></tr>
<tr class="separator:a91531c0bdb6068afd2ecdbf3648465f5"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad87056bdec269b8bf0a7c9e5bd66d763"><td align="right" class="memItemLeft" valign="top"><a id="ad87056bdec269b8bf0a7c9e5bd66d763"></a>
template void </td><td class="memItemRight" valign="bottom"><b>sssp&lt; int, int, double &gt;</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, double &gt; const &amp;graph, double *distances, int *predecessors, const int source_vertex)</td></tr>
<tr class="separator:ad87056bdec269b8bf0a7c9e5bd66d763"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:abb057b64c6715542101620df81487e2e"><td class="memTemplParams" colspan="2">template&lt;typename VT , typename ET , typename WT &gt; </td></tr>
<tr class="memitem:abb057b64c6715542101620df81487e2e"><td align="right" class="memTemplItemLeft" valign="top">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">cugraph::experimental::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#abb057b64c6715542101620df81487e2e">get_two_hop_neighbors</a> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp;graph)</td></tr>
<tr class="memdesc:abb057b64c6715542101620df81487e2e"><td class="mdescLeft"> </td><td class="mdescRight">Find all 2-hop neighbors in the graph.  <a href="namespacecugraph.html#abb057b64c6715542101620df81487e2e">More...</a><br/></td></tr>
<tr class="separator:abb057b64c6715542101620df81487e2e"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0742bcb9f90235dc7d35dc600b69254"><td align="right" class="memItemLeft" valign="top"><a id="af0742bcb9f90235dc7d35dc600b69254"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">cugraph::experimental::GraphCOO</a>&lt; int, int, float &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>get_two_hop_neighbors</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, float &gt; const &amp;)</td></tr>
<tr class="separator:af0742bcb9f90235dc7d35dc600b69254"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0198efc01008b8bd1400ec5cfc7a87b"><td align="right" class="memItemLeft" valign="top"><a id="ae0198efc01008b8bd1400ec5cfc7a87b"></a>
template std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">cugraph::experimental::GraphCOO</a>&lt; int, int, double &gt; &gt; </td><td class="memItemRight" valign="bottom"><b>get_two_hop_neighbors</b> (<a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; int, int, double &gt; const &amp;)</td></tr>
<tr class="separator:ae0198efc01008b8bd1400ec5cfc7a87b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2395e2390e2f10f12c081cb4c635c5df"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t &gt; </td></tr>
<tr class="memitem:a2395e2390e2f10f12c081cb4c635c5df"><td align="right" class="memTemplItemLeft" valign="top">vertex_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a2395e2390e2f10f12c081cb4c635c5df">coo2csr</a> (edge_t num_edges, vertex_t const *src, vertex_t const *dst, edge_t **offsets, vertex_t **indices)</td></tr>
<tr class="memdesc:a2395e2390e2f10f12c081cb4c635c5df"><td class="mdescLeft"> </td><td class="mdescRight">Convert COO to CSR, unweighted.  <a href="namespacecugraph.html#a2395e2390e2f10f12c081cb4c635c5df">More...</a><br/></td></tr>
<tr class="separator:a2395e2390e2f10f12c081cb4c635c5df"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0c590126e8b178515e63ef251d4da2a5"><td class="memTemplParams" colspan="2">template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </td></tr>
<tr class="memitem:a0c590126e8b178515e63ef251d4da2a5"><td align="right" class="memTemplItemLeft" valign="top">vertex_t </td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecugraph.html#a0c590126e8b178515e63ef251d4da2a5">coo2csr_weighted</a> (edge_t num_edges, vertex_t const *src, vertex_t const *dst, weight_t const *weights, edge_t **offsets, vertex_t **indices, weight_t **csr_weights)</td></tr>
<tr class="memdesc:a0c590126e8b178515e63ef251d4da2a5"><td class="mdescLeft"> </td><td class="mdescRight">Convert COO to CSR, weighted.  <a href="namespacecugraph.html#a0c590126e8b178515e63ef251d4da2a5">More...</a><br/></td></tr>
<tr class="separator:a0c590126e8b178515e63ef251d4da2a5"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" name="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Katz Centrality implementation. </p>
<p>Functions for computing the two hop neighbor pairs of a graph.</p>
<p>The cugraph Jaccard core functionality.</p>
<p>Wrapper functions for Nvgraph.</p>
<p>------------------------------------------------------------------------—* </p>
<h2><a class="anchor" id="autotoc_md2"></a>
@file katz_centrality.cu</h2>
<p>------------------------------------------------------------------------—* </p>
<h2><a class="anchor" id="autotoc_md4"></a>
@file nvgraph_wrapper.cpp</h2>
<p>------------------------------------------------------------------------—* </p>
<h2><a class="anchor" id="autotoc_md5"></a>
@file jaccard.cu</h2>
<p>------------------------------------------------------------------------—* </p>
<h2><a class="anchor" id="autotoc_md6"></a>
@file jaccard.cu</h2>
<p>------------------------------------------------------------------------—* </p>
<h2><a class="anchor" id="autotoc_md8"></a>
@file two_hop_neighbors.cu</h2>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a365647c6c8b681e9af24661537ee6e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365647c6c8b681e9af24661537ee6e27">◆ </a></span>cugraph_cc_t</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">enum <a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph::cugraph_cc_t</a></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a365647c6c8b681e9af24661537ee6e27a5882369885616cc6ba190202b140ee02"></a>CUGRAPH_STRONG </td><td class="fielddoc"><blockquote class="doxtable">
<p>Weakly Connected Components </p>
</blockquote>
</td></tr>
<tr><td class="fieldname"><a id="a365647c6c8b681e9af24661537ee6e27a436bdad1238dd6b8309bdbd0150c0e65"></a>NUM_CONNECTIVITY_TYPES </td><td class="fielddoc"><blockquote class="doxtable">
<p>Strongly Connected Components </p>
</blockquote>
</td></tr>
</table>
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af9735ae2264898b1ced8393871e4d263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9735ae2264898b1ced8393871e4d263">◆ </a></span>betweenness_centrality()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::betweenness_centrality </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">result_t * </td>
<td class="paramname"><em>result</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>normalize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>endpoints</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const * </td>
<td class="paramname"><em>weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>vertices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute betweenness centrality for a graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>array&lt;result_t&gt;(number_of_vertices) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalize</td><td>bool True -&gt; Apply normalization </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">endpoints</td><td>(NIY) bool Include endpoints </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>(NIY) array&lt;WT&gt;(number_of_edges) Weights to use </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Number of sources </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>array&lt;VT&gt;(k) Sources for traversal</td></tr>
</table>
</dd>
</dl>
<p>Betweenness centrality for a vertex is the sum of the fraction of all pairs shortest paths that pass through the vertex.</p>
<p>The current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double. </td></tr>
<tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float or double (double only supported in default implementation)</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If true, return normalized scores, if false return unnormalized scores. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">endpoints</td><td>If true, include endpoints of paths in score, if false do not </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>If specified, device array of weights for each edge </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>If specified, number of vertex samples defined in the vertices array. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertices</td><td>If specified, host array of vertex ids to estimate betweenness centrality, these vertices will serve as sources for the traversal algorihtm to obtain shortest path counters. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad27ae2963f608e797b23436525ca341a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27ae2963f608e797b23436525ca341a">◆ </a></span>bfs()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::bfs </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>distances</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>predecessors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double * </td>
<td class="paramname"><em>sp_counters</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const VT </td>
<td class="paramname"><em>start_vertex</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>directed</em> = <code>true</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>@Synopsis Performs a breadth first search traversal of a graph starting from a vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : int (signed, 32-bit)</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>If set to a valid pointer, this is populated by distance of every vertex in the graph from the starting vertex</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">predecessors</td><td>If set to a valid pointer, this is populated by bfs traversal predecessor of every vertex</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">sp_counters</td><td>If set to a valid pointer, this is populated by bfs traversal shortest_path counter of every vertex</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The starting vertex for breadth first search traversal</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">directed</td><td>Treat the input graph as directed</td></tr>
</table>
</dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a464a3fd968b4002beb3694e60f4090fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464a3fd968b4002beb3694e60f4090fd">◆ </a></span>connected_components()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::connected_components </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="namespacecugraph.html#a365647c6c8b681e9af24661537ee6e27">cugraph_cc_t</a> </td>
<td class="paramname"><em>connectivity_type</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>labels</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute connected components. </p>
<p>The weak version (for undirected graphs, only) was imported from cuML. This implementation comes from [1] and solves component labeling problem in parallel on CSR-indexes based upon the vertex degree and adjacency graph.</p>
<p>[1] Hawick, K.A et al, 2010. "Parallel graph component labelling with GPUs and CUDA"</p>
<p>The strong version (for directed or undirected graphs) is based on: [2] Gilbert, J. et al, 2011. "Graph Algorithms in the Language of Linear Algebra"</p>
<p>C = I | A | A^2 |...| A^k where matrix multiplication is via semi-ring: (combine, reduce) == (&amp;, |) (bitwise ops) Then: X = C &amp; transpose(C); and finally, apply get_labels(X);</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">connectivity_type</td><td>STRONG or WEAK </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">labels</td><td>Device array of component labels (labels[i] indicates the label associated with vertex id i. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2395e2390e2f10f12c081cb4c635c5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2395e2390e2f10f12c081cb4c635c5df">◆ </a></span>coo2csr()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t &gt; </div>
<table class="memname">
<tr>
<td class="memname">vertex_t cugraph::coo2csr </td>
<td>(</td>
<td class="paramtype">edge_t </td>
<td class="paramname"><em>num_edges</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const * </td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const * </td>
<td class="paramname"><em>dst</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">edge_t ** </td>
<td class="paramname"><em>offsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t ** </td>
<td class="paramname"><em>indices</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convert COO to CSR, unweighted. </p>
<p>Takes a list of edges in COOrdinate format and generates a CSR format. Note, if you want CSC format simply pass the src and dst arrays in the opposite order.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">vertex_t</td><td>type of vertex index </td></tr>
<tr><td class="paramname">edge_t</td><td>type of edge index</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">num_edges</td><td>Number of edges </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Device array containing original source vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Device array containing original dest vertices </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>Device array containing the CSR offsets </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Device array containing the CSR indices</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unique vertices in the src and dst arrays </dd></dl>
</div>
</div>
<a id="a0c590126e8b178515e63ef251d4da2a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c590126e8b178515e63ef251d4da2a5">◆ </a></span>coo2csr_weighted()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename vertex_t , typename edge_t , typename weight_t &gt; </div>
<table class="memname">
<tr>
<td class="memname">vertex_t cugraph::coo2csr_weighted </td>
<td>(</td>
<td class="paramtype">edge_t </td>
<td class="paramname"><em>num_edges</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const * </td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t const * </td>
<td class="paramname"><em>dst</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t const * </td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">edge_t ** </td>
<td class="paramname"><em>offsets</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">vertex_t ** </td>
<td class="paramname"><em>indices</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">weight_t ** </td>
<td class="paramname"><em>csr_weights</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convert COO to CSR, weighted. </p>
<p>Takes a list of edges in COOrdinate format and generates a CSR format. Note, if you want CSC format simply pass the src and dst arrays in the opposite order.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">vertex_t</td><td>type of vertex index </td></tr>
<tr><td class="paramname">edge_t</td><td>type of edge index </td></tr>
<tr><td class="paramname">weight_t</td><td>type of the edge weight</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">num_edges</td><td>Number of edges </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Device array containing original source vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Device array containing original dest vertices </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>Device array containing original edge weights </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">offsets</td><td>Device array containing the CSR offsets </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">indices</td><td>Device array containing the CSR indices </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">csr_weights</td><td>Device array containing the CSR edge weights</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of unique vertices in the src and dst arrays </dd></dl>
</div>
</div>
<a id="ad639855bed144d03aa710d4ecc865049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad639855bed144d03aa710d4ecc865049">◆ </a></span>coo_to_csr()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCSR.html">experimental::GraphCSR</a>&lt; VT, ET, WT &gt; &gt; cugraph::coo_to_csr </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Convert COO to CSR. </p>
<p>Takes a list of edges in COOrdinate format and generates a CSR format.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>type of vertex index </td></tr>
<tr><td class="paramname">ET</td><td>type of edge index </td></tr>
<tr><td class="paramname">WT</td><td>type of the edge weight</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph in coordinate format </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to generate Compressed Sparse Row graph </dd></dl>
</div>
</div>
<a id="a8586a22ab60adaa041bc492e5e98beeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8586a22ab60adaa041bc492e5e98beeb">◆ </a></span>core_number()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::core_number </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>core_number</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the Core Number for the nodes of the graph G. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor with a valid edgeList or adjList </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">core_number</td><td>Populated by the core number of every vertex in the graph</td></tr>
</table>
</dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a2ba0a7b1d781a3a58970277d53749261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba0a7b1d781a3a58970277d53749261">◆ </a></span>ecg()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::ecg </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph_csr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT </td>
<td class="paramname"><em>min_weight</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT </td>
<td class="paramname"><em>ensemble_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>ecg_parts</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Computes the ecg clustering of the given graph. </p>
<p>ECG runs truncated Louvain on an ensemble of permutations of the input graph, then uses the ensemble partitions to determine weights for the input graph. The final result is found by running full Louvain on the input graph using the determined weights. See <a href="https://arxiv.org/abs/1809.05578">https://arxiv.org/abs/1809.05578</a> for further information.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph_coo</td><td>input graph object (COO) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">graph_csr</td><td>input graph object (CSR) </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">min_weight</td><td>The minimum weight parameter </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">ensemble_size</td><td>The ensemble size parameter </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">ecg_parts</td><td>A device pointer to array where the partitioning should be written </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ac9d27efe68d8715ee723ebbca0742188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d27efe68d8715ee723ebbca0742188">◆ </a></span>force_atlas2()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::force_atlas2 </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>pos</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const int </td>
<td class="paramname"><em>max_iter</em> = <code>500</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>x_start</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">float * </td>
<td class="paramname"><em>y_start</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>outbound_attraction_distribution</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>lin_log_mode</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>prevent_overlapping</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>edge_weight_influence</em> = <code>1.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>jitter_tolerance</em> = <code>1.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>barnes_hut_optimize</em> = <code>true</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>barnes_hut_theta</em> = <code>0.5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>scaling_ratio</em> = <code>2.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>strong_gravity_mode</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const float </td>
<td class="paramname"><em>gravity</em> = <code>1.0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>verbose</em> = <code>false</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="classcugraph_1_1internals_1_1GraphBasedDimRedCallback.html">internals::GraphBasedDimRedCallback</a> * </td>
<td class="paramname"><em>callback</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>ForceAtlas2 is a continuous graph layout algorithm for handy network visualization. </p>
<pre class="fragment">                                         NOTE: Peak memory allocation occurs at 17*V.
</pre><dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a COO. Graph is considered undirected. Edge weights are used for this algorithm and set to 1 by default. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">pos</td><td>Device array (2, n) containing x-axis and y-axis positions; </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations Force Atlas 2 should run for. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">x_start</td><td>Device array containing starting x-axis positions; </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">y_start</td><td>Device array containing starting y-axis positions; </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">outbound_attraction_distribution</td><td>Distributes attraction along outbound edges. Hubs attract less and thus are pushed to the borders. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">lin_log_mode</td><td>Switch ForceAtlas’ model from lin-lin to lin-log (tribute to Andreas Noack). Makes clusters more tight. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">prevent_overlapping</td><td>Prevent nodes from overlapping. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">edge_weight_influence</td><td>How much influence you give to the edges weight. 0 is “no influence” and 1 is “normal”. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">jitter_tolerance</td><td>How much swinging you allow. Above 1 discouraged. Lower gives less speed and more precision. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut_optimize</td><td>Whether to use the fast Barnes Hut or use the slower exact version. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">barnes_hut_theta</td><td>Float between 0 and 1. Tradeoff for speed (1) vs accuracy (0) for Barnes Hut only. @params[in] scaling_ratio Float strictly positive. How much repulsion you want. More makes a more sparse graph. Switching from regular mode to LinLog mode needs a readjustment of the scaling parameter. @params[in] strong_gravity_mode The “Strong gravity” option sets a force that attracts the nodes that are distant from the center more ( is this distance). This force has the drawback of being so strong that it is sometimes stronger than the other forces. It may result in a biased placement of the nodes. However, its advantage is to force a very compact layout, which may be useful for certain purposes. @params[in] gravity Attracts nodes to the center. Prevents islands from drifting away. @params[in] verbose Output convergence info at each interation. @params[in] callback An instance of GraphBasedDimRedCallback class to intercept the internal state of positions while they are being trained. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="abb057b64c6715542101620df81487e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb057b64c6715542101620df81487e2e">◆ </a></span>get_two_hop_neighbors()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">cugraph::experimental::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::get_two_hop_neighbors </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Find all 2-hop neighbors in the graph. </p>
<p>Find pairs of vertices in the input graph such that each pair is connected by a path that is two hops in length.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Graph in COO format </dd></dl>
</div>
</div>
<a id="a5c86ae51264c248597c0d22c0a093fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c86ae51264c248597c0d22c0a093fa1">◆ </a></span>jaccard()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::jaccard </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const * </td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>result</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute jaccard similarity coefficient for all vertices. </p>
<p>Computes the Jaccard similarity coefficient for every pair of vertices in the graph which are connected by an edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted Jaccard, may be NULL for unweighted Jaccard. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ac32f7b2f2cf849fa8f3e4f9b8b85fd68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac32f7b2f2cf849fa8f3e4f9b8b85fd68">◆ </a></span>jaccard_list()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::jaccard_list </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const * </td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ET </td>
<td class="paramname"><em>num_pairs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>first</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>second</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>result</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute jaccard similarity coefficient for selected vertex pairs. </p>
<p>Computes the Jaccard similarity coefficient for each pair of specified vertices. Vertices are specified as pairs where pair[n] = (first[n], second[n])</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>The input vertex weights for weighted Jaccard, may be NULL for unweighted Jaccard. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_pairs</td><td>The number of vertex ID pairs specified </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Device pointer to first vertex ID of each pair </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Device pointer to second vertex ID of each pair </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a8f4653d80a07bc3703194a2ede066a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4653d80a07bc3703194a2ede066a97">◆ </a></span>k_core()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::k_core </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>vertex_id</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>core_number</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT </td>
<td class="paramname"><em>num_vertex_ids</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute K Core of the graph G. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph in coordinate format </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>Order of the core. This value must not be negative. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">vertex_id</td><td>User specified vertex identifiers for which core number values are supplied </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">core_number</td><td>User supplied core number values corresponding to vertex_id </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_vertex_ids</td><td>Number of elements in vertex_id/core_number arrays </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">out_graph</td><td>Unique pointer to K Core subgraph in COO format </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ac1b153abaf4d37f58c9ba2c4c406047a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b153abaf4d37f58c9ba2c4c406047a">◆ </a></span>k_truss_subgraph()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt; <a class="el" href="classcugraph_1_1experimental_1_1GraphCOO.html">experimental::GraphCOO</a>&lt; VT, ET, WT &gt; &gt; cugraph::k_truss_subgraph </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCOOView.html">experimental::GraphCOOView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>k</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute k truss for a graph. </p>
<p>K Truss is the maximal subgraph of a graph which contains at least three vertices where every edge is incident to at least k-2 triangles.</p>
<p>Note that current implementation does not support a weighted graph.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a COO </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">k</td><td>The order of the truss </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph </td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to K Truss subgraph in COO format </dd></dl>
</div>
</div>
<a id="a4a5cc4561f8d4351c342736c6231c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5cc4561f8d4351c342736c6231c560">◆ </a></span>katz_centrality()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT , typename result_t &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::katz_centrality </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">result_t * </td>
<td class="paramname"><em>result</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>alpha</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_iter</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>tol</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>has_guess</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>normalized</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute the Katz centrality for the nodes of the graph G. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double. </td></tr>
<tr><td class="paramname">result_t</td><td>Type of computed result. Supported values : float</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device array of centrality scores </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>Attenuation factor with a default value of 0.1. Alpha is set to 1/(lambda_max) if it is greater where lambda_max is the maximum degree of the graph. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>The maximum number of iterations before an answer is returned. This can be used to limit the execution time and do an early exit before the solver reaches the convergence tolerance. If this value is lower or equal to 0 cuGraph will use the default value, which is 100. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tol</td><td>Set the tolerance the approximation, this parameter should be a small magnitude value. The lower the tolerance the better the approximation. If this value is 0.0f, cuGraph will use the default value which is 1.0E-5. Setting too small a tolerance can lead to non-convergence due to numerical roundoff. Usually values between 0.01 and 0.00001 are acceptable. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">has_guess</td><td>Flag to determine whether <code>katz_centrality</code> contains an initial guess for katz centrality values </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">normalized</td><td>If True normalize the resulting katz centrality values </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ab5f3bcab8ac059258061c8b2dc5380d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f3bcab8ac059258061c8b2dc5380d2">◆ </a></span>louvain()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::louvain </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>final_modularity</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int * </td>
<td class="paramname"><em>num_level</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>louvain_parts</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>max_iter</em> = <code>100</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Louvain implementation. </p>
<p>Compute a clustering of the graph by minimizing modularity</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>input graph object (CSR) </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">final_modularity</td><td>modularity of the returned clustering </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">num_level</td><td>number of levels of the returned clustering </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">clustering</td><td>Pointer to device array where the clustering should be stored </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>(optional) maximum number of iterations to run (default 100) </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a0f945174cdbdf1e40211564103b2824f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f945174cdbdf1e40211564103b2824f">◆ </a></span>overlap()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::overlap </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const * </td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>result</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute overlap coefficient for all vertices in the graph. </p>
<p>Computes the Overlap Coefficient for every pair of vertices in the graph which are connected by an edge.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted overlap, may be NULL for unweighted overlap. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad8da8639b2acd1a83d738bb639e622fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8da8639b2acd1a83d738bb639e622fc">◆ </a></span>overlap_list()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::overlap_list </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT const * </td>
<td class="paramname"><em>weights</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ET </td>
<td class="paramname"><em>num_pairs</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>first</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT const * </td>
<td class="paramname"><em>second</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>result</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Compute overlap coefficient for select pairs of vertices. </p>
<p>Computes the overlap coefficient for each pair of specified vertices. Vertices are specified as pairs where pair[n] = (first[n], second[n])</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>The input graph object </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">weights</td><td>device pointer to input vertex weights for weighted overlap, may be NULL for unweighted overlap. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">num_pairs</td><td>The number of vertex ID pairs specified </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Device pointer to first vertex ID of each pair </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">second</td><td>Device pointer to second vertex ID of each pair </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Device pointer to result values, memory needs to be pre-allocated by caller </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="abe6bd1c7884de072d7d4ebebd908d7cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6bd1c7884de072d7d4ebebd908d7cd">◆ </a></span>pagerank()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::pagerank </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSCView.html">experimental::GraphCSCView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>pagerank</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT </td>
<td class="paramname"><em>personalization_subset_size</em> = <code>0</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>personalization_subset</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>personalization_values</em> = <code>nullptr</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>alpha</em> = <code>0.85</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">double </td>
<td class="paramname"><em>tolerance</em> = <code>1e-5</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int64_t </td>
<td class="paramname"><em>max_iter</em> = <code>500</code>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>has_guess</em> = <code>false</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Find the PageRank vertex values for a graph. </p>
<p>cuGraph computes an approximation of the Pagerank eigenvector using the power method. The number of iterations depends on the properties of the network itself; it increases when the tolerance descreases and/or alpha increases toward the limiting value of 1. The user is free to use default values or to provide inputs for the initial guess, tolerance and maximum number of iterations.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported value : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a transposed adjacency list (CSC). Edge weights are not used for this algorithm. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">alpha</td><td>The damping factor alpha represents the probability to follow an outgoing edge, standard value is 0.85. Thus, 1.0-alpha is the probability to “teleport” to a random vertex. Alpha should be greater than 0.0 and strictly lower than 1.0. The initial guess must not be the vector of 0s. Any value other than 1 or 0 is treated as an invalid value. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">pagerank</td><td>Array of size V. Should contain the initial guess if has_guess=true. In this case the initial guess cannot be the vector of 0s. Memory is provided and owned by the caller. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">personalization_subset_size</td><td>(optional) The number of vertices for to personalize. Initialized to 0 by default. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">personalization_subset</td><td>(optional) Array of size personalization_subset_size containing vertices for running personalized pagerank. Initialized to nullptr by default. Memory is provided and owned by the caller. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">personalization_values</td><td>(optional) Array of size personalization_subset_size containing values associated with personalization_subset vertices. Initialized to nullptr by default. Memory is provided and owned by the caller. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>Set the tolerance the approximation, this parameter should be a small magnitude value. The lower the tolerance the better the approximation. If this value is 0.0f, cuGRAPH will use the default value which is 1.0E-5. Setting too small a tolerance can lead to non-convergence due to numerical roundoff. Usually values between 0.01 and 0.00001 are acceptable. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">max_iter</td><td>(optional) The maximum number of iterations before an answer is returned. This can be used to limit the execution time and do an early exit before the solver reaches the convergence tolerance. If this value is lower or equal to 0 cuGRAPH will use the default value, which is 500. </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">has_guess</td><td>(optional) This parameter is used to notify cuGRAPH if it should use a user-provided initial guess. False means the user does not have a guess, in this case cuGRAPH will use a uniform vector set to 1/V. If the value is True, cuGRAPH will read the pagerank parameter and use this as an initial guess. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">*pagerank</td><td>The PageRank : pagerank[i] is the PageRank of vertex i. Memory remains provided and owned by the caller. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a3eba88220e47be34a4351a4378116545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eba88220e47be34a4351a4378116545">◆ </a></span>renumber_vertices()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT_IN , typename VT_OUT , typename ET &gt; </div>
<table class="memname">
<tr>
<td class="memname">std::unique_ptr&lt; rmm::device_buffer &gt; cugraph::renumber_vertices </td>
<td>(</td>
<td class="paramtype">ET </td>
<td class="paramname"><em>number_of_edges</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_IN const * </td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_IN const * </td>
<td class="paramname"><em>dst</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_OUT * </td>
<td class="paramname"><em>src_renumbered</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT_OUT * </td>
<td class="paramname"><em>dst_renumbered</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">ET * </td>
<td class="paramname"><em>map_size</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">rmm::mr::device_memory_resource * </td>
<td class="paramname"><em>mr</em> = <code>rmm::mr::get_default_resource()</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Renumber source and destination indices. </p>
<p>Renumber source and destination indexes to be a dense numbering, using contiguous values between 0 and number of vertices minus 1.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT_IN</td><td>type of vertex index input </td></tr>
<tr><td class="paramname">VT_OUT</td><td>type of vertex index output </td></tr>
<tr><td class="paramname">ET</td><td>type of edge index</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">number_of_edges</td><td>number of edges in the graph </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Pointer to device memory containing source vertex ids </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">dst</td><td>Pointer to device memory containing destination vertex ids </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">src_renumbered</td><td>Pointer to device memory containing the output source vertices. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">dst_renumbered</td><td>Pointer to device memory containing the output destination vertices. </td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">map_size</td><td>Pointer to local memory containing the number of elements in the renumbering map </td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">mr</td><td>Memory resource used to allocate the returned graph</td></tr>
</table>
</dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unique pointer to renumbering map </dd></dl>
</div>
</div>
<a id="ad46fa64646df0df9737055649c7acc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad46fa64646df0df9737055649c7acc71">◆ </a></span>sssp()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT , typename ET , typename WT &gt; </div>
<table class="memname">
<tr>
<td class="memname">void cugraph::sssp </td>
<td>(</td>
<td class="paramtype"><a class="el" href="classcugraph_1_1experimental_1_1GraphCSRView.html">experimental::GraphCSRView</a>&lt; VT, ET, WT &gt; const &amp; </td>
<td class="paramname"><em>graph</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">WT * </td>
<td class="paramname"><em>distances</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">VT * </td>
<td class="paramname"><em>predecessors</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const VT </td>
<td class="paramname"><em>source_vertex</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Native sssp with predecessors. </p>
<p>------------------------------------------------------------------------—* </p>
<h2><a class="anchor" id="autotoc_md7"></a>
@file sssp.cu</h2>
<p>@Synopsis Performs a single source shortest path traversal of a graph starting from a vertex.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
<table class="exception">
<tr><td class="paramname"><a class="el" href="structcugraph_1_1logic__error.html" title="Exception thrown when logical precondition is violated.">cugraph::logic_error</a></td><td>with a custom message when an error occurs.</td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">VT</td><td>Type of vertex identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">ET</td><td>Type of edge identifiers. Supported value : int (signed, 32-bit) </td></tr>
<tr><td class="paramname">WT</td><td>Type of edge weights. Supported values : float or double.</td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramdir">[in]</td><td class="paramname">graph</td><td>cuGRAPH graph descriptor, should contain the connectivity information as a CSR</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">distances</td><td>If set to a valid pointer, array of size V populated by distance of every vertex in the graph from the starting vertex. Memory is provided and owned by the caller.</td></tr>
<tr><td class="paramdir">[out]</td><td class="paramname">predecessors</td><td>If set to a valid pointer, array of size V populated by the SSSP predecessor of every vertex. Memory is provided and owned by the caller.</td></tr>
<tr><td class="paramdir">[in]</td><td class="paramname">start_vertex</td><td>The starting vertex for SSSP </td></tr>
</table>
</dd>
</dl>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by  <a href="http://www.doxygen.org/index.html">
<img alt="doxygen" class="footer" src="doxygen.png"/>
</a> 1.8.18
</small></address>
<script defer id="rapids-selector-js" src="/assets/js/custom.js"></script></body>
</html>
