
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>API &#8212; kvikio 22.08.00 documentation</title>
<script>
  document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
  document.documentElement.dataset.theme = localStorage.getItem("theme") || "light"
</script>

  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=92025949c220c2e29695" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=92025949c220c2e29695" rel="stylesheet">


  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Welcome to kvikIOâ€™s documentation!" href="index.html" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">
    <div class="bd-header-announcement container-fluid" id="banner">
      

    </div>

    
    <nav class="bd-header navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="bd-header__inner container-xl">

  <div id="navbar-start">
    
    
  


<a class="navbar-brand logo" href="index.html">
  
  
  
  
    <img src="_static/RAPIDS-logo-purple.png" class="logo__image only-light" alt="Logo image">
    <img src="_static/RAPIDS-logo-purple.png" class="logo__image only-dark" alt="Logo image">
  
  
</a>
    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="fas fa-bars"></span>
  </button>

  
  <div id="navbar-collapsible" class=" collapse navbar-collapse">
    <div id="navbar-center" class="ml-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  API
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <span id="theme-switch" class="btn btn-sm btn-outline-primary navbar-btn rounded-circle">
    <a class="theme-switch" data-mode="light"><i class="fas fa-sun"></i></a>
    <a class="theme-switch" data-mode="dark"><i class="far fa-moon"></i></a>
    <a class="theme-switch" data-mode="auto"><i class="fas fa-adjust"></i></a>
</span>
      </div>
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/rapidsai/kvikio" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://twitter.com/rapidsai" rel="noopener" target="_blank" title="Twitter"><span><i class="fab fa-twitter-square"></i></span>
            <label class="sr-only">Twitter</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="bd-container container-xl">
      <div class="bd-container__inner row">
          

<!-- Only show if we have sidebars configured, else just a small margin  -->
<div class="bd-sidebar-primary col-12 col-md-3 bd-sidebar">
  <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
  </div>
  <div class="sidebar-end-items">
  </div>
</div>


          


<div class="bd-sidebar-secondary d-none d-xl-block col-xl-2 bd-toc">
  
    
    <div class="toc-item">
      
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cufile">
   CuFile
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#zarr">
   Zarr
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#defaults">
   Defaults
  </a>
 </li>
</ul>

</nav>
    </div>
    
    <div class="toc-item">
      
    </div>
    
  
</div>


          
          
          <div class="bd-content col-12 col-md-9 col-xl-7">
              
              <article class="bd-article" role="main">
                
  <section id="api">
<h1>API<a class="headerlink" href="#api" title="Permalink to this heading">#</a></h1>
<section id="cufile">
<h2>CuFile<a class="headerlink" href="#cufile" title="Permalink to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kvikio.cufile.</span></span><span class="sig-name descname"><span class="pre">CuFile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Union</span><span class="p"><span class="pre">[</span></span><span class="pre">Path</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">str</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'r'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kvikio.cufile.CuFile" title="Permalink to this definition">#</a></dt>
<dd><p>File handle for GPUDirect Storage (GDS)</p>
<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.close" title="Permalink to this definition">#</a></dt>
<dd><p>Deregister the file and close the file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.fileno">
<span class="sig-name descname"><span class="pre">fileno</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.fileno" title="Permalink to this definition">#</a></dt>
<dd><p>Get the file descripter of the open file</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.open_flags">
<span class="sig-name descname"><span class="pre">open_flags</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.open_flags" title="Permalink to this definition">#</a></dt>
<dd><p>Get the flags of the file descripter (see open(2))</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.pread">
<span class="sig-name descname"><span class="pre">pread</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kvikio.cufile.IOFuture" title="kvikio.cufile.IOFuture"><span class="pre">IOFuture</span></a></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.pread" title="Permalink to this definition">#</a></dt>
<dd><p>Reads specified bytes from the file into the device memory in parallel</p>
<p><cite>pread</cite> reads the data from a specified file at a specified offset and size
bytes into the GPU memory by using GDS functionality. The API works correctly
for unaligned offsets and any data size, although the performance might not
match the performance of aligned reads.</p>
<p><cite>pread</cite> is non-blocking and returns a <cite>IOFuture</cite> that can be waited upon. It
partitions the operation into tasks of size <cite>task_size</cite> for execution in the
default thread pool.</p>
<dl class="simple">
<dt>buf: buffer-like or array-like</dt><dd><p>Device buffer to read into.</p>
</dd>
<dt>size: int</dt><dd><p>Size in bytes to read.</p>
</dd>
<dt>file_offset: int, optional</dt><dd><p>Offset in the file to read from.</p>
</dd>
<dt>task_size: int, default=kvikio.defaults.task_size()</dt><dd><p>Size of each task in bytes.</p>
</dd>
</dl>
<dl class="simple">
<dt>IOFuture</dt><dd><p>Future that on completion returns the size of bytes that were successfully
read.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.pwrite">
<span class="sig-name descname"><span class="pre">pwrite</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#kvikio.cufile.IOFuture" title="kvikio.cufile.IOFuture"><span class="pre">IOFuture</span></a></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.pwrite" title="Permalink to this definition">#</a></dt>
<dd><p>Writes specified bytes from the device memory into the file in parallel</p>
<p><cite>pwrite</cite> writes the data from the GPU memory to the file at a specified
offset and size bytes by using GDS functionality. The API works correctly
for unaligned offset and data sizes, although the performance is not on-par
with aligned writes.</p>
<p><cite>pwrite</cite> is non-blocking and returns a <cite>IOFuture</cite> that can be waited upon. It
partitions the operation into tasks of size <cite>task_size</cite> for execution in the
default thread pool.</p>
<dl class="simple">
<dt>buf: buffer-like or array-like</dt><dd><p>Device buffer to write to.</p>
</dd>
<dt>size: int</dt><dd><p>Size in bytes to read.</p>
</dd>
<dt>file_offset: int, optional</dt><dd><p>Offset in the file to write from.</p>
</dd>
<dt>task_size: int, default=kvikio.defaults.task_size()</dt><dd><p>Size of each task in bytes.</p>
</dd>
</dl>
<dl class="simple">
<dt>IOFuture</dt><dd><p>Future that on completion returns the size of bytes that were successfully
written.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.raw_read">
<span class="sig-name descname"><span class="pre">raw_read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.raw_read" title="Permalink to this definition">#</a></dt>
<dd><p>Reads specified bytes from the file into the device memory</p>
<p>This is a low-level version of <cite>.read</cite> that doesnâ€™t use threads.</p>
<dl class="simple">
<dt>buf: buffer-like or array-like</dt><dd><p>Device buffer to read into.</p>
</dd>
<dt>size: int</dt><dd><p>Size in bytes to read.</p>
</dd>
<dt>file_offset: int, optional</dt><dd><p>Offset in the file to read from.</p>
</dd>
<dt>dev_offset: int, optional</dt><dd><p>Offset in the <cite>buf</cite> to read from.</p>
</dd>
</dl>
<dl class="simple">
<dt>int</dt><dd><p>The size of bytes that were successfully read.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.raw_write">
<span class="sig-name descname"><span class="pre">raw_write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dev_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.raw_write" title="Permalink to this definition">#</a></dt>
<dd><p>Writes specified bytes from the device memory into the file</p>
<p>This is a low-level version of <cite>.write</cite> that doesnâ€™t use threads.</p>
<dl class="simple">
<dt>buf: buffer-like or array-like</dt><dd><p>Device buffer to write to.</p>
</dd>
<dt>size: int</dt><dd><p>Size in bytes to read.</p>
</dd>
<dt>file_offset: int, optional</dt><dd><p>Offset in the file to write from.</p>
</dd>
<dt>dev_offset: int, optional</dt><dd><p>Offset in the <cite>buf</cite> to write from.</p>
</dd>
</dl>
<dl class="simple">
<dt>int</dt><dd><p>The size of bytes that were successfully written.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.read">
<span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.read" title="Permalink to this definition">#</a></dt>
<dd><p>Reads specified bytes from the file into the device memory in parallel</p>
<p>This is a blocking version of <cite>.pread</cite>.</p>
<dl class="simple">
<dt>buf: buffer-like or array-like</dt><dd><p>Device buffer to read into.</p>
</dd>
<dt>size: int</dt><dd><p>Size in bytes to read.</p>
</dd>
<dt>file_offset: int, optional</dt><dd><p>Offset in the file to read from.</p>
</dd>
<dt>task_size: int, default=kvikio.defaults.task_size()</dt><dd><p>Size of each task in bytes.</p>
</dd>
</dl>
<dl class="simple">
<dt>int</dt><dd><p>The size of bytes that were successfully read.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.CuFile.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Optional</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file_offset</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">task_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.CuFile.write" title="Permalink to this definition">#</a></dt>
<dd><p>Writes specified bytes from the device memory into the file in parallel</p>
<p>This is a blocking version of <cite>.pwrite</cite>.</p>
<dl class="simple">
<dt>buf: buffer-like or array-like</dt><dd><p>Device buffer to write to.</p>
</dd>
<dt>size: int</dt><dd><p>Size in bytes to read.</p>
</dd>
<dt>file_offset: int, optional</dt><dd><p>Offset in the file to write from.</p>
</dd>
<dt>task_size: int, default=kvikio.defaults.task_size()</dt><dd><p>Size of each task in bytes.</p>
</dd>
</dl>
<dl class="simple">
<dt>int</dt><dd><p>The size of bytes that were successfully written.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="kvikio.cufile.IOFuture">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kvikio.cufile.</span></span><span class="sig-name descname"><span class="pre">IOFuture</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">handle</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kvikio.cufile.IOFuture" title="Permalink to this definition">#</a></dt>
<dd><p>Future for CuFile IO</p>
<p>This class shouldnâ€™t be used directly, instead non-blocking IO operations such
as <cite>CuFile.pread</cite> and <cite>CuFile.pwrite</cite> returns an instance of this class. Use
<cite>.get()</cite> to wait on the completion of the IO operation and retrieve the result.</p>
<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.IOFuture.done">
<span class="sig-name descname"><span class="pre">done</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kvikio.cufile.IOFuture.done" title="Permalink to this definition">#</a></dt>
<dd><p>Return True if the future is done.</p>
<dl class="simple">
<dt>bool</dt><dd><p>Whether the future is done or not</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="kvikio.cufile.IOFuture.get">
<span class="sig-name descname"><span class="pre">get</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.cufile.IOFuture.get" title="Permalink to this definition">#</a></dt>
<dd><p>Retrieve the result of the IO operation that created this future</p>
<p>This call blocks until the IO operation finishes.</p>
<dl class="simple">
<dt>int</dt><dd><p>The size of bytes that were read or written successfully.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="zarr">
<h2>Zarr<a class="headerlink" href="#zarr" title="Permalink to this heading">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="kvikio.zarr.GDSStore">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">kvikio.zarr.</span></span><span class="sig-name descname"><span class="pre">GDSStore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize_keys</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dimension_separator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#kvikio.zarr.GDSStore" title="Permalink to this definition">#</a></dt>
<dd><p>GPUDirect Storage (GDS) class using directories and files.</p>
<p>This class works like <cite>zarr.storage.DirectoryStore</cite> but use GPU
buffers and will use GDS when applicable.
The store supports both CPU and GPU buffers but when reading, GPU
buffers are returned always.</p>
<p>TODO: Write metadata to disk in order to perserve the item types such that
GPU items are read as GPU device buffers and CPU items are read as bytes.</p>
</dd></dl>

</section>
<section id="defaults">
<h2>Defaults<a class="headerlink" href="#defaults" title="Permalink to this heading">#</a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="kvikio.defaults.compat_mode">
<span class="sig-prename descclassname"><span class="pre">kvikio.defaults.</span></span><span class="sig-name descname"><span class="pre">compat_mode</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#kvikio.defaults.compat_mode" title="Permalink to this definition">#</a></dt>
<dd><p>Check if KvikIO is running in compatibility mode.</p>
<p>Notice, this is not the same as the compatibility mode in cuFile. That is,
cuFile can run in compatibility mode while KvikIO is not.</p>
<p>When KvikIO is running in compatibility mode, it doesnâ€™t load <cite>libcufile.so</cite>.
Instead, reads and writes are done using POSIX.</p>
<p>Set the environment variable <cite>KVIKIO_COMPAT_MODE</cite> to enable/disable compatibility
mode. By default, compatibility mode is enabled:</p>
<blockquote>
<div><ul class="simple">
<li><p>when <cite>libcufile</cite> cannot be found</p></li>
<li><p>when running in Windows Subsystem for Linux (WSL)</p></li>
<li><p>when <cite>/run/udev</cite> isnâ€™t readable, which typically happens when running inside
a docker image not launched with <cite>â€“volume /run/udev:/run/udev:ro</cite></p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>bool</dt><dd><p>Whether KvikIO is running in compatibility mode or not.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kvikio.defaults.compat_mode_reset">
<span class="sig-prename descclassname"><span class="pre">kvikio.defaults.</span></span><span class="sig-name descname"><span class="pre">compat_mode_reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#kvikio.defaults.compat_mode_reset" title="Permalink to this definition">#</a></dt>
<dd><p>Reset the compatibility mode.</p>
<p>Use this function to enable/disable compatibility mode explicitly.</p>
<dl class="simple">
<dt>enable<span class="classifier">bool</span></dt><dd><p>Set to True to enable and False to disable compatibility mode</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kvikio.defaults.get_num_threads">
<span class="sig-prename descclassname"><span class="pre">kvikio.defaults.</span></span><span class="sig-name descname"><span class="pre">get_num_threads</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#kvikio.defaults.get_num_threads" title="Permalink to this definition">#</a></dt>
<dd><p>Get the number of threads of the thread pool.</p>
<p>Set the default value using <cite>reset_num_threads()</cite> or by setting the
<cite>KVIKIO_NTHREADS</cite> environment variable. If not set, the default value is 1.</p>
<dl class="simple">
<dt>nthreads: int</dt><dd><p>The number of threads in the current thread pool.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="kvikio.defaults.reset_num_threads">
<span class="sig-prename descclassname"><span class="pre">kvikio.defaults.</span></span><span class="sig-name descname"><span class="pre">reset_num_threads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nthreads</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#kvikio.defaults.reset_num_threads" title="Permalink to this definition">#</a></dt>
<dd><p>Reset the number of threads in the default thread pool.</p>
<p>Waits for all currently running tasks to be completed, then destroys all threads
in the pool and creates a new thread pool with the new number of threads. Any
tasks that were waiting in the queue before the pool was reset will then be
executed by the new threads. If the pool was paused before resetting it, the new
pool will be paused as well.</p>
<dl class="simple">
<dt>nthreads<span class="classifier">int</span></dt><dd><p>The number of threads to use.</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


              </article>
              

              
              <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="index.html" title="previous page">
      <i class="fas fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Welcome to kvikIOâ€™s documentation!</p>
      </div>
  </a>
</div>
              </footer>
              
          </div>
          
      </div>
    </div>

  
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=92025949c220c2e29695"></script>

<footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    <p class="copyright">
    &copy; Copyright 2022, NVIDIA.<br>
</p>
  </div>
  
  <div class="footer-item">
    <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 5.0.2.<br>
</p>
  </div>
  
</div>
</footer>
  </body>
</html>